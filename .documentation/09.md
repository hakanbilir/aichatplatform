# 9. Conversations & Chat API (REST + SSE Streaming)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Implement **conversation & chat APIs** in `apps/api-gateway` so that:
>
> - Clients can **create and list conversations** for the authenticated user/org.  
> - Clients can **send messages** to a conversation (non‑streaming).  
> - Clients can **stream assistant responses** via **Server‑Sent Events (SSE)**.  
> - All chat flows go through the **chat orchestrator** and are **persisted** to the database.
>
> After following this file, the backend will provide a functional, ChatGPT‑style chat API with streaming support, ready for the web UI.

> **Important instructions to AI agents:**
> - Reuse the existing Prisma models (`Conversation`, `Message`) and orchestrator from previous files.  
> - Do **not** duplicate DB schemas or types already defined in 5.md, 6.md, 7.md, 8.md.  
> - Ensure that only **authorized** users can access conversations (owner or member of the org).

---

## 9.1. High‑Level Design

### 9.1.1. Conversation Lifecycle

1. **Create conversation** – user creates a conversation with optional title/system prompt/model.  
2. **Send message** – user posts a new message to a conversation:
   - Non‑streaming: backend returns full assistant message after completion.  
   - Streaming: backend sends tokens progressively via SSE.
3. **Persistence** – both user and assistant messages are stored in `Message` table.

### 9.1.2. Core Endpoints

We implement the following endpoints (all **authenticated**):

- `GET /conversations` – list conversations for the current user/org.  
- `POST /conversations` – create a new conversation.  
- `GET /conversations/:id` – get conversation details with recent messages.  
- `POST /conversations/:id/messages` – send a message (non‑streaming).  
- `POST /conversations/:id/stream` – send a message and stream assistant reply via SSE.

> **Note:** Deleting or archiving conversations will be handled in a later file.

---

## 9.2. Update `apps/api-gateway/package.json`

We need the orchestrator package in the API gateway.

Update `apps/api-gateway/package.json` **dependencies** to include `@ai-chat/chat-orchestrator`:

```jsonc
{
  "dependencies": {
    // ...existing deps...
    "@ai-chat/chat-orchestrator": "0.1.0"
  }
}
```

> **AI Agent Note:**  
> Merge carefully; do not remove existing dependencies. After editing, run `pnpm install` at the repo root.

---

## 9.3. Conversation Routes – List, Create, Detail

We implement REST routes for conversation management.

### 9.3.1. Create `apps/api-gateway/src/routes/conversations.ts`

Create `apps/api-gateway/src/routes/conversations.ts` with:

```ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';

const createConversationBodySchema = z.object({
  title: z.string().min(1).optional(),
  systemPrompt: z.string().optional(),
  model: z.string().optional(),
  temperature: z.number().min(0).max(2).optional(),
  topP: z.number().min(0).max(1).optional()
});

export default async function conversationsRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // List conversations for current user
  app.get('/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    // Find all orgs the user belongs to
    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      select: { orgId: true }
    });

    const orgIds = memberships.map((m) => m.orgId);

    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversations = await prisma.conversation.findMany({
      where: {
        OR: orConditions
      },
      orderBy: {
        updatedAt: 'desc'
      },
      take: 50,
      include: {
        messages: {
          orderBy: { createdAt: 'desc' },
          take: 1
        }
      }
    });

    return reply.send({
      conversations: conversations.map((c) => ({
        id: c.id,
        title: c.title,
        model: c.model,
        createdAt: c.createdAt,
        updatedAt: c.updatedAt,
        orgId: c.orgId,
        lastMessage: c.messages[0]
          ? {
              id: c.messages[0].id,
              role: c.messages[0].role,
              createdAt: c.messages[0].createdAt
            }
          : null
      }))
    });
  });

  // Create a new conversation
  app.post('/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parseResult = createConversationBodySchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.code(400).send({ error: 'Invalid conversation data', details: parseResult.error.format() });
    }

    const { title, systemPrompt, model, temperature, topP } = parseResult.data;

    const conversation = await prisma.conversation.create({
      data: {
        title: title ?? 'New Conversation',
        systemPrompt: systemPrompt ?? undefined,
        model: model ?? 'llama3.1',
        temperature: temperature ?? 0.7,
        topP: topP ?? 1,
        userId: payload.userId,
        orgId: payload.orgId
      }
    });

    return reply.code(201).send({
      id: conversation.id,
      title: conversation.title,
      model: conversation.model,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      orgId: conversation.orgId
    });
  });

  // Get conversation details + recent messages
  app.get('/conversations/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);

    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }

    const conversationId = parseParams.data.id;

    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      select: { orgId: true }
    });
    const orgIds = memberships.map((m) => m.orgId);

    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
          take: 200
        }
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    return reply.send({
      conversation: {
        id: conversation.id,
        title: conversation.title,
        model: conversation.model,
        systemPrompt: conversation.systemPrompt,
        temperature: conversation.temperature,
        topP: conversation.topP,
        createdAt: conversation.createdAt,
        updatedAt: conversation.updatedAt,
        orgId: conversation.orgId,
        messages: conversation.messages.map((m) => ({
          id: m.id,
          role: m.role,
          content: m.content,
          createdAt: m.createdAt
        }))
      }
    });
  });
}
```

> **AI Agent Note:**  
> We use a simple org membership query to ensure users only see conversations they own or that belong to orgs they are members of.

---

## 9.4. Chat Routes – Non‑Streaming & Streaming via SSE

We now implement chat routes that:

- Load conversation + history from DB.  
- Build `ConversationContext` for the orchestrator.  
- Persist the **user message** immediately.  
- Persist the **assistant message** when the response is ready.  
- Stream tokens via SSE (for `/stream`).

### 9.4.1. Create `apps/api-gateway/src/routes/chat.ts`

Create `apps/api-gateway/src/routes/chat.ts` with:

```ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import {
  ConversationContext,
  OrchestratorOptions,
  createUserMessage,
  runChatCompletion,
  streamChatCompletionOrchestrated
} from '@ai-chat/chat-orchestrator';
import { ChatMessage, ChatRole, ChatStreamEvent } from '@ai-chat/core-types';
import { z } from 'zod';

const sendMessageBodySchema = z.object({
  content: z.string().min(1),
  model: z.string().optional(),
  temperature: z.number().min(0).max(2).optional(),
  topP: z.number().min(0).max(1).optional(),
  maxTokens: z.number().int().positive().optional()
});

function mapDbRoleToChatRole(dbRole: string): ChatRole {
  switch (dbRole) {
    case 'SYSTEM':
      return 'system';
    case 'ASSISTANT':
      return 'assistant';
    case 'TOOL':
      return 'tool';
    case 'USER':
    default:
      return 'user';
  }
}

function buildConversationContext(conversation: any): ConversationContext {
  const history: ChatMessage[] = conversation.messages.map((m: any) => ({
    id: m.id,
    role: mapDbRoleToChatRole(m.role),
    content: m.content,
    createdAt: m.createdAt.toISOString()
  }));

  const ctx: ConversationContext = {
    id: conversation.id,
    title: conversation.title ?? undefined,
    systemPrompt: conversation.systemPrompt ?? undefined,
    customInstructions: undefined, // can be filled from user profile later
    history
  };

  return ctx;
}

export default async function chatRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  const orchestratorOptions: OrchestratorOptions = {
    maxContextTokens: 4000
  };

  // Non-streaming message send
  app.post('/conversations/:id/messages', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }
    const conversationId = parseParams.data.id;

    const parseBody = sendMessageBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid message data', details: parseBody.error.format() });
    }

    const { content, model, temperature, topP, maxTokens } = parseBody.data;

    // Load conversation + messages, ensuring access rights
    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      select: { orgId: true }
    });
    const orgIds = memberships.map((m) => m.orgId);

    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
          take: 200
        }
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    // Persist user message immediately
    const userMessageRecord = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        role: 'USER',
        content,
        meta: {}
      }
    });

    // Add new message to in-memory history for this run
    const conversationWithNewMessage = {
      ...conversation,
      messages: [...conversation.messages, userMessageRecord]
    };

    const context = buildConversationContext(conversationWithNewMessage);
    const userMessage = createUserMessage(content);

    const response = await runChatCompletion(
      context,
      userMessage,
      orchestratorOptions,
      {
        model: model ?? conversation.model,
        temperature: temperature ?? conversation.temperature ?? 0.7,
        topP: topP ?? conversation.topP ?? 1,
        maxTokens
      }
    );

    // Persist assistant message
    const assistantMessageRecord = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        role: 'ASSISTANT',
        content: response.message.content,
        meta: {
          usage: response.usage ?? null,
          providerMeta: response.providerMeta ?? null
        }
      }
    });

    // Update conversation's updatedAt implicitly (via Prisma) or explicitly with a touch
    await prisma.conversation.update({
      where: { id: conversation.id },
      data: {
        updatedAt: new Date()
      }
    });

    return reply.send({
      conversationId: conversation.id,
      userMessage: {
        id: userMessageRecord.id,
        role: userMessageRecord.role,
        content: userMessageRecord.content,
        createdAt: userMessageRecord.createdAt
      },
      assistantMessage: {
        id: assistantMessageRecord.id,
        role: assistantMessageRecord.role,
        content: assistantMessageRecord.content,
        createdAt: assistantMessageRecord.createdAt
      },
      usage: response.usage
    });
  });

  // Streaming message send via SSE
  app.post('/conversations/:id/stream', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }
    const conversationId = parseParams.data.id;

    const parseBody = sendMessageBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid message data', details: parseBody.error.format() });
    }

    const { content, model, temperature, topP, maxTokens } = parseBody.data;

    // Load conversation + messages, ensuring access rights
    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      select: { orgId: true }
    });
    const orgIds = memberships.map((m) => m.orgId);

    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
          take: 200
        }
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    // Persist user message immediately
    const userMessageRecord = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        role: 'USER',
        content,
        meta: {}
      }
    });

    const conversationWithNewMessage = {
      ...conversation,
      messages: [...conversation.messages, userMessageRecord]
    };

    const context = buildConversationContext(conversationWithNewMessage);
    const userMessage = createUserMessage(content);

    // Set up SSE headers
    reply.raw.setHeader('Content-Type', 'text/event-stream');
    reply.raw.setHeader('Cache-Control', 'no-cache');
    reply.raw.setHeader('Connection', 'keep-alive');
    reply.raw.flushHeaders?.();

    const sendEvent = (event: unknown) => {
      reply.raw.write(`data: ${JSON.stringify(event)}\n\n`);
    };

    const abortController = new AbortController();

    request.raw.on('close', () => {
      abortController.abort();
    });

    let finalAssistantContent = '';
    let finalUsage: any = null;

    try {
      for await (const event of streamChatCompletionOrchestrated(
        context,
        userMessage,
        orchestratorOptions,
        {
          model: model ?? conversation.model,
          temperature: temperature ?? conversation.temperature ?? 0.7,
          topP: topP ?? conversation.topP ?? 1,
          maxTokens,
          signal: abortController.signal
        }
      )) {
        const outgoing: any = { type: event.type };

        if (event.type === 'token' && event.token) {
          outgoing.token = event.token;
          finalAssistantContent += event.token;
        }

        if (event.type === 'end') {
          if (event.finalMessage) {
            finalAssistantContent = event.finalMessage.content;
          }
          outgoing.message = {
            role: 'assistant',
            content: finalAssistantContent
          };
          if (event.usage) {
            outgoing.usage = event.usage;
            finalUsage = event.usage;
          }
        }

        if (event.type === 'error' && event.error) {
          outgoing.error = event.error;
        }

        sendEvent(outgoing as ChatStreamEvent);
      }

      // Persist assistant message if we have any content
      if (finalAssistantContent.length > 0) {
        await prisma.message.create({
          data: {
            conversationId: conversation.id,
            role: 'ASSISTANT',
            content: finalAssistantContent,
            meta: {
              usage: finalUsage,
              providerMeta: null
            }
          }
        });

        await prisma.conversation.update({
          where: { id: conversation.id },
          data: {
            updatedAt: new Date()
          }
        });
      }

      reply.raw.end();
    } catch (err) {
      // In case of an unexpected error, send an error event if possible
      try {
        sendEvent({ type: 'error', error: (err as Error).message });
        reply.raw.end();
      } catch {
        // Ignore if connection already closed
      }
    }
  });
}
```

> **AI Agent Note:**  
> - SSE payloads are simple JSON objects with a `type` field (`start`, `token`, `end`, `error`).  
> - The frontend will use `EventSource` to consume this stream.

---

## 9.5. Wire New Routes in `src/main.ts`

We now register the new routes in the API gateway.

Update `apps/api-gateway/src/main.ts` to import and register the new route modules.

> **AI Agent Note:** Replace the entire contents of `apps/api-gateway/src/main.ts` with the code below (it preserves everything from 8.md and adds conversation/chat routes).

```ts
import fastify from 'fastify';
import cors from 'fastify-cors';
import { getConfig } from '@ai-chat/config';
import { ensureDbExtensions, checkDbConnection } from '@ai-chat/db';
import authPlugin from './plugins/auth';
import authRoutes from './routes/auth';
import orgRoutes from './routes/orgs';
import conversationsRoutes from './routes/conversations';
import chatRoutes from './routes/chat';

async function buildServer() {
  const config = getConfig();

  const app = fastify({
    logger: {
      level: config.LOG_LEVEL
    }
  });

  await app.register(cors, {
    origin: true,
    credentials: true
  });

  // Health check route (no auth)
  app.get('/health', async () => {
    const dbOk = await checkDbConnection();
    return {
      status: 'ok',
      env: config.NODE_ENV,
      db: dbOk ? 'up' : 'down',
      defaultModel: config.DEFAULT_MODEL
    };
  });

  // Auth plugin (JWT + authenticate hook)
  await app.register(authPlugin);

  // Routes
  await app.register(authRoutes);
  await app.register(orgRoutes);
  await app.register(conversationsRoutes);
  await app.register(chatRoutes);

  // Ensure DB extensions
  await ensureDbExtensions();

  return app;
}

async function start() {
  const config = getConfig();
  const port = config.API_PORT;
  const host = config.API_HOST;

  const app = await buildServer();

  app
    .listen({ port, host })
    .then(() => {
      app.log.info(`API Gateway listening on http://${host}:${port}`);
    })
    .catch((err) => {
      app.log.error(err, 'Failed to start API Gateway');
      process.exit(1);
    });
}

start();
```

---

## 9.6. Sanity Checks

After implementing all changes in this file, run the following from the repo root:

1. **Install any new dependencies:**

   ```bash
   pnpm install
   ```

2. **Build the monorepo:**

   ```bash
   pnpm build
   ```

3. **Start the API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

4. **Test Conversations API (example with `curl`):**

   - List conversations (replace `TOKEN` with JWT):

     ```bash
     curl http://localhost:4000/conversations \
       -H "Authorization: Bearer TOKEN"
     ```

   - Create conversation:

     ```bash
     curl -X POST http://localhost:4000/conversations \
       -H "Authorization: Bearer TOKEN" \
       -H "Content-Type: application/json" \
       -d '{"title":"My Chat","systemPrompt":"You are a helpful assistant."}'
     ```

   - Get conversation details:

     ```bash
     curl http://localhost:4000/conversations/CONV_ID \
       -H "Authorization: Bearer TOKEN"
     ```

5. **Test Non‑Streaming Chat:**

   ```bash
   curl -X POST http://localhost:4000/conversations/CONV_ID/messages \
     -H "Authorization: Bearer TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"content":"Hello!"}'
   ```

6. **Test Streaming Chat (SSE) from browser console:**

   ```js
   const source = new EventSource('http://localhost:4000/conversations/CONV_ID/stream', {
     withCredentials: true
   });

   source.onmessage = (event) => {
     const data = JSON.parse(event.data);
     console.log('SSE event', data);
   };
   ```

   > **Note:** For POST + SSE, you’ll typically use `fetch` from the frontend and not `EventSource` directly. In the web app implementation, we will wire a proper streaming client. Here, the goal is to validate that SSE frames are emitted.

If all the above succeed, you now have a fully functional **conversation + chat API with persistence and streaming**, ready to be used by the Material 3 web UI.

---

## 9.7. Next Steps

With chat APIs in place, upcoming markdown files will:

- Implement the **web frontend** chat UI (Material 3, gradients, micro‑interactions).  
- Add **Grafana‑ready metrics** for per‑conversation usage and latency.  
- Extend chat orchestration with **tools** and **RAG** (knowledge base integration).

> **AI Agent Instruction:**  
> Before proceeding, ensure that:
> - `pnpm build` passes.  
> - You can create conversations, send messages, and stream replies end‑to‑end through the API.

---

_End of 9.md – Conversations & Chat API (REST + SSE Streaming)_
