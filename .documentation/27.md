# 27. Tools Panel & Tool Call Inspector (Frontend UI)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Add a **Material 3 + Grafana‑inspired tools panel** to the web app so power‑users can:
>
> - Discover which tools are available (`time.now`, `org.usageSnapshot`, `conversation.searchMessages`, etc.).  
> - Execute tools manually for a given conversation/org context.  
> - Inspect tool request/response JSON in a developer‑friendly way.  
> - Toggle it from within **ChatPage**, without breaking the main chat flow.
>
> This panel uses the backend tools engine from 26.md and is safe for production use and debugging.

> **Important instructions to AI agents:**
> - Treat this file as canonical for the **frontend tools panel**.  
> - Do not change backend routes; they are defined in 26.md (`/tools`, `/tools/execute`, `/tools/execute-envelope`).  
> - All code must be complete and compilable; no placeholders.

---

## 27.1. Frontend API Client for Tools

We add a small typed client for the tools HTTP API.

### 27.1.1. Create `apps/web/src/api/tools.ts`

```ts
// apps/web/src/api/tools.ts

import { apiRequest } from './client';

export interface ToolDescription {
  name: string;
  description: string;
  argsSchema: any;
}

export interface ListToolsResponse {
  tools: ToolDescription[];
}

export interface ToolExecutionResult {
  tool: string;
  ok: boolean;
  result?: unknown;
  error?: string;
}

export interface ExecuteToolResponse extends ToolExecutionResult {}

export interface ExecuteEnvelopeResponse {
  results: ToolExecutionResult[];
}

export async function listTools(
  token: string,
  params: { conversationId?: string | null; orgId?: string | null } = {}
): Promise<ListToolsResponse> {
  const searchParams = new URLSearchParams();

  if (params.conversationId) {
    searchParams.set('conversationId', params.conversationId);
  }
  if (params.orgId) {
    searchParams.set('orgId', params.orgId);
  }

  const suffix = searchParams.toString() ? `?${searchParams.toString()}` : '';

  return apiRequest<ListToolsResponse>(`/tools${suffix}`, { method: 'GET' }, token);
}

export async function executeTool(
  token: string,
  payload: {
    conversationId?: string | null;
    orgId?: string | null;
    tool: string;
    args?: unknown;
  }
): Promise<ExecuteToolResponse> {
  return apiRequest<ExecuteToolResponse>(
    '/tools/execute',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    },
    token
  );
}

export async function executeToolEnvelope(
  token: string,
  payload: {
    conversationId?: string | null;
    orgId?: string | null;
    toolCalls: { tool: string; args?: unknown }[];
  }
): Promise<ExecuteEnvelopeResponse> {
  return apiRequest<ExecuteEnvelopeResponse>(
    '/tools/execute-envelope',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    },
    token
  );
}
```

This client directly mirrors the backend routes introduced in 26.md.

---

## 27.2. Hooks for Tools Panel State

We add a small hook to manage tools loading and execution history for the panel.

### 27.2.1. Create `apps/web/src/chat/useToolsPanel.ts`

```ts
// apps/web/src/chat/useToolsPanel.ts

import { useEffect, useState } from 'react';
import { useAuth } from '../auth/AuthContext';
import {
  ExecuteToolResponse,
  ListToolsResponse,
  ToolDescription,
  executeTool,
  listTools
} from '../api/tools';

export interface ToolRunRecord {
  id: string;
  tool: string;
  argsJson: string;
  resultJson: string;
  ok: boolean;
  error?: string;
  createdAt: Date;
}

export function useToolsPanel(conversationId: string | null, orgId: string | null) {
  const { token } = useAuth();

  const [tools, setTools] = useState<ToolDescription[]>([]);
  const [loadingTools, setLoadingTools] = useState(false);
  const [toolsError, setToolsError] = useState<string | null>(null);

  const [runs, setRuns] = useState<ToolRunRecord[]>([]);
  const [executing, setExecuting] = useState(false);
  const [executeError, setExecuteError] = useState<string | null>(null);

  useEffect(() => {
    if (!token) return;

    let cancelled = false;

    async function load() {
      setLoadingTools(true);
      setToolsError(null);
      try {
        const res: ListToolsResponse = await listTools(token, {
          conversationId: conversationId ?? undefined,
          orgId: orgId ?? undefined
        });
        if (cancelled) return;
        setTools(res.tools);
      } catch (err) {
        if (cancelled) return;
        setToolsError((err as Error).message || 'Failed to load tools');
      } finally {
        if (!cancelled) {
          setLoadingTools(false);
        }
      }
    }

    void load();

    return () => {
      cancelled = true;
    };
  }, [token, conversationId, orgId]);

  const runTool = async (tool: string, argsJson: string): Promise<ExecuteToolResponse | null> => {
    if (!token) return null;

    let parsedArgs: unknown = {};

    if (argsJson.trim()) {
      try {
        parsedArgs = JSON.parse(argsJson);
      } catch (err) {
        setExecuteError('Args JSON is invalid.');
        return null;
      }
    }

    setExecuting(true);
    setExecuteError(null);

    try {
      const res = await executeTool(token, {
        conversationId,
        orgId,
        tool,
        args: parsedArgs
      });

      const record: ToolRunRecord = {
        id: `${Date.now()}-${Math.random().toString(36).slice(2)}`,
        tool: res.tool,
        argsJson: argsJson || '{}',
        resultJson: JSON.stringify(res.ok ? res.result ?? {} : { error: res.error }, null, 2),
        ok: res.ok,
        error: res.error,
        createdAt: new Date()
      };

      setRuns((prev) => [record, ...prev]);

      return res;
    } catch (err) {
      const msg = (err as Error).message || 'Tool execution failed';
      setExecuteError(msg);
      return null;
    } finally {
      setExecuting(false);
    }
  };

  return {
    tools,
    loadingTools,
    toolsError,
    runs,
    executing,
    executeError,
    runTool
  };
}
```

This hook:

- Loads tools when `conversationId`/`orgId` or auth token changes.  
- Provides a `runTool` function that accepts a **tool name** and an **args JSON string**, executes the tool, and records the run history.

---

## 27.3. Tools Panel UI Component

We now build a bottom‑anchored drawer that displays tools, allows editing JSON args, and shows results.

### 27.3.1. Create `apps/web/src/chat/ToolsPanel.tsx`

```tsx
// apps/web/src/chat/ToolsPanel.tsx

import React, { useMemo, useState } from 'react';
import {
  Box,
  Button,
  Divider,
  Drawer,
  IconButton,
  List,
  ListItemButton,
  ListItemText,
  TextField,
  Tooltip,
  Typography
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import RefreshIcon from '@mui/icons-material/Refresh';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import TerminalIcon from '@mui/icons-material/Terminal';
import { useToolsPanel } from './useToolsPanel';

export interface ToolsPanelProps {
  open: boolean;
  onClose: () => void;
  conversationId: string | null;
  orgId: string | null;
}

export const ToolsPanel: React.FC<ToolsPanelProps> = ({
  open,
  onClose,
  conversationId,
  orgId
}) => {
  const { tools, loadingTools, toolsError, runs, executing, executeError, runTool } = useToolsPanel(
    conversationId,
    orgId
  );

  const [selectedToolName, setSelectedToolName] = useState<string | null>(null);
  const [argsJson, setArgsJson] = useState<string>('{}');

  const selectedTool = useMemo(
    () => tools.find((t) => t.name === selectedToolName) || null,
    [tools, selectedToolName]
  );

  const lastRun = runs[0] ?? null;

  const handleSelectTool = (name: string) => {
    setSelectedToolName(name);
    setArgsJson('{}');
  };

  const handleRun = async () => {
    if (!selectedToolName) return;
    await runTool(selectedToolName, argsJson);
  };

  return (
    <Drawer
      anchor="bottom"
      open={open}
      onClose={onClose}
      PaperProps={{
        sx: {
          height: 420,
          background:
            'radial-gradient(circle at top left, rgba(8,47,73,0.9), transparent 60%), radial-gradient(circle at bottom right, rgba(88,28,135,0.85), rgba(15,23,42,0.96))',
          color: 'rgba(241,245,249,0.98)'
        }
      }}
    >
      <Box display="flex" flexDirection="column" height="100%">
        <Box display="flex" alignItems="center" justifyContent="space-between" px={2} py={1.5}>
          <Box display="flex" alignItems="center" gap={1}>
            <TerminalIcon fontSize="small" />
            <Box>
              <Typography variant="subtitle1">Tools panel</Typography>
              <Typography variant="caption" color="rgba(148,163,184,0.95)">
                Inspect and run tools in the current context.
              </Typography>
            </Box>
          </Box>
          <Box display="flex" alignItems="center" gap={1}>
            {loadingTools && (
              <Typography variant="caption" color="rgba(148,163,184,0.9)">
                Loading tools…
              </Typography>
            )}
            <IconButton size="small" onClick={onClose}>
              <CloseIcon fontSize="small" />
            </IconButton>
          </Box>
        </Box>

        <Divider sx={{ borderColor: 'rgba(51,65,85,0.9)' }} />

        <Box flex={1} display="flex" minHeight={0}>
          {/* Tools list */}
          <Box
            sx={{
              width: 260,
              borderRight: '1px solid rgba(30,64,175,0.8)',
              display: 'flex',
              flexDirection: 'column',
              p: 1.5
            }}
          >
            <Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
              <Typography variant="caption" sx={{ textTransform: 'uppercase', letterSpacing: 0.08 }}>
                Tools
              </Typography>
              <Tooltip title="Reload tools">
                <span>
                  <IconButton
                    size="small"
                    onClick={undefined}
                    disabled
                    sx={{ opacity: 0.3, cursor: 'default' }}
                  >
                    <RefreshIcon fontSize="small" />
                  </IconButton>
                </span>
              </Tooltip>
            </Box>

            {toolsError && (
              <Typography variant="caption" color="error" mb={1}>
                {toolsError}
              </Typography>
            )}

            {tools.length === 0 && !loadingTools && (
              <Typography variant="body2" color="rgba(148,163,184,0.95)">
                No tools available in this context.
              </Typography>
            )}

            <List dense disablePadding sx={{ overflowY: 'auto', flex: 1 }}>
              {tools.map((tool) => (
                <ListItemButton
                  key={tool.name}
                  selected={tool.name === selectedToolName}
                  onClick={() => handleSelectTool(tool.name)}
                  sx={{
                    borderRadius: 1.5,
                    mb: 0.5,
                    '&.Mui-selected': {
                      background:
                        'linear-gradient(90deg, rgba(59,130,246,0.45), rgba(45,212,191,0.35))'
                    },
                    '&:hover': {
                      backgroundColor: 'rgba(30,64,175,0.6)'
                    }
                  }}
                >
                  <ListItemText
                    primary={tool.name}
                    secondary={tool.description}
                    primaryTypographyProps={{
                      noWrap: true,
                      fontSize: 13
                    }}
                    secondaryTypographyProps={{
                      noWrap: true,
                      fontSize: 11,
                      color: 'rgba(148,163,184,0.95)'
                    }}
                  />
                </ListItemButton>
              ))}
            </List>
          </Box>

          {/* Right side: args + result */}
          <Box flex={1} display="flex" flexDirection="column" minWidth={0}>
            <Box display="flex" flexDirection="column" p={1.5} gap={1}>
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Box>
                  <Typography variant="caption" sx={{ textTransform: 'uppercase', letterSpacing: 0.08 }}>
                    Arguments
                  </Typography>
                  {selectedTool ? (
                    <Typography variant="caption" color="rgba(148,163,184,0.95)">
                      {selectedTool.description}
                    </Typography>
                  ) : (
                    <Typography variant="caption" color="rgba(148,163,184,0.8)">
                      Select a tool on the left to view its description and run it.
                    </Typography>
                  )}
                </Box>
                <Box display="flex" alignItems="center" gap={1}>
                  {executeError && (
                    <Typography variant="caption" color="error">
                      {executeError}
                    </Typography>
                  )}
                  <Button
                    size="small"
                    variant="contained"
                    startIcon={<PlayArrowIcon fontSize="small" />}
                    onClick={handleRun}
                    disabled={!selectedTool || executing}
                    sx={{ borderRadius: 999, textTransform: 'none' }}
                  >
                    {executing ? 'Running…' : 'Run tool'}
                  </Button>
                </Box>
              </Box>

              <TextField
                multiline
                minRows={5}
                maxRows={10}
                value={argsJson}
                onChange={(e) => setArgsJson(e.target.value)}
                sx={{
                  '& .MuiInputBase-root': {
                    fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                    fontSize: 12,
                    backgroundColor: 'rgba(15,23,42,0.9)'
                  }
                }}
                placeholder="{ }"
              />
            </Box>

            <Divider sx={{ borderColor: 'rgba(51,65,85,0.9)' }} />

            <Box flex={1} p={1.5} overflow="auto">
              <Typography
                variant="caption"
                sx={{ textTransform: 'uppercase', letterSpacing: 0.08, display: 'block', mb: 0.5 }}
              >
                Last result
              </Typography>

              {!lastRun && (
                <Typography variant="body2" color="rgba(148,163,184,0.95)">
                  No tool runs yet. Configure args above and click "Run tool".
                </Typography>
              )}

              {lastRun && (
                <>
                  <Typography variant="caption" color="rgba(148,163,184,0.9)" display="block" mb={0.5}>
                    {lastRun.tool} · {lastRun.createdAt.toLocaleTimeString()} ·{' '}
                    {lastRun.ok ? 'OK' : 'ERROR'}
                  </Typography>
                  <Box
                    component="pre"
                    sx={{
                      m: 0,
                      p: 1.5,
                      borderRadius: 1.5,
                      backgroundColor: 'rgba(15,23,42,0.95)',
                      fontFamily:
                        'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                      fontSize: 12,
                      whiteSpace: 'pre-wrap',
                      wordBreak: 'break-word',
                      maxHeight: '100%',
                      overflowY: 'auto'
                    }}
                  >
                    {lastRun.resultJson}
                  </Box>
                </>
              )}
            </Box>
          </Box>
        </Box>
      </Box>
    </Drawer>
  );
};
```

This panel:

- Shows available tools on the left.  
- Lets the user edit args JSON and run tools.  
- Shows the latest result JSON in a monospace, preformatted block.  
- Uses a **bottom drawer** to avoid overlapping with the right‑hand settings drawer from 24.md.

---

## 27.4. Integrate Tools Panel into ChatPage

We now hook the panel into the main chat UI.

> **Assumption:** `ChatPage` already has access to `conversationId` and `orgId` from route params.

### 27.4.1. Update `apps/web/src/chat/ChatPage.tsx`

Add imports at the top:

```tsx
import ExtensionIcon from '@mui/icons-material/Extension';
import { ToolsPanel } from './ToolsPanel';
```

Inside the `ChatPage` component, add local state:

```tsx
const [toolsOpen, setToolsOpen] = React.useState(false);
```

In the header area (where you added the Settings icon in 24.md), extend the actions. For example, change:

```tsx
<Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
  <Typography variant="h6">Conversation</Typography>
  <IconButton size="small" onClick={() => setSettingsOpen(true)}>
    <SettingsIcon fontSize="small" />
  </IconButton>
</Box>
```

into:

```tsx
<Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
  <Typography variant="h6">Conversation</Typography>
  <Box display="flex" alignItems="center" gap={1}>
    <Tooltip title="Tools panel">
      <IconButton size="small" onClick={() => setToolsOpen(true)}>
        <ExtensionIcon fontSize="small" />
      </IconButton>
    </Tooltip>
    <Tooltip title="Conversation settings">
      <IconButton size="small" onClick={() => setSettingsOpen(true)}>
        <SettingsIcon fontSize="small" />
      </IconButton>
    </Tooltip>
  </Box>
</Box>
```

Finally, render the tools panel near the bottom of `ChatPage` JSX (inside the root `Box`):

```tsx
<ToolsPanel
  open={toolsOpen}
  onClose={() => setToolsOpen(false)}
  conversationId={conversationId ?? null}
  orgId={orgId ?? null}
/>
```

This ensures the tools panel is available from any chat, using the current conversation/org context.

---

## 27.5. Sanity Checks

From the repo root:

1. **Typecheck & lint:**

   ```bash
   pnpm lint
   pnpm typecheck
   ```

2. **Run API gateway & web:**

   ```bash
   pnpm dev --filter=api-gateway
   cd apps/web
   pnpm dev
   ```

3. **Manual verification:**

   - Go to `/app/orgs/<orgId>/chat/<conversationId>`.  
   - Click the **puzzle/extension** icon in the chat header – tools panel should slide from the bottom.  
   - Tools list should display at least:
     - `time.now`  
     - `org.usageSnapshot`  
     - `conversation.searchMessages`
   - Select `time.now`, leave args as `{}` and click **Run tool** – result JSON should show current time.  
   - Select `org.usageSnapshot`, set args JSON to `{ "windowDays": 30 }`, run – should return quota snapshot (from 19.md).  
   - Select `conversation.searchMessages`, args JSON like `{ "query": "error", "limit": 5 }` – should show matching messages.

If all checks pass, your AI chat frontend now has a **full tools console** integrated into the chat experience, matching the backend tools engine from 26.md and the per‑conversation settings from 24–25.md.

---

_End of 27.md – Tools Panel & Tool Call Inspector (Frontend UI)_
