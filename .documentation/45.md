# 45. Usage Analytics & Cost Dashboard – Org‑Level Insights with Material 3 + Grafana

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Implement an **end‑to‑end usage analytics & cost layer** so that:
>
> - Each org can see **how much they use the platform** (requests, tokens, models, features).  
> - Estimated **cost per org / model / feature** can be computed using Model Registry pricing (43.md).  
> - There is an **Org Usage Dashboard** in the web app (Material 3 + vivid gradients).  
> - Infra‑level time‑series metrics are exposed to **Grafana** (28.md), but business‑level views live inside the app.  
> - Everything is multi‑tenant, RBAC‑aware and built on top of existing **LLM events & metrics** (19.md, 38.md, 43.md, 44.md).
>
> This spec is written so Cursor‑like agents can implement it end‑to‑end without further questions.

This file builds on:

- 19.md – Quotas, rate limits & usage accounting.  
- 25.md – Conversation & message pipeline.  
- 28.md – Metrics & observability (Prometheus + Grafana).  
- 38.md – Event bus & audit log.  
- 40.md – Org Admin Console navigation.  
- 43.md – Model Registry & pricing metadata.  
- 44.md – Playground & Experiments usage.

---

## 45.1. Concepts & Scope

We distinguish **two layers of usage data**:

1. **Infra‑level metrics (Prometheus, Grafana)** – already defined in 28.md  
   - High‑granularity, time‑series (seconds/minutes).  
   - Used by SREs/devops.

2. **Business‑level analytics (Postgres + Prisma)** – defined here  
   - Aggregated per **org / day / model / feature / user**.  
   - Used by org admins & billing.

Key concepts introduced in this file:

- **Usage Event** – per LLM call, a small struct with org, model, feature, tokens, estimated cost.  
- **Daily Aggregates** – nightly (or periodic) job rolls events into `OrgDailyUsage` and `OrgUserDailyUsage`.  
- **Usage API** – endpoints to query aggregated usage.  
- **Usage Dashboard (Material 3)** – in‑app UI at `/app/orgs/:orgId/analytics`.  
- **Grafana Dashboards** – use Prometheus metrics for advanced time‑series views.

---

## 45.2. Data Model – Prisma Aggregates

We introduce **daily aggregates** instead of storing every raw token event. Raw events are still available in the event log (38.md).

Extend `packages/db/prisma/schema.prisma`:

```prisma
/// Per-org daily usage aggregated by model and feature.
model OrgDailyUsage {
  id        String   @id @default(cuid())

  orgId     String

  /// Truncated to day (e.g. 2025-12-07T00:00:00Z). Use UTC.
  date      DateTime

  /// Provider + model, e.g. 'ollama', 'openai', ...
  provider  String
  modelName String

  /// High-level feature: 'chat', 'playground', 'experiment', 'rag', 'tools', etc.
  feature   String

  requestCount      Int    @default(0)
  inputTokens       Int    @default(0)
  outputTokens      Int    @default(0)
  estimatedCostMicros Int  @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Org      @relation(fields: [orgId], references: [id])

  @@index([orgId, date])
  @@index([orgId, date, provider, modelName])
}

/// Per-org per-user daily usage, for "top users" views.
model OrgUserDailyUsage {
  id        String   @id @default(cuid())

  orgId     String
  userId    String

  date      DateTime

  provider  String
  modelName String
  feature   String

  requestCount        Int   @default(0)
  inputTokens         Int   @default(0)
  outputTokens        Int   @default(0)
  estimatedCostMicros Int   @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Org   @relation(fields: [orgId], references: [id])
  user      User  @relation(fields: [userId], references: [id])

  @@index([orgId, date])
  @@index([orgId, userId, date])
}
```

> **Note:** 19.md may already define lower‑level usage structures (e.g. per‑request usage). Those can feed these aggregates. This spec assumes the aggregates above exist and are the **source of truth** for analytics queries.

Run a Prisma migration after updating the schema.

---

## 45.3. Usage Event Abstraction

We define a small, reusable **Usage Event** interface and a tracker service. This service is called by:

- Chat pipeline (25.md) when an LLM completion finishes.  
- Playground (44.md).  
- Experiments (44.md).  
- Future tools/RAG pipelines.

### 45.3.1. Types

**File:** `apps/api-gateway/src/usage/types.ts`

```ts
// apps/api-gateway/src/usage/types.ts

export type UsageFeature =
  | 'chat'
  | 'playground'
  | 'experiment'
  | 'rag'
  | 'tools';

export interface UsageEvent {
  orgId: string;
  userId?: string;

  provider: string; // e.g. 'ollama', 'openai'
  modelName: string; // e.g. 'llama3', 'gpt-4.1-mini'

  feature: UsageFeature;

  // Basic counts
  requestCount: number; // usually 1
  inputTokens: number;
  outputTokens: number;

  // Cost in micros (optional, will be computed if not provided)
  estimatedCostMicros?: number;

  // Optional opaque metadata (conversation, message, experiment IDs)
  metadata?: Record<string, any>;

  // Event creation time; if omitted, use now.
  occurredAt?: Date;
}
```

### 45.3.2. Usage Tracker Service

**File:** `apps/api-gateway/src/usage/usageTracker.ts`

```ts
// apps/api-gateway/src/usage/usageTracker.ts

import { prisma } from '@ai-chat/db';
import { UsageEvent } from './types';

function truncateToUtcDay(date: Date): Date {
  const d = new Date(date.toISOString().slice(0, 10) + 'T00:00:00.000Z');
  return d;
}

async function computeCostMicrosFromRegistry(
  orgId: string,
  provider: string,
  modelName: string,
  inputTokens: number,
  outputTokens: number
): Promise<number> {
  const entry = await prisma.modelRegistryEntry.findFirst({
    where: { orgId, provider, modelName }
  });

  const fallback = await prisma.modelRegistryEntry.findFirst({
    where: { orgId: null, provider, modelName }
  });

  const model = entry ?? fallback;
  if (!model) return 0;

  const inPrice = model.inputPriceMicros ?? 0;
  const outPrice = model.outputPriceMicros ?? 0;

  const costIn = Math.round((inputTokens / 1000) * inPrice);
  const costOut = Math.round((outputTokens / 1000) * outPrice);

  return costIn + costOut;
}

export async function recordUsage(event: UsageEvent): Promise<void> {
  const occurredAt = event.occurredAt ?? new Date();
  const day = truncateToUtcDay(occurredAt);

  const requestCount = event.requestCount || 1;
  const inputTokens = event.inputTokens || 0;
  const outputTokens = event.outputTokens || 0;

  let estimatedCostMicros = event.estimatedCostMicros ?? 0;
  if (!estimatedCostMicros && (inputTokens || outputTokens)) {
    estimatedCostMicros = await computeCostMicrosFromRegistry(
      event.orgId,
      event.provider,
      event.modelName,
      inputTokens,
      outputTokens
    );
  }

  // Upsert OrgDailyUsage
  await prisma.orgDailyUsage.upsert({
    where: {
      // You will need a composite unique constraint on (orgId, date, provider, modelName, feature)
      // in the schema to support this.
      orgId_date_provider_modelName_feature: {
        orgId: event.orgId,
        date: day,
        provider: event.provider,
        modelName: event.modelName,
        feature: event.feature
      }
    },
    update: {
      requestCount: { increment: requestCount },
      inputTokens: { increment: inputTokens },
      outputTokens: { increment: outputTokens },
      estimatedCostMicros: { increment: estimatedCostMicros }
    },
    create: {
      orgId: event.orgId,
      date: day,
      provider: event.provider,
      modelName: event.modelName,
      feature: event.feature,
      requestCount,
      inputTokens,
      outputTokens,
      estimatedCostMicros
    }
  });

  if (event.userId) {
    await prisma.orgUserDailyUsage.upsert({
      where: {
        // composite unique on (orgId, userId, date, provider, modelName, feature)
        orgId_userId_date_provider_modelName_feature: {
          orgId: event.orgId,
          userId: event.userId,
          date: day,
          provider: event.provider,
          modelName: event.modelName,
          feature: event.feature
        }
      },
      update: {
        requestCount: { increment: requestCount },
        inputTokens: { increment: inputTokens },
        outputTokens: { increment: outputTokens },
        estimatedCostMicros: { increment: estimatedCostMicros }
      },
      create: {
        orgId: event.orgId,
        userId: event.userId,
        date: day,
        provider: event.provider,
        modelName: event.modelName,
        feature: event.feature,
        requestCount,
        inputTokens,
        outputTokens,
        estimatedCostMicros
      }
    });
  }

  // Optional: also emit a generic event for the event bus (38.md)
  // emitEvent('usage.recorded', { ...event, estimatedCostMicros });
}
```

> **Schema Note:** You must add composite unique keys in Prisma for the upsert `where` blocks above, for example:  
> `@@unique([orgId, date, provider, modelName, feature], name: "orgId_date_provider_modelName_feature")` etc.

---

## 45.4. Integrating Usage Tracking into LLM Calls

Every place that performs an LLM call via `completeWithRouting` / `streamWithRouting` should also call `recordUsage`.

### 45.4.1. Chat Pipeline Integration

Within chat message handler (25.md), after receiving an LLM response:

```ts
import { recordUsage } from '../usage/usageTracker';

// Assume you already have orgId, userId, profile, modelEntry, etc.

const completion = await completeWithRouting({
  orgId,
  modelProvider: profile.modelProvider,
  modelName: profile.modelName,
  messages: builtMessages,
  temperature: profile.temperature,
  topP: profile.topP,
  maxTokens: profile.maxTokens
});

// Token counts may come from provider response if available; use 0 as fallback.
const inputTokens = 0;  // TODO in provider to calculate or read
const outputTokens = 0; // same

await recordUsage({
  orgId,
  userId,
  provider: profile.modelProvider,
  modelName: profile.modelName,
  feature: 'chat',
  requestCount: 1,
  inputTokens,
  outputTokens,
  metadata: {
    conversationId,
    chatProfileId: profile.id,
    source: 'chat_pipeline'
  }
});
```

> **Improvement:** For providers that expose token counts, extend the `ChatCompletionResponse` type (43.md) to include them and pass here instead of `0`.

### 45.4.2. Playground & Experiments Integration

- In `/playground/complete` (44.md), after completion, call `recordUsage` with `feature: 'playground'`.  
- In experiment run loop (44.md: `experimentRun.ts`), after each `completeWithRouting`, call `recordUsage` with `feature: 'experiment'` and `metadata: { experimentId, variantId, inputId }`.

This ensures all LLM usage flows into `OrgDailyUsage` and `OrgUserDailyUsage` in a unified way.

---

## 45.5. Usage Analytics API – Backend Routes

We expose **read‑only analytics endpoints** for org admins.

### 45.5.1. Types & Query Schemas

**File:** `apps/api-gateway/src/routes/usageAnalytics.ts`

```ts
// apps/api-gateway/src/routes/usageAnalytics.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

const usageQuerySchema = z.object({
  from: z.string().optional(), // ISO date string (YYYY-MM-DD)
  to: z.string().optional(),
  feature: z.string().optional() // optional filter: 'chat', 'playground', etc.
});

function parseDateOrFallback(input: string | undefined, fallback: Date): Date {
  if (!input) return fallback;
  const d = new Date(input);
  if (Number.isNaN(d.getTime())) return fallback;
  return d;
}

export default async function usageAnalyticsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // Summary by day & model
  app.get('/orgs/:orgId/analytics/usage', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:analytics:read'
    );

    const parsed = usageQuerySchema.safeParse(req.query);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_QUERY', details: parsed.error.format() });
    }

    const now = new Date();
    const defaultFrom = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); // last 30 days

    const fromDate = parseDateOrFallback(parsed.data.from, defaultFrom);
    const toDate = parseDateOrFallback(parsed.data.to, now);

    const featureFilter = parsed.data.feature;

    const rows = await prisma.orgDailyUsage.findMany({
      where: {
        orgId,
        date: {
          gte: fromDate,
          lte: toDate
        },
        ...(featureFilter ? { feature: featureFilter } : {})
      },
      orderBy: { date: 'asc' }
    });

    return reply.send({ usage: rows });
  });

  // Top users within a date range
  app.get('/orgs/:orgId/analytics/top-users', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:analytics:read'
    );

    const parsed = usageQuerySchema.safeParse(req.query);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_QUERY', details: parsed.error.format() });
    }

    const now = new Date();
    const defaultFrom = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const fromDate = parseDateOrFallback(parsed.data.from, defaultFrom);
    const toDate = parseDateOrFallback(parsed.data.to, now);

    const raw = await prisma.orgUserDailyUsage.groupBy({
      by: ['userId'],
      where: {
        orgId,
        date: { gte: fromDate, lte: toDate }
      },
      _sum: {
        requestCount: true,
        inputTokens: true,
        outputTokens: true,
        estimatedCostMicros: true
      },
      orderBy: {
        _sum: {
          estimatedCostMicros: 'desc'
        }
      },
      take: 20
    });

    const userIds = raw.map((r) => r.userId);
    const users = await prisma.user.findMany({ where: { id: { in: userIds } } });
    const userMap = new Map(users.map((u) => [u.id, u]));

    const result = raw.map((r) => ({
      userId: r.userId,
      user: userMap.get(r.userId)
        ? {
            id: userMap.get(r.userId)!.id,
            name: userMap.get(r.userId)!.name,
            email: userMap.get(r.userId)!.email
          }
        : null,
      requestCount: r._sum.requestCount ?? 0,
      inputTokens: r._sum.inputTokens ?? 0,
      outputTokens: r._sum.outputTokens ?? 0,
      estimatedCostMicros: r._sum.estimatedCostMicros ?? 0
    }));

    return reply.send({ topUsers: result });
  });
}
```

Register in `main.ts`:

```ts
import usageAnalyticsRoutes from './routes/usageAnalytics';

await app.register(usageAnalyticsRoutes);
```

---

## 45.6. Frontend – API Wrapper

**File:** `apps/web/src/api/analytics.ts`

```ts
// apps/web/src/api/analytics.ts

import { apiRequest } from './client';

export interface OrgDailyUsageDto {
  id: string;
  orgId: string;
  date: string;
  provider: string;
  modelName: string;
  feature: string;
  requestCount: number;
  inputTokens: number;
  outputTokens: number;
  estimatedCostMicros: number;
}

export interface OrgTopUserUsageDto {
  userId: string;
  user: {
    id: string;
    name: string | null;
    email: string | null;
  } | null;
  requestCount: number;
  inputTokens: number;
  outputTokens: number;
  estimatedCostMicros: number;
}

export async function fetchOrgUsage(
  token: string,
  orgId: string,
  params: { from?: string; to?: string; feature?: string }
): Promise<{ usage: OrgDailyUsageDto[] }> {
  const search = new URLSearchParams();
  if (params.from) search.set('from', params.from);
  if (params.to) search.set('to', params.to);
  if (params.feature) search.set('feature', params.feature);

  const query = search.toString();

  return apiRequest<{ usage: OrgDailyUsageDto[]}>(
    `/orgs/${orgId}/analytics/usage${query ? `?${query}` : ''}`,
    { method: 'GET' },
    token
  );
}

export async function fetchOrgTopUsers(
  token: string,
  orgId: string,
  params: { from?: string; to?: string }
): Promise<{ topUsers: OrgTopUserUsageDto[] }> {
  const search = new URLSearchParams();
  if (params.from) search.set('from', params.from);
  if (params.to) search.set('to', params.to);

  const query = search.toString();

  return apiRequest<{ topUsers: OrgTopUserUsageDto[]}>(
    `/orgs/${orgId}/analytics/top-users${query ? `?${query}` : ''}`,
    { method: 'GET' },
    token
  );
}
```

---

## 45.7. Material 3 Usage Dashboard UI

Route: `/app/orgs/:orgId/analytics`

This page provides **high‑level, business‑friendly usage and cost views**.

### 45.7.1. Component – OrgUsageDashboardPage

**File:** `apps/web/src/org/OrgUsageDashboardPage.tsx`

```tsx
// apps/web/src/org/OrgUsageDashboardPage.tsx

import React, { useEffect, useMemo, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  TextField,
  Typography
} from '@mui/material';
import AnalyticsIcon from '@mui/icons-material/Analytics';
import RefreshIcon from '@mui/icons-material/Refresh';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { fetchOrgUsage, fetchOrgTopUsers, OrgDailyUsageDto, OrgTopUserUsageDto } from '../api/analytics';

function formatCurrencyFromMicros(micros: number): string {
  const dollars = micros / 1_000_000;
  return `$${dollars.toFixed(4)}`;
}

function formatDateInput(d: Date): string {
  return d.toISOString().slice(0, 10);
}

export const OrgUsageDashboardPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [from, setFrom] = useState<string>(() => {
    const d = new Date();
    d.setDate(d.getDate() - 7);
    return formatDateInput(d);
  });

  const [to, setTo] = useState<string>(() => formatDateInput(new Date()));
  const [feature, setFeature] = useState<string>('all');

  const [usage, setUsage] = useState<OrgDailyUsageDto[]>([]);
  const [topUsers, setTopUsers] = useState<OrgTopUserUsageDto[]>([]);

  const [loading, setLoading] = useState(false);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(56,189,248,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(249,115,22,0.18), transparent 55%)';

  const load = async () => {
    if (!token || !orgId) return;
    setLoading(true);
    try {
      const [uRes, topRes] = await Promise.all([
        fetchOrgUsage(token, orgId, {
          from,
          to,
          feature: feature === 'all' ? undefined : feature
        }),
        fetchOrgTopUsers(token, orgId, { from, to })
      ]);
      setUsage(uRes.usage);
      setTopUsers(topRes.topUsers);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [orgId]);

  const summary = useMemo(() => {
    let totalReq = 0;
    let inTok = 0;
    let outTok = 0;
    let cost = 0;
    for (const row of usage) {
      totalReq += row.requestCount;
      inTok += row.inputTokens;
      outTok += row.outputTokens;
      cost += row.estimatedCostMicros;
    }
    return { totalReq, inTok, outTok, cost };
  }, [usage]);

  const byModel = useMemo(() => {
    const map = new Map<string, { provider: string; modelName: string; requestCount: number; inputTokens: number; outputTokens: number; cost: number }>();
    for (const row of usage) {
      const key = `${row.provider}:${row.modelName}`;
      const existing = map.get(key) || {
        provider: row.provider,
        modelName: row.modelName,
        requestCount: 0,
        inputTokens: 0,
        outputTokens: 0,
        cost: 0
      };
      existing.requestCount += row.requestCount;
      existing.inputTokens += row.inputTokens;
      existing.outputTokens += row.outputTokens;
      existing.cost += row.estimatedCostMicros;
      map.set(key, existing);
    }
    return Array.from(map.values()).sort((a, b) => b.cost - a.cost);
  }, [usage]);

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1}>
          <AnalyticsIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Usage & Cost</Typography>
            <Typography variant="caption" color="text.secondary">
              Track how your organization uses AI models over time.
            </Typography>
          </Box>
        </Box>

        <Box display="flex" alignItems="center" gap={1.5}>
          <TextField
            label="From"
            type="date"
            size="small"
            value={from}
            onChange={(e) => setFrom(e.target.value)}
            InputLabelProps={{ shrink: true }}
          />
          <TextField
            label="To"
            type="date"
            size="small"
            value={to}
            onChange={(e) => setTo(e.target.value)}
            InputLabelProps={{ shrink: true }}
          />
          <FormControl size="small" sx={{ minWidth: 140 }}>
            <InputLabel id="feature-label">Feature</InputLabel>
            <Select
              labelId="feature-label"
              label="Feature"
              value={feature}
              onChange={(e) => setFeature(e.target.value)}
            >
              <MenuItem value="all">All</MenuItem>
              <MenuItem value="chat">Chat</MenuItem>
              <MenuItem value="playground">Playground</MenuItem>
              <MenuItem value="experiment">Experiments</MenuItem>
              <MenuItem value="rag">RAG</MenuItem>
              <MenuItem value="tools">Tools</MenuItem>
            </Select>
          </FormControl>
          <Button
            size="small"
            startIcon={<RefreshIcon />}
            onClick={() => void load()}
            disabled={loading}
          >
            {loading ? 'Loading…' : 'Refresh'}
          </Button>
        </Box>
      </Box>

      {/* Summary cards */}
      <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap' }}>
        <Card sx={{ borderRadius: 3, minWidth: 220, flex: 1 }}>
          <CardContent>
            <Typography variant="caption" color="text.secondary">
              Total requests
            </Typography>
            <Typography variant="h5">{summary.totalReq.toLocaleString()}</Typography>
          </CardContent>
        </Card>
        <Card sx={{ borderRadius: 3, minWidth: 220, flex: 1 }}>
          <CardContent>
            <Typography variant="caption" color="text.secondary">
              Input tokens
            </Typography>
            <Typography variant="h5">{summary.inTok.toLocaleString()}</Typography>
          </CardContent>
        </Card>
        <Card sx={{ borderRadius: 3, minWidth: 220, flex: 1 }}>
          <CardContent>
            <Typography variant="caption" color="text.secondary">
              Output tokens
            </Typography>
            <Typography variant="h5">{summary.outTok.toLocaleString()}</Typography>
          </CardContent>
        </Card>
        <Card sx={{ borderRadius: 3, minWidth: 220, flex: 1 }}>
          <CardContent>
            <Typography variant="caption" color="text.secondary">
              Estimated cost
            </Typography>
            <Typography variant="h5">{formatCurrencyFromMicros(summary.cost)}</Typography>
          </CardContent>
        </Card>
      </Box>

      <Box sx={{ display: 'flex', gap: 2, flex: 1, minHeight: 0 }}>
        {/* Left: usage by model */}
        <Card sx={{ borderRadius: 3, flex: 2, overflow: 'hidden' }}>
          <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1, height: '100%' }}>
            <Typography variant="subtitle2">Usage by model</Typography>
            <Box
              sx={{
                mt: 1,
                flex: 1,
                overflow: 'auto',
                '& table': { width: '100%', borderCollapse: 'collapse' },
                '& th, & td': { padding: '6px 8px', fontSize: 13 },
                '& th': { textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.08)' },
                '& tr:nth-of-type(even)': { backgroundColor: 'action.hover' }
              }}
            >
              <table>
                <thead>
                  <tr>
                    <th>Model</th>
                    <th>Requests</th>
                    <th>Input tokens</th>
                    <th>Output tokens</th>
                    <th>Estimated cost</th>
                  </tr>
                </thead>
                <tbody>
                  {byModel.length === 0 && (
                    <tr>
                      <td colSpan={5}>
                        <Typography variant="body2" color="text.secondary">
                          No usage data for this range.
                        </Typography>
                      </td>
                    </tr>
                  )}
                  {byModel.map((m) => (
                    <tr key={`${m.provider}:${m.modelName}`}>
                      <td>
                        <Typography variant="body2">
                          {m.provider}:{m.modelName}
                        </Typography>
                      </td>
                      <td>{m.requestCount.toLocaleString()}</td>
                      <td>{m.inputTokens.toLocaleString()}</td>
                      <td>{m.outputTokens.toLocaleString()}</td>
                      <td>{formatCurrencyFromMicros(m.cost)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </Box>
          </CardContent>
        </Card>

        {/* Right: top users */}
        <Card sx={{ borderRadius: 3, flex: 1 }}>
          <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1, height: '100%' }}>
            <Typography variant="subtitle2">Top users by cost</Typography>
            <Box
              sx={{
                mt: 1,
                flex: 1,
                overflow: 'auto',
                '& table': { width: '100%', borderCollapse: 'collapse' },
                '& th, & td': { padding: '6px 8px', fontSize: 13 },
                '& th': { textAlign: 'left', borderBottom: '1px solid rgba(255,255,255,0.08)' },
                '& tr:nth-of-type(even)': { backgroundColor: 'action.hover' }
              }}
            >
              <table>
                <thead>
                  <tr>
                    <th>User</th>
                    <th>Requests</th>
                    <th>Tokens</th>
                    <th>Cost</th>
                  </tr>
                </thead>
                <tbody>
                  {topUsers.length === 0 && (
                    <tr>
                      <td colSpan={4}>
                        <Typography variant="body2" color="text.secondary">
                          No user data for this range.
                        </Typography>
                      </td>
                    </tr>
                  )}
                  {topUsers.map((u) => (
                    <tr key={u.userId}>
                      <td>
                        <Typography variant="body2">
                          {u.user?.name || u.user?.email || u.userId}
                        </Typography>
                      </td>
                      <td>{u.requestCount.toLocaleString()}</td>
                      <td>
                        {(u.inputTokens + u.outputTokens).toLocaleString()}
                      </td>
                      <td>{formatCurrencyFromMicros(u.estimatedCostMicros)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </Box>
          </CardContent>
        </Card>
      </Box>
    </Box>
  );
};
```

Add to router:

```tsx
import { OrgUsageDashboardPage } from './org/OrgUsageDashboardPage';

<Route path="/app/orgs/:orgId/analytics" element={<OrgUsageDashboardPage />} />
```

---

## 45.8. Grafana Dashboards (Infra‑Level)

Using the metrics from 28.md + additional LLM metrics (43.md, 44.md), build one or more **Grafana dashboards** for:

- **LLM performance** – latency, error rates, token throughput per provider/model.  
- **Usage vs. quota** – compare org usage (from Prometheus or derived) to quotas defined in 19.md.  
- **Experiments** – per‑experiment traffic & latency, success vs. failure.

Examples of Prometheus metrics to plot:

- `llm_requests_total{provider,modelName}`  
- `llm_request_duration_ms_bucket{provider,modelName}`  
- `llm_tokens_input_total{provider,modelName}`  
- `llm_tokens_output_total{provider,modelName}`  
- `playground_requests_total{orgId}`  
- `experiment_runs_total{orgId,experimentId}`

Org admins see high‑level trends via **OrgUsageDashboardPage**, while SREs use Grafana for deeper real‑time analytics.

---

## 45.9. Sanity Checklist

Before enabling analytics in production:

- [ ] Prisma migration applied for `OrgDailyUsage` and `OrgUserDailyUsage` plus unique indexes.  
- [ ] `recordUsage` is called from chat pipeline, playground, experiments (and any other LLM flows).  
- [ ] `usageAnalyticsRoutes` registered and protected by `org:analytics:read` permission.  
- [ ] Frontend `OrgUsageDashboardPage` is reachable from Org Admin Console (40.md).  
- [ ] Summary cards, by‑model table and top users table show data for test orgs.  
- [ ] Grafana dashboards show infra‑level LLM metrics and align approximately with DB aggregates.

If all items are green, the platform now offers an **enterprise‑grade analytics & cost layer**: org admins can monitor usage, anticipate spend and optimize model/profile choices – comparable to what modern AI platforms provide.

---

_End of 45.md – Usage Analytics & Cost Dashboard – Org‑Level Insights with Material 3 + Grafana_
