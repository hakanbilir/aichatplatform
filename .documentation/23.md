# 23. Conversation Inline Rename & Context Menu UX

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Refine the **conversation sidebar UX** introduced in 22.md with:
>
> - Inline conversation title renaming (double‑click + context menu action).  
> - A compact **context menu** (⋮) per conversation: Rename, Pin/Unpin, Archive.  
> - Smooth Material 3 micro‑interactions that keep the UI clean and discoverable.
>
> After this file, users can rename conversations in place and use a unified menu for common actions, without changing any backend APIs.

> **Important instructions to AI agents:**
> - This file **replaces and supersedes** the `ConversationSidebar.tsx` implementation from 22.4.1.  
> - Do **not** modify backend routes or schema – we reuse the APIs from 22.md (`updateConversation` etc.).  
> - All code must be complete and compilable; no placeholders.

---

## 23.1. UX Behavior Specification

We enhance the conversation sidebar (22.md) with the following interactions:

1. **Inline rename**
   - **Trigger:**
     - Option A: Use the **context menu** action "Rename" on a conversation.  
     - Option B: (Optional to implement later) double‑click on the conversation row – not required in this file.
   - **Edit mode:**
     - The conversation title becomes a single‑line `TextField` inline.  
     - The input is auto‑focused, with the existing title prefilled.  
     - `Enter` → saves changes (via `PATCH /conversations/:id` with `{ title }`).  
     - `Esc` → cancels editing and restores previous text (no network call).  
     - Blur (`onBlur`) → saves changes.

2. **Context menu (⋮)**
   - A single **more actions** icon appears at the right side of each conversation row.  
   - Clicking it opens a `Menu` with items:
     - **Rename**  
     - **Pin** / **Unpin** (label depends on current `pinned` state)  
     - **Archive** (sets `archived: true`, which maps to `archivedAt = now` on backend as per 22.md)
   - All actions use existing `updateConversation` API.

3. **Visual behavior**
   - Selected conversation row still uses the gradients and hover effects from 22.md.  
   - Inline edit mode keeps the row visually distinct but unobtrusive (no extra background needed).  
   - Clicking the context menu **does not** trigger navigation.

No new backend endpoints are required – all writes go through `updateConversation` from 22.md.

---

## 23.2. Frontend – Updated Conversation Sidebar Component

We now update `ConversationSidebar.tsx` to add:

- Local edit state: `editingConversationId`, `editingTitle`.  
- A `Menu` with three actions: Rename, Pin/Unpin, Archive.  
- Inline `TextField` rendering when a conversation is in edit mode.

> **Important:** This replaces the previous implementation from 22.4.1; treat this as the canonical version of `ConversationSidebar`.

### 23.2.1. Replace `apps/web/src/chat/ConversationSidebar.tsx`

```tsx
// apps/web/src/chat/ConversationSidebar.tsx

import React, { useEffect, useMemo, useState } from 'react';
import {
  Box,
  Button,
  CircularProgress,
  IconButton,
  InputAdornment,
  List,
  ListItemButton,
  ListItemSecondaryAction,
  ListItemText,
  Menu,
  MenuItem,
  TextField,
  Tooltip,
  Typography
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import { useNavigate, useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import {
  ConversationListItem,
  ConversationListResponse,
  createOrgConversation,
  listOrgConversations,
  updateConversation
} from '../api/conversations';

interface ConversationSidebarProps {
  selectedConversationId?: string;
}

export const ConversationSidebar: React.FC<ConversationSidebarProps> = ({ selectedConversationId }) => {
  const { token } = useAuth();
  const { orgId } = useParams<{ orgId: string }>();
  const navigate = useNavigate();

  const [items, setItems] = useState<ConversationListItem[]>([]);
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [loadingMore, setLoadingMore] = useState<boolean>(false);
  const [search, setSearch] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  const [editingConversationId, setEditingConversationId] = useState<string | null>(null);
  const [editingTitle, setEditingTitle] = useState<string>('');

  const [menuAnchorEl, setMenuAnchorEl] = useState<null | HTMLElement>(null);
  const [menuConversationId, setMenuConversationId] = useState<string | null>(null);

  const load = async (opts: { append: boolean; cursor?: string; search?: string }) => {
    if (!token || !orgId) return;

    if (opts.append) {
      setLoadingMore(true);
    } else {
      setLoading(true);
      setError(null);
    }

    try {
      const res: ConversationListResponse = await listOrgConversations(token, orgId, {
        search: opts.search ?? search,
        limit: 30,
        cursor: opts.cursor
      });

      setNextCursor(res.nextCursor);

      if (opts.append) {
        setItems((prev) => [...prev, ...res.items]);
      } else {
        setItems(res.items);
      }
    } catch (err) {
      setError((err as Error).message || 'Failed to load conversations');
    } finally {
      if (opts.append) {
        setLoadingMore(false);
      } else {
        setLoading(false);
      }
    }
  };

  useEffect(() => {
    // Initial load
    void load({ append: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [token, orgId]);

  const handleSearchSubmit: React.FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();
    void load({ append: false, search });
  };

  const handleNewChat = async () => {
    if (!token || !orgId) return;
    try {
      const convo = await createOrgConversation(token, orgId, {});
      // Optimistically prepend new conversation
      setItems((prev) => [convo, ...prev]);
      navigate(`/app/orgs/${orgId}/chat/${convo.id}`);
    } catch (err) {
      setError((err as Error).message || 'Failed to create conversation');
    }
  };

  const handleSelect = (id: string) => {
    if (!orgId) return;
    navigate(`/app/orgs/${orgId}/chat/${id}`);
  };

  const handleOpenMenu = (event: React.MouseEvent<HTMLElement>, conversationId: string) => {
    event.stopPropagation();
    setMenuAnchorEl(event.currentTarget);
    setMenuConversationId(conversationId);
  };

  const handleCloseMenu = () => {
    setMenuAnchorEl(null);
    setMenuConversationId(null);
  };

  const handleBeginRename = (item: ConversationListItem) => {
    setEditingConversationId(item.id);
    setEditingTitle(item.title);
    handleCloseMenu();
  };

  const handleSaveTitle = async (conversationId: string, title: string) => {
    if (!token) return;
    const trimmed = title.trim();
    const newTitle = trimmed || 'Untitled chat';

    try {
      const updated = await updateConversation(token, conversationId, { title: newTitle });
      setItems((prev) => prev.map((c) => (c.id === conversationId ? updated : c)));
    } catch (err) {
      setError((err as Error).message || 'Failed to rename conversation');
    } finally {
      setEditingConversationId(null);
      setEditingTitle('');
    }
  };

  const handleTogglePinned = async (item: ConversationListItem) => {
    if (!token) return;
    try {
      const updated = await updateConversation(token, item.id, { pinned: !item.pinned });
      setItems((prev) => prev.map((c) => (c.id === item.id ? updated : c)));
    } catch (err) {
      setError((err as Error).message || 'Failed to update conversation');
    } finally {
      handleCloseMenu();
    }
  };

  const handleArchive = async (item: ConversationListItem) => {
    if (!token) return;
    try {
      const updated = await updateConversation(token, item.id, { archived: true });
      setItems((prev) => prev.filter((c) => c.id !== updated.id));
    } catch (err) {
      setError((err as Error).message || 'Failed to archive conversation');
    } finally {
      handleCloseMenu();
    }
  };

  const pinned = useMemo(() => items.filter((i) => i.pinned), [items]);
  const others = useMemo(() => items.filter((i) => !i.pinned), [items]);

  const menuConversation = useMemo(
    () => items.find((c) => c.id === menuConversationId) || null,
    [items, menuConversationId]
  );

  return (
    <Box
      sx={{
        width: 290,
        flexShrink: 0,
        display: 'flex',
        flexDirection: 'column',
        borderRight: (theme) => `1px solid ${theme.palette.divider}`,
        background:
          'linear-gradient(180deg, rgba(17,24,39,0.98), rgba(15,23,42,0.98)), radial-gradient(circle at top left, rgba(124,77,255,0.18), transparent 55%)',
        color: 'rgba(255,255,255,0.92)'
      }}
    >
      <Box p={2} pb={1} display="flex" flexDirection="column" gap={1.5}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Typography variant="subtitle1">Conversations</Typography>
          <Button
            size="small"
            variant="contained"
            startIcon={<AddIcon />}
            onClick={handleNewChat}
            sx={{ borderRadius: 999, textTransform: 'none' }}
          >
            New
          </Button>
        </Box>

        <Box component="form" onSubmit={handleSearchSubmit}>
          <TextField
            fullWidth
            size="small"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search conversations"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon fontSize="small" />
                </InputAdornment>
              )
            }}
            variant="outlined"
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 999,
                backgroundColor: 'rgba(15,23,42,0.9)',
                '& fieldset': {
                  borderColor: 'rgba(148,163,184,0.5)'
                },
                '&:hover fieldset': {
                  borderColor: 'rgba(209,213,219,0.8)'
                }
              },
              '& .MuiInputBase-input': {
                color: 'rgba(248,250,252,0.95)'
              }
            }}
          />
        </Box>

        {error && (
          <Typography variant="caption" color="error">
            {error}
          </Typography>
        )}
      </Box>

      <Box flex={1} overflow="auto" px={1} pb={1}>
        {loading && !items.length ? (
          <Box display="flex" alignItems="center" justifyContent="center" mt={4}>
            <CircularProgress size={24} />
          </Box>
        ) : (
          <>
            {pinned.length > 0 && (
              <>
                <Typography
                  variant="caption"
                  sx={{
                    px: 1.5,
                    mb: 0.5,
                    textTransform: 'uppercase',
                    letterSpacing: 0.08,
                    opacity: 0.7
                  }}
                >
                  Pinned
                </Typography>
                <List dense disablePadding>
                  {pinned.map((item) => {
                    const isSelected = item.id === selectedConversationId;
                    const isEditing = item.id === editingConversationId;

                    return (
                      <ListItemButton
                        key={item.id}
                        selected={isSelected}
                        onClick={() => handleSelect(item.id)}
                        sx={{
                          borderRadius: 2,
                          mb: 0.5,
                          '&.Mui-selected': {
                            background:
                              'linear-gradient(90deg, rgba(124,77,255,0.35), rgba(3,218,198,0.25))'
                          },
                          '&:hover': {
                            backgroundColor: 'rgba(30,64,175,0.45)'
                          }
                        }}
                      >
                        {isEditing ? (
                          <TextField
                            autoFocus
                            size="small"
                            value={editingTitle}
                            onClick={(e) => e.stopPropagation()}
                            onChange={(e) => setEditingTitle(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                (e.currentTarget as HTMLInputElement).blur();
                              } else if (e.key === 'Escape') {
                                e.preventDefault();
                                setEditingConversationId(null);
                                setEditingTitle('');
                              }
                            }}
                            onBlur={() => {
                              if (!editingConversationId) return;
                              void handleSaveTitle(editingConversationId, editingTitle);
                            }}
                            variant="outlined"
                            sx={{
                              '& .MuiOutlinedInput-root': {
                                height: 32,
                                fontSize: 14
                              }
                            }}
                          />
                        ) : (
                          <ListItemText
                            primary={item.title}
                            secondary={new Date(item.lastActivityAt).toLocaleString()}
                            primaryTypographyProps={{
                              noWrap: true,
                              fontSize: 14
                            }}
                            secondaryTypographyProps={{
                              noWrap: true,
                              fontSize: 11,
                              color: 'rgba(148,163,184,0.9)'
                            }}
                          />
                        )}
                        {!isEditing && (
                          <ListItemSecondaryAction>
                            <Tooltip title="More actions">
                              <IconButton
                                size="small"
                                edge="end"
                                onClick={(e) => handleOpenMenu(e, item.id)}
                              >
                                <MoreVertIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </ListItemSecondaryAction>
                        )}
                      </ListItemButton>
                    );
                  })}
                </List>
              </>
            )}

            {others.length > 0 && (
              <>
                {pinned.length > 0 && (
                  <Typography
                    variant="caption"
                    sx={{
                      px: 1.5,
                      mt: 1,
                      mb: 0.5,
                      textTransform: 'uppercase',
                      letterSpacing: 0.08,
                      opacity: 0.7
                    }}
                  >
                    Recent
                  </Typography>
                )}
                <List dense disablePadding>
                  {others.map((item) => {
                    const isSelected = item.id === selectedConversationId;
                    const isEditing = item.id === editingConversationId;

                    return (
                      <ListItemButton
                        key={item.id}
                        selected={isSelected}
                        onClick={() => handleSelect(item.id)}
                        sx={{
                          borderRadius: 2,
                          mb: 0.5,
                          '&.Mui-selected': {
                            background:
                              'linear-gradient(90deg, rgba(56,189,248,0.25), rgba(94,234,212,0.25))'
                          },
                          '&:hover': {
                            backgroundColor: 'rgba(15,23,42,0.85)'
                          }
                        }}
                      >
                        {isEditing ? (
                          <TextField
                            autoFocus
                            size="small"
                            value={editingTitle}
                            onClick={(e) => e.stopPropagation()}
                            onChange={(e) => setEditingTitle(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                (e.currentTarget as HTMLInputElement).blur();
                              } else if (e.key === 'Escape') {
                                e.preventDefault();
                                setEditingConversationId(null);
                                setEditingTitle('');
                              }
                            }}
                            onBlur={() => {
                              if (!editingConversationId) return;
                              void handleSaveTitle(editingConversationId, editingTitle);
                            }}
                            variant="outlined"
                            sx={{
                              '& .MuiOutlinedInput-root': {
                                height: 32,
                                fontSize: 14
                              }
                            }}
                          />
                        ) : (
                          <ListItemText
                            primary={item.title}
                            secondary={new Date(item.lastActivityAt).toLocaleString()}
                            primaryTypographyProps={{ noWrap: true, fontSize: 14 }}
                            secondaryTypographyProps={{
                              noWrap: true,
                              fontSize: 11,
                              color: 'rgba(148,163,184,0.9)'
                            }}
                          />
                        )}
                        {!isEditing && (
                          <ListItemSecondaryAction>
                            <Tooltip title="More actions">
                              <IconButton
                                size="small"
                                edge="end"
                                onClick={(e) => handleOpenMenu(e, item.id)}
                              >
                                <MoreVertIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </ListItemSecondaryAction>
                        )}
                      </ListItemButton>
                    );
                  })}
                </List>
              </>
            )}

            {!items.length && !loading && (
              <Box px={2} py={3}>
                <Typography variant="body2" color="rgba(148,163,184,0.9)">
                  No conversations yet. Start a new one to begin chatting.
                </Typography>
              </Box>
            )}

            {nextCursor && (
              <Box display="flex" justifyContent="center" mt={1} mb={1.5}>
                <Button
                  size="small"
                  variant="outlined"
                  onClick={() => load({ append: true, cursor: nextCursor })}
                  disabled={loadingMore}
                >
                  {loadingMore ? 'Loading…' : 'Load more'}
                </Button>
              </Box>
            )}
          </>
        )}
      </Box>

      <Menu
        anchorEl={menuAnchorEl}
        open={Boolean(menuAnchorEl) && Boolean(menuConversation)}
        onClose={handleCloseMenu}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        transformOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        {menuConversation && (
          <>
            <MenuItem
              onClick={() => {
                handleBeginRename(menuConversation);
              }}
            >
              Rename
            </MenuItem>
            <MenuItem
              onClick={() => {
                void handleTogglePinned(menuConversation);
              }}
            >
              {menuConversation.pinned ? 'Unpin' : 'Pin'}
            </MenuItem>
            <MenuItem
              onClick={() => {
                void handleArchive(menuConversation);
              }}
            >
              Archive
            </MenuItem>
          </>
        )}
      </Menu>
    </Box>
  );
};
```

This implementation:

- Keeps the **layout and styling** from 22.md (pinned/recent sections, gradients, micro‑interactions).  
- Adds inline rename via a `TextField` shown when `editingConversationId` matches the item.  
- Introduces a per‑row **more actions menu** with Rename / Pin / Unpin / Archive.  
- Uses existing `updateConversation` API for updates – no backend changes required.

---

## 23.3. Sanity Checks

From the repo root:

1. **Frontend typecheck & lint**

   ```bash
   pnpm lint
   pnpm typecheck
   ```

2. **Run web app:**

   ```bash
   cd apps/web
   pnpm dev
   ```

3. **Verify inline rename:**

   - Open `/app/orgs/<orgId>/chat/<conversationId>`.  
   - In sidebar, click the **⋮** menu on a conversation and choose **Rename**.  
   - The title should turn into an inline input with the current title.  
   - Edit the text:
     - Press **Enter** → saves and exits edit mode.  
     - Click outside (blur) → saves and exits.  
     - Press **Esc** → cancels and restores previous title.

4. **Verify menu actions:**

   - **Pin/Unpin** updates the `pinned` state and reorders lists accordingly.  
   - **Archive** removes the conversation from the sidebar (since `archivedAt` is set).

If all checks pass, your conversation sidebar now offers a **much smoother, production‑grade UX** for managing chats: inline renaming, context menus, and clean Material 3 micro‑interactions.

---

_End of 23.md – Conversation Inline Rename & Context Menu UX_
