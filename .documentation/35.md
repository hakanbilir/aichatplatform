# 35. Prompt Library, Conversation Presets & Org AI Policies

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human product/backend/frontend engineers.  
> **Goal of this file:** Design and implement a **first‑class prompt system** for the AI chat platform so that:
>
> - Users can create and reuse **prompt templates** (system prompts, initial instructions, macros).  
> - Orgs can define **org‑wide AI policies** and default behaviors.  
> - Conversations can be created from **presets** (prompt + tools + model + RAG settings).  
> - The system supports **multi‑tenant, RBAC‑aware** prompt management with clear APIs and UI hooks.

This file builds on:

- 13.md – Role & RBAC model.  
- 19.md – Org quota / usage guard.  
- 25–26.md – Chat engine & tools.  
- 31.md – Security & multi‑tenant isolation.  
- 33–34.md – RAG settings & Knowledge Base UI.

---

## 35.1. Concepts & Terminology

We introduce several levels of prompt control:

- **User Prompt Template** – A reusable template created by a single user for their own use (e.g. “Rewrite in formal English”, “Summarize legal decision in bullet points”).  
- **Org Prompt Template** – A template shared org‑wide (e.g. “Customer support reply”, “Bug triage summary”).  
- **Org AI Policy** – A set of org‑level constraints and preferences applied as **system messages** to all conversations in the org (e.g. style guidelines, forbidden topics, compliance hints).  
- **Conversation Preset** – A saved configuration that can be used to quickly create a new conversation with: 
  - default system prompt,  
  - selected tools,  
  - model choice,  
  - RAG settings,  
  - optional UI metadata (icon, color).

All of these entities are **org‑scoped** where appropriate and honor RBAC.

---

## 35.2. Data Model (Prisma)

We add the following models to the Prisma schema.

```prisma
model OrgAiPolicy {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orgId       String   @unique

  // High-level description for admins
  name        String
  description String?

  // System message text injected into conversations
  systemPrompt String

  // JSON flags for additional behavior, e.g. style presets, safety toggles
  config      Json

  org Org @relation(fields: [orgId], references: [id])
}

model PromptTemplate {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orgId       String
  createdById String

  // If true, visible to entire org; otherwise private to creator
  isOrgShared Boolean  @default(false)

  title       String
  description String?

  // e.g. "system", "user" or mixed semantics depending on usage
  kind        String   // "system" | "user" | "macro"

  // Template with variables, e.g. "Rewrite the following text for {{audience}}: {{text}}"
  template    String

  // JSON describing variables: [{ name, label, type, required, default }]
  variables   Json

  org   Org   @relation(fields: [orgId], references: [id])
  owner User  @relation(fields: [createdById], references: [id])

  usages PromptUsage[]
}

model PromptUsage {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  orgId          String
  templateId     String
  userId         String
  conversationId String

  org         Org            @relation(fields: [orgId], references: [id])
  template    PromptTemplate @relation(fields: [templateId], references: [id])
  user        User           @relation(fields: [userId], references: [id])
  conversation Conversation  @relation(fields: [conversationId], references: [id])
}

model ConversationPreset {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orgId       String
  createdById String

  name        String
  description String?

  // Visual metadata (icon, color, emoji, etc.)
  uiConfig    Json

  // System prompt to use when starting conversations from this preset
  systemPrompt String

  // Serialized configuration: model, tools, RAG, tool config, etc.
  config      Json

  org   Org  @relation(fields: [orgId], references: [id])
  owner User @relation(fields: [createdById], references: [id])
}
```

Key points:

- `OrgAiPolicy` – at most one per org (`orgId` is unique).  
- `PromptTemplate` – both private (user‑only) and org‑shared templates in one table.  
- `PromptUsage` – used for analytics (which templates are popular, etc.).  
- `ConversationPreset` – a richer “GPT style” preset that captures config for quick conversation creation.

---

## 35.3. Org AI Policy Service & API

Org AI policy acts as a **global system prompt** overlay for all conversations in the org.

### 35.3.1. Service

**File:** `apps/api-gateway/src/services/orgAiPolicy.ts`

```ts
// apps/api-gateway/src/services/orgAiPolicy.ts

import { prisma } from '@ai-chat/db';

export interface OrgAiPolicyConfig {
  tone?: 'formal' | 'casual' | 'neutral';
  disallowTopics?: string[]; // e.g. ["politics", "medical"]
  extra?: Record<string, any>;
}

export interface OrgAiPolicyDto {
  id: string;
  orgId: string;
  name: string;
  description: string | null;
  systemPrompt: string;
  config: OrgAiPolicyConfig;
}

export async function getOrgAiPolicy(orgId: string): Promise<OrgAiPolicyDto | null> {
  const row = await prisma.orgAiPolicy.findUnique({ where: { orgId } });
  if (!row) return null;

  return {
    id: row.id,
    orgId: row.orgId,
    name: row.name,
    description: row.description,
    systemPrompt: row.systemPrompt,
    config: row.config as OrgAiPolicyConfig
  };
}

export async function upsertOrgAiPolicy(params: {
  orgId: string;
  name: string;
  description?: string | null;
  systemPrompt: string;
  config?: OrgAiPolicyConfig;
}): Promise<OrgAiPolicyDto> {
  const row = await prisma.orgAiPolicy.upsert({
    where: { orgId: params.orgId },
    update: {
      name: params.name,
      description: params.description ?? null,
      systemPrompt: params.systemPrompt,
      config: params.config ?? {}
    },
    create: {
      orgId: params.orgId,
      name: params.name,
      description: params.description ?? null,
      systemPrompt: params.systemPrompt,
      config: params.config ?? {}
    }
  });

  return {
    id: row.id,
    orgId: row.orgId,
    name: row.name,
    description: row.description,
    systemPrompt: row.systemPrompt,
    config: row.config as OrgAiPolicyConfig
  };
}
```

### 35.3.2. Org AI Policy Routes

**File:** `apps/api-gateway/src/routes/orgAiPolicy.ts`

```ts
// apps/api-gateway/src/routes/orgAiPolicy.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { getOrgAiPolicy, upsertOrgAiPolicy } from '../services/orgAiPolicy';

const policyBodySchema = z.object({
  name: z.string().min(1).max(128),
  description: z.string().max(1024).optional(),
  systemPrompt: z.string().min(1),
  config: z
    .object({
      tone: z.enum(['formal', 'casual', 'neutral']).optional(),
      disallowTopics: z.array(z.string()).optional(),
      extra: z.record(z.any()).optional()
    })
    .optional()
});

export default async function orgAiPolicyRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  app.get('/orgs/:orgId/ai-policy', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:manage'
    );

    const policy = await getOrgAiPolicy(orgId);
    return reply.send({ policy });
  });

  app.put('/orgs/:orgId/ai-policy', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:manage'
    );

    const parsed = policyBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const policy = await upsertOrgAiPolicy({
      orgId,
      name: parsed.data.name,
      description: parsed.data.description ?? null,
      systemPrompt: parsed.data.systemPrompt,
      config: parsed.data.config
    });

    return reply.send({ policy });
  });
}
```

Register in `main.ts`:

```ts
import orgAiPolicyRoutes from './routes/orgAiPolicy';

await app.register(orgAiPolicyRoutes);
```

RBAC: Only roles with `org:settings:manage` can view/edit the org AI policy.

---

## 35.4. Prompt Template Service & API

Prompt templates power reusable instructions for users and orgs.

### 35.4.1. Template Variable Shape

Variables are defined as JSON on `PromptTemplate.variables`:

```ts
export interface PromptVariable {
  name: string; // e.g. "audience"
  label: string; // e.g. "Audience"
  type: 'string' | 'number' | 'boolean' | 'multiline';
  required: boolean;
  defaultValue?: string | number | boolean;
}
```

### 35.4.2. Service

**File:** `apps/api-gateway/src/services/promptTemplates.ts`

```ts
// apps/api-gateway/src/services/promptTemplates.ts

import { prisma } from '@ai-chat/db';

export type PromptTemplateKind = 'system' | 'user' | 'macro';

export interface PromptTemplateInput {
  orgId: string;
  createdById: string;
  isOrgShared: boolean;
  title: string;
  description?: string | null;
  kind: PromptTemplateKind;
  template: string;
  variables: any;
}

export async function createPromptTemplate(input: PromptTemplateInput) {
  return prisma.promptTemplate.create({
    data: {
      orgId: input.orgId,
      createdById: input.createdById,
      isOrgShared: input.isOrgShared,
      title: input.title,
      description: input.description ?? null,
      kind: input.kind,
      template: input.template,
      variables: input.variables
    }
  });
}

export async function listPromptTemplates(orgId: string, userId: string) {
  return prisma.promptTemplate.findMany({
    where: {
      orgId,
      OR: [{ isOrgShared: true }, { createdById: userId }]
    },
    orderBy: { createdAt: 'asc' }
  });
}

export async function updatePromptTemplate(
  orgId: string,
  templateId: string,
  data: Partial<{
    title: string;
    description: string | null;
    template: string;
    variables: any;
    isOrgShared: boolean;
  }>
) {
  return prisma.promptTemplate.updateMany({
    where: {
      id: templateId,
      orgId
    },
    data
  });
}

export async function deletePromptTemplate(orgId: string, templateId: string) {
  await prisma.promptTemplate.deleteMany({
    where: {
      id: templateId,
      orgId
    }
  });
}

export async function recordPromptUsage(params: {
  orgId: string;
  templateId: string;
  userId: string;
  conversationId: string;
}) {
  await prisma.promptUsage.create({
    data: {
      orgId: params.orgId,
      templateId: params.templateId,
      userId: params.userId,
      conversationId: params.conversationId
    }
  });
}
```

### 35.4.3. Routes

**File:** `apps/api-gateway/src/routes/promptTemplates.ts`

```ts
// apps/api-gateway/src/routes/promptTemplates.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import {
  createPromptTemplate,
  deletePromptTemplate,
  listPromptTemplates,
  updatePromptTemplate
} from '../services/promptTemplates';

const templateBodySchema = z.object({
  title: z.string().min(1).max(128),
  description: z.string().max(512).optional(),
  kind: z.enum(['system', 'user', 'macro']),
  template: z.string().min(1),
  variables: z.array(
    z.object({
      name: z.string().min(1).max(64),
      label: z.string().min(1).max(128),
      type: z.enum(['string', 'number', 'boolean', 'multiline']),
      required: z.boolean(),
      defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional()
    })
  ),
  isOrgShared: z.boolean().optional()
});

const updateBodySchema = templateBodySchema.partial();

export default async function promptTemplatesRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.get('/orgs/:orgId/prompts', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:read'
    );

    const templates = await listPromptTemplates(orgId, payload.userId);
    return reply.send({ templates });
  });

  app.post('/orgs/:orgId/prompts', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const parsed = templateBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const template = await createPromptTemplate({
      orgId,
      createdById: payload.userId,
      isOrgShared: parsed.data.isOrgShared ?? false,
      title: parsed.data.title,
      description: parsed.data.description,
      kind: parsed.data.kind,
      template: parsed.data.template,
      variables: parsed.data.variables
    });

    return reply.code(201).send({ template });
  });

  app.patch('/orgs/:orgId/prompts/:templateId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const templateId = (request.params as any).templateId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const parsed = updateBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    await updatePromptTemplate(orgId, templateId, parsed.data);
    return reply.send({ ok: true });
  });

  app.delete('/orgs/:orgId/prompts/:templateId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const templateId = (request.params as any).templateId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    await deletePromptTemplate(orgId, templateId);
    return reply.send({ ok: true });
  });
}
```

Register in `main.ts`:

```ts
import promptTemplatesRoutes from './routes/promptTemplates';

await app.register(promptTemplatesRoutes);
```

Permissions:

- `GET /prompts` – `org:chat:read`.  
- `POST/PATCH/DELETE` – `org:chat:write`.

---

## 35.5. Conversation Presets Service & API

Conversation presets are like “mini‑GPTs” that users can click to start a configured conversation.

### 35.5.1. Config Shape

`ConversationPreset.config` can hold:

```ts
export interface ConversationPresetConfig {
  modelId: string; // e.g. "gpt-4.1" or "llama3:8b"
  tools: string[]; // tool names enabled by default
  rag?: {
    enabled: boolean;
    spaceId: string | null;
    maxChunks: number;
  };
  temperature?: number;
  maxOutputTokens?: number;
}
```

### 35.5.2. Service

**File:** `apps/api-gateway/src/services/conversationPresets.ts`

```ts
// apps/api-gateway/src/services/conversationPresets.ts

import { prisma } from '@ai-chat/db';

export interface ConversationPresetInput {
  orgId: string;
  createdById: string;
  name: string;
  description?: string | null;
  uiConfig?: any;
  systemPrompt: string;
  config: any;
}

export async function createConversationPreset(input: ConversationPresetInput) {
  return prisma.conversationPreset.create({
    data: {
      orgId: input.orgId,
      createdById: input.createdById,
      name: input.name,
      description: input.description ?? null,
      uiConfig: input.uiConfig ?? {},
      systemPrompt: input.systemPrompt,
      config: input.config
    }
  });
}

export async function listConversationPresets(orgId: string) {
  return prisma.conversationPreset.findMany({
    where: { orgId },
    orderBy: { createdAt: 'asc' }
  });
}

export async function updateConversationPreset(
  orgId: string,
  presetId: string,
  data: Partial<{
    name: string;
    description: string | null;
    uiConfig: any;
    systemPrompt: string;
    config: any;
  }>
) {
  return prisma.conversationPreset.updateMany({
    where: {
      id: presetId,
      orgId
    },
    data
  });
}

export async function deleteConversationPreset(orgId: string, presetId: string) {
  await prisma.conversationPreset.deleteMany({
    where: {
      id: presetId,
      orgId
    }
  });
}
```

### 35.5.3. Routes

**File:** `apps/api-gateway/src/routes/conversationPresets.ts`

```ts
// apps/api-gateway/src/routes/conversationPresets.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import {
  createConversationPreset,
  deleteConversationPreset,
  listConversationPresets,
  updateConversationPreset
} from '../services/conversationPresets';

const presetBodySchema = z.object({
  name: z.string().min(1).max(128),
  description: z.string().max(512).optional(),
  uiConfig: z.record(z.any()).optional(),
  systemPrompt: z.string().min(1),
  config: z.record(z.any())
});

const updateBodySchema = presetBodySchema.partial();

export default async function conversationPresetsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.get('/orgs/:orgId/presets', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:read'
    );

    const presets = await listConversationPresets(orgId);
    return reply.send({ presets });
  });

  app.post('/orgs/:orgId/presets', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const parsed = presetBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const preset = await createConversationPreset({
      orgId,
      createdById: payload.userId,
      name: parsed.data.name,
      description: parsed.data.description ?? null,
      uiConfig: parsed.data.uiConfig ?? {},
      systemPrompt: parsed.data.systemPrompt,
      config: parsed.data.config
    });

    return reply.code(201).send({ preset });
  });

  app.patch('/orgs/:orgId/presets/:presetId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const presetId = (request.params as any).presetId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const parsed = updateBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    await updateConversationPreset(orgId, presetId, parsed.data);
    return reply.send({ ok: true });
  });

  app.delete('/orgs/:orgId/presets/:presetId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const presetId = (request.params as any).presetId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    await deleteConversationPreset(orgId, presetId);
    return reply.send({ ok: true });
  });
}
```

Register in `main.ts`:

```ts
import conversationPresetsRoutes from './routes/conversationPresets';

await app.register(conversationPresetsRoutes);
```

---

## 35.6. Chat Engine Integration

We integrate **Org AI Policy** and **Conversation Preset system prompts** into `runConversationTurn`.

### 35.6.1. System Messages Priority

When constructing the message list for the model, apply the following order:

1. **Org AI Policy system prompt** (if present).  
2. **Conversation preset system prompt** (if present).  
3. Any conversation‑specific ad‑hoc system messages (e.g. user edited system prompt).  
4. RAG context system message (if enabled, 33.7).  
5. Historical messages (user/assistant/tool) as usual.

This can be implemented by progressively prepending to `baseMessages` in `chatEngine.ts`.

### 35.6.2. Example Pseudocode Snippet

```ts
const baseMessages: ModelMessage[] = buildHistoryMessages(/* ... */);

// RAG context (from 33.7)
if (ragContextText) {
  baseMessages.unshift({
    role: 'system',
    content:
      'You have access to the following knowledge base context. Use it to answer the user question. ' +
      'If the context does not contain the answer, say so explicitly.\n\n' +
      ragContextText
  });
}

// Conversation preset system prompt
if (conversation.presetSystemPrompt) {
  baseMessages.unshift({
    role: 'system',
    content: conversation.presetSystemPrompt
  });
}

// Org AI policy
const policy = await getOrgAiPolicy(conversation.orgId);
if (policy) {
  baseMessages.unshift({
    role: 'system',
    content: policy.systemPrompt
  });
}
```

You may store `presetSystemPrompt` directly on the conversation when created from a preset.

### 35.6.3. Creating Conversations from Presets

Add a field to the "Create conversation" API (25.md) such as `presetId?: string`. When `presetId` is supplied:

1. Load the `ConversationPreset` (ensure `orgId` matches).  
2. Set initial conversation settings:
   - `modelId` from `preset.config.modelId`.  
   - Enabled tools from `preset.config.tools`.  
   - RAG settings from `preset.config.rag`.  
3. Store `preset.systemPrompt` on `conversation.presetSystemPrompt` (or in `conversation.settings`).

This allows the UI to expose a catalog of presets (“Chatbots”) that behave like custom assistants.

---

## 35.7. Frontend Integration Sketch (High‑Level)

A dedicated UI spec can live in another md; here we outline minimal wiring so agents understand dependencies.

### 35.7.1. Prompt Library Panel

- Location: In the main chat UI, a **side drawer or bottom sheet** labelled “Prompt Library”.  
- Features:
  - List templates (`GET /orgs/:orgId/prompts`).  
  - Filter: “My prompts” vs “Org prompts” (client‑side using `createdById` vs `isOrgShared` if exposed).  
  - Actions: apply template → open a small form to fill variables → insert into input box.

### 35.7.2. Org AI Policy Editor

- Location: Org settings page (`/app/orgs/:orgId/settings/ai-policy`).  
- Features:
  - Inputs for `name`, `description`, large textarea for `systemPrompt`.  
  - Optional toggles for tone (formal/casual/neutral) and disallowed topics.  
  - Preview card showing “How the assistant will behave for this org”.

### 35.7.3. Presets Gallery

- Location: `/app/orgs/:orgId/presets` and also inline in conversation creation UI.  
- Features:
  - Cards listing presets (name, description, icon/color).  
  - Button “Start conversation” → navigates to new conversation with `presetId`.  
  - Admin‑only editing (rename, update system prompt, tune config).

A future md file can define exact Material 3 components, layouts and gradients.

---

## 35.8. Observability & Analytics

Integrate with 28.md (metrics) and 29.md (analytics):

- Metrics:
  - `prompt_template_usage_total{orgId, templateId}` – incremented in `recordPromptUsage`.  
  - `conversation_from_preset_total{orgId, presetId}` – increment when new conversations are created from presets.  
- Analytics:
  - Extend `OrgAnalyticsResult` (29.md) with:
    - `topPromptTemplates` (by usage count).  
    - `conversationsByPreset` (distribution of preset usage).

This helps org admins understand how prompts and presets drive behavior.

---

## 35.9. Sanity Checklist

Before enabling prompt library & policies in production:

- [ ] Prisma migrations for `OrgAiPolicy`, `PromptTemplate`, `PromptUsage`, `ConversationPreset` applied.  
- [ ] Org AI policy routes (`/ai-policy`) protected by `org:settings:manage`.  
- [ ] Prompt template routes correctly filter by `orgId` and only show private + org prompts.  
- [ ] Conversation creation from presets correctly applies model/tools/RAG/system prompt.  
- [ ] Chat engine composes system messages in the correct priority order (policy → preset → custom → RAG).  
- [ ] Metrics & analytics for prompt and preset usage are wired and visible in Grafana.

If all checks pass, your AI chat platform now has a **rich prompt library and org‑level control layer**, on par with and extending beyond typical ChatGPT “custom GPT” and “system prompt” features—in a multi‑tenant, enterprise‑ready way.

---

_End of 35.md – Prompt Library, Conversation Presets & Org AI Policies_
