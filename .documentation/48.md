# 48. Enterprise SSO (SAML/OIDC) & Seat‑Based Licensing

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Implement **enterprise‑grade authentication** and **seat‑based licensing** so that:
>
> - Orgs can connect their **IdP** (Okta, Azure AD, Google Workspace, etc.) via **SAML 2.0** or **OIDC**.  
> - Users can sign in using **SSO instead of passwords**, with just‑in‑time (JIT) provisioning.  
> - **Seat limits** are enforced from billing plans (46.md) – e.g. 10, 50, 200 seats per org.  
> - SSO login & membership changes are reflected in **audit logs, analytics & billing**.  
> - All flows remain multi‑tenant, RBAC‑aware and work cleanly with the rest of the platform.
>
> This spec is written so Cursor‑like agents can implement it end‑to‑end without further questions.

This file builds on:

- 11–14.md – Orgs, users, roles & RBAC.  
- 18.md – Auth & JWT.  
- 19.md – Quotas & usage limits.  
- 40.md – Org Admin Console.  
- 45.md – Usage analytics.  
- 46.md – Billing & plans (`limits` JSON).  
- 47.md – Branding & hostname tenancy.

---

## 48.1. Concepts & Scope

We introduce:

1. **SSO Connection** (per org)
   - A configured link to an external IdP (SAML or OIDC).  
   - Holds metadata (issuer, ACS URL, certs, client ID/secret, mapping rules).

2. **SSO Login Flow**
   - **SP‑initiated**: user clicks "Continue with SSO" → redirect to IdP → callback → JWT.  
   - **IdP‑initiated**: IdP sends SAML/OIDC response to callback URL → we resolve org & user.

3. **JIT Provisioning & Seat Limits**
   - If user doesn’t exist locally, we can create them automatically (subject to seat limits).  
   - Seat limits come from `BillingPlan.limits.max_seats` etc.  
   - If seats exhausted, login is rejected or user becomes **pending** (configurable).

4. **SSO & RBAC**
   - IdP group/role claims can map to platform roles (`org_admin`, `member`, `viewer`, etc.).

5. **SSO Audit**
   - Each SSO login attempt is written to an `SsoLoginAudit` table for security & compliance.

Non‑goals:

- Implementing MFA (can be handled by IdP).  
- Advanced SCIM provisioning (out of scope for this version—but we keep space in schema).

---

## 48.2. Data Model – Prisma

Extend `packages/db/prisma/schema.prisma` with SSO models.

```prisma
/// Per-org SSO config (SAML or OIDC)
model SsoConnection {
  id        String   @id @default(cuid())

  orgId     String

  // 'saml' or 'oidc'
  type      String

  name      String   // e.g. 'Acme Okta SAML'

  // Is this connection active and offered on login?
  isEnabled Boolean  @default(false)

  // If true, new SSO users can be auto-created up to seat limits
  enableJitProvisioning Boolean @default(true)

  // For SAML: entityID, ACS URL, certificate(s), mappings, etc.
  // For OIDC: issuer, clientId, clientSecret, scopes, mappings, etc.
  config    Json

  // Optional: limits/flags like whether IdP-initiated SSO is allowed
  flags     Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Org      @relation(fields: [orgId], references: [id])

  @@index([orgId])
}

/// Audit log of SSO sign-in attempts
model SsoLoginAudit {
  id        String   @id @default(cuid())

  orgId     String
  userId    String?

  // 'saml' or 'oidc'
  type      String
  connectionId String?

  email     String?

  status    String   // 'success', 'failed'
  reason    String?  // e.g. 'seat_limit', 'no_matching_user', 'invalid_assertion'

  ip        String?
  userAgent String?

  rawPayload Json?   // sanitized subset of assertion/claims for debugging

  createdAt DateTime @default(now())

  org       Org      @relation(fields: [orgId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])

  @@index([orgId])
  @@index([userId])
}
```

### 48.2.1. Plan Limits for Seats & SSO

We extend the **expected shape** of `BillingPlan.limits` (46.md) to include:

```jsonc
{
  "max_seats": 10,                 // max active members/org
  "sso_allowed": true,             // whether SSO features allowed
  "jit_provisioning_allowed": true // whether SSO can auto-create users
}
```

Backend code must tolerate older plans without these keys (fallback defaults).

---

## 48.3. Seat Counting & Enforcement

### 48.3.1. Seat Definition

A **seat** is a **distinct active user** with membership in an org (see 11–14.md) that is not soft‑deleted and not disabled.

We assume there is a join table or equivalent (e.g. `OrgUser` / `OrgMembership`) backing org membership.  
Seat count is defined as the number of **non‑disabled memberships** in that org.

### 48.3.2. Seat Utility

**File:** `apps/api-gateway/src/billing/seatService.ts`

```ts
// apps/api-gateway/src/billing/seatService.ts

import { prisma } from '@ai-chat/db';

export interface SeatLimits {
  maxSeats: number | null;
  ssoAllowed: boolean;
  jitProvisioningAllowed: boolean;
}

export async function getSeatLimitsForOrg(orgId: string): Promise<SeatLimits> {
  const sub = await prisma.orgSubscription.findUnique({
    where: { orgId },
    include: { plan: true }
  });

  if (!sub || !sub.plan) {
    // Fallback: unlimited seats, SSO allowed = false
    return {
      maxSeats: null,
      ssoAllowed: false,
      jitProvisioningAllowed: false
    };
  }

  const limits = (sub.plan.limits as any) || {};

  return {
    maxSeats: typeof limits.max_seats === 'number' ? limits.max_seats : null,
    ssoAllowed: Boolean(limits.sso_allowed),
    jitProvisioningAllowed: Boolean(limits.jit_provisioning_allowed)
  };
}

export async function countActiveSeats(orgId: string): Promise<number> {
  // Assuming OrgMembership holds active members per org.
  return prisma.orgMembership.count({
    where: {
      orgId,
      isDisabled: false
    }
  });
}

export async function canAddSeat(orgId: string): Promise<boolean> {
  const limits = await getSeatLimitsForOrg(orgId);
  if (limits.maxSeats == null) return true;

  const used = await countActiveSeats(orgId);
  return used < limits.maxSeats;
}
```

> **Note:** Update this file to use the real membership model name (`OrgMembership`, `OrgUser`, etc.) as defined in 11–14.md.

Seat checks are used when:

- Inviting a new user by email.  
- Promoting an existing user from disabled → active.  
- Creating/jit‑provisioning users via SSO.

---

## 48.4. SSO Core Service

We implement a generic **SSO service** that:

- Locates a `SsoConnection` for a given org.  
- Builds redirect URLs.  
- Validates SAML/OIDC responses.  
- Maps identity → local user & membership.  
- Respects **seat limits** and plan SSO permissions.

### 48.4.1. Types & Entry Point

**File:** `apps/api-gateway/src/sso/types.ts`

```ts
// apps/api-gateway/src/sso/types.ts

export type SsoType = 'saml' | 'oidc';

export interface SsoProfile {
  email: string;
  name?: string;
  givenName?: string;
  familyName?: string;
  externalId?: string; // IdP user ID / subject
  groups?: string[];
}

export interface SsoConnectionConfig {
  id: string;
  orgId: string;
  type: SsoType;
  name: string;
  isEnabled: boolean;
  enableJitProvisioning: boolean;
  config: any;
}
```

**File:** `apps/api-gateway/src/sso/ssoService.ts`

```ts
// apps/api-gateway/src/sso/ssoService.ts

import { prisma } from '@ai-chat/db';
import { SsoProfile, SsoType } from './types';
import { getSeatLimitsForOrg, canAddSeat } from '../billing/seatService';

export async function getSsoConnection(orgId: string, connectionId?: string) {
  if (connectionId) {
    return prisma.ssoConnection.findFirst({ where: { id: connectionId, orgId, isEnabled: true } });
  }

  // Default: first enabled connection for the org
  return prisma.ssoConnection.findFirst({ where: { orgId, isEnabled: true } });
}

// Map IdP group/role claims to platform roles
export function mapGroupsToRoles(groups: string[] | undefined): string[] {
  if (!groups || groups.length === 0) return ['member'];

  const normalized = groups.map((g) => g.toLowerCase());

  if (normalized.some((g) => g.includes('admin') || g.includes('owner'))) {
    return ['org_admin'];
  }

  if (normalized.some((g) => g.includes('viewer') || g.includes('read'))) {
    return ['viewer'];
  }

  return ['member'];
}

export async function findOrProvisionUserFromSso(
  orgId: string,
  type: SsoType,
  connectionId: string | null,
  profile: SsoProfile
) {
  const limits = await getSeatLimitsForOrg(orgId);

  if (!limits.ssoAllowed) {
    throw new Error('SSO_NOT_ALLOWED_FOR_PLAN');
  }

  const existingUser = await prisma.user.findFirst({ where: { email: profile.email } });

  if (existingUser) {
    // Ensure membership exists
    const membership = await prisma.orgMembership.upsert({
      where: {
        orgId_userId: {
          orgId,
          userId: existingUser.id
        }
      },
      update: {
        isDisabled: false
      },
      create: {
        orgId,
        userId: existingUser.id,
        isDisabled: false,
        roles: mapGroupsToRoles(profile.groups)
      }
    });

    return { user: existingUser, membership };
  }

  // No existing user
  if (!limits.jitProvisioningAllowed) {
    throw new Error('JIT_PROVISIONING_NOT_ALLOWED');
  }

  const canSeat = await canAddSeat(orgId);
  if (!canSeat) {
    throw new Error('SEAT_LIMIT_EXCEEDED');
  }

  const user = await prisma.user.create({
    data: {
      email: profile.email,
      name: profile.name ?? profile.email.split('@')[0]
    }
  });

  const membership = await prisma.orgMembership.create({
    data: {
      orgId,
      userId: user.id,
      isDisabled: false,
      roles: mapGroupsToRoles(profile.groups)
    }
  });

  return { user, membership };
}

export async function recordSsoLoginAudit(params: {
  orgId: string;
  userId?: string;
  type: SsoType;
  connectionId?: string | null;
  email?: string;
  status: 'success' | 'failed';
  reason?: string;
  ip?: string;
  userAgent?: string;
  rawPayload?: any;
}) {
  await prisma.ssoLoginAudit.create({
    data: {
      orgId: params.orgId,
      userId: params.userId ?? null,
      type: params.type,
      connectionId: params.connectionId ?? null,
      email: params.email ?? null,
      status: params.status,
      reason: params.reason ?? null,
      ip: params.ip ?? null,
      userAgent: params.userAgent ?? null,
      rawPayload: params.rawPayload ?? null
    }
  });
}
```

> **Note:** `orgMembership` should be replaced with the actual membership model defined previously.

---

## 48.5. SAML & OIDC Handlers

We sketch separate modules for SAML and OIDC. In the real implementation, use battle‑tested libraries.

### 48.5.1. SAML Handler

**File:** `apps/api-gateway/src/sso/samlHandler.ts`

```ts
// apps/api-gateway/src/sso/samlHandler.ts

import { SsoProfile } from './types';

export async function buildSamlRedirectUrl(config: any, relayState: string): Promise<string> {
  // Use a SAML library to build AuthnRequest URL + RelayState.
  // Here we assume config contains IdP SSO URL and entityId.
  const idpSsoUrl = config.idpSsoUrl as string;
  const url = new URL(idpSsoUrl);
  url.searchParams.set('RelayState', relayState);
  return url.toString();
}

export async function parseSamlResponse(config: any, samlResponse: string): Promise<SsoProfile> {
  // Use real SAML parser & signature validation here.
  // For now, return a mocked structure to guide implementation.

  // Example decoded assertion mapping:
  return {
    email: 'john.doe@example.com',
    name: 'John Doe',
    givenName: 'John',
    familyName: 'Doe',
    externalId: 'idp-user-123',
    groups: ['member']
  };
}
```

### 48.5.2. OIDC Handler

**File:** `apps/api-gateway/src/sso/oidcHandler.ts`

```ts
// apps/api-gateway/src/sso/oidcHandler.ts

import { SsoProfile } from './types';

export async function buildOidcRedirectUrl(config: any, state: string, nonce: string): Promise<string> {
  const authUrl = new URL(config.authorizationEndpoint as string);
  authUrl.searchParams.set('client_id', config.clientId as string);
  authUrl.searchParams.set('response_type', 'code');
  authUrl.searchParams.set('scope', config.scope || 'openid email profile');
  authUrl.searchParams.set('redirect_uri', config.redirectUri as string);
  authUrl.searchParams.set('state', state);
  authUrl.searchParams.set('nonce', nonce);
  return authUrl.toString();
}

export async function exchangeCodeForTokens(config: any, code: string): Promise<any> {
  // POST to token endpoint, return token JSON (id_token, access_token, etc.)
  return {};
}

export async function extractProfileFromIdToken(config: any, tokens: any): Promise<SsoProfile> {
  // Verify ID token signature & audience, then extract claims.
  return {
    email: 'john.doe@example.com',
    name: 'John Doe',
    givenName: 'John',
    familyName: 'Doe',
    externalId: 'idp-user-123',
    groups: ['member']
  };
}
```

> Replace these mocks with actual SAML/OIDC libraries and mapping logic. The structure here simply shows expected responsibilities.

---

## 48.6. SSO Routes – Start & Callback

We expose **SP‑initiated SSO** endpoints under `/auth/sso`.

**File:** `apps/api-gateway/src/routes/sso.ts`

```ts
// apps/api-gateway/src/routes/sso.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { getSsoConnection, findOrProvisionUserFromSso, recordSsoLoginAudit } from '../sso/ssoService';
import { buildSamlRedirectUrl, parseSamlResponse } from '../sso/samlHandler';
import { buildOidcRedirectUrl, exchangeCodeForTokens, extractProfileFromIdToken } from '../sso/oidcHandler';
import { signJwtForUser } from '../auth/jwt';

export default async function ssoRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // SP-initiated SSO start: /auth/sso/:orgSlug/:connectionId?/start
  app.get('/auth/sso/:orgSlug/:connectionId/start', async (req, reply) => {
    const { orgSlug, connectionId } = req.params as any;

    const org = await prisma.org.findFirst({ where: { slug: orgSlug } });
    if (!org) {
      return reply.code(404).send({ error: 'ORG_NOT_FOUND' });
    }

    const conn = await getSsoConnection(org.id, connectionId);
    if (!conn) {
      return reply.code(404).send({ error: 'SSO_CONNECTION_NOT_FOUND' });
    }

    const relayState = JSON.stringify({ orgId: org.id, connectionId: conn.id });

    if (conn.type === 'saml') {
      const redirectUrl = await buildSamlRedirectUrl(conn.config, relayState);
      return reply.redirect(redirectUrl);
    }

    if (conn.type === 'oidc') {
      const state = Buffer.from(relayState).toString('base64url');
      const nonce = state; // a real impl must generate a random nonce
      const redirectUrl = await buildOidcRedirectUrl(conn.config, state, nonce);
      return reply.redirect(redirectUrl);
    }

    return reply.code(400).send({ error: 'UNSUPPORTED_SSO_TYPE' });
  });

  // SAML callback: ACS endpoint
  app.post('/auth/sso/saml/callback', async (req, reply) => {
    const { SAMLResponse, RelayState } = req.body as any;

    const relay = JSON.parse(RelayState || '{}');
    const orgId = relay.orgId as string;
    const connectionId = relay.connectionId as string;

    const conn = await prisma.ssoConnection.findFirst({ where: { id: connectionId, orgId } });
    if (!conn) {
      return reply.code(400).send('invalid_connection');
    }

    try {
      const profile = await parseSamlResponse(conn.config, SAMLResponse);

      const { user } = await findOrProvisionUserFromSso(orgId, 'saml', conn.id, profile);

      const token = await signJwtForUser(user, orgId);

      await recordSsoLoginAudit({
        orgId,
        userId: user.id,
        type: 'saml',
        connectionId: conn.id,
        email: profile.email,
        status: 'success',
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        rawPayload: null
      });

      // Frontend should provide a URL like APP_BASE_URL + '/auth/callback?token=...'
      const redirectUrl = `${process.env.APP_BASE_URL}/auth/sso/callback?token=${token}`;
      return reply.redirect(redirectUrl);
    } catch (err: any) {
      await recordSsoLoginAudit({
        orgId,
        type: 'saml',
        connectionId: conn.id,
        email: undefined,
        status: 'failed',
        reason: err?.message || 'unknown',
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        rawPayload: null
      });
      return reply.code(400).send('sso_failed');
    }
  });

  // OIDC callback
  app.get('/auth/sso/oidc/callback', async (req, reply) => {
    const { code, state } = req.query as any;

    const relayJson = Buffer.from(String(state || ''), 'base64url').toString('utf8');
    const relay = JSON.parse(relayJson || '{}');
    const orgId = relay.orgId as string;
    const connectionId = relay.connectionId as string;

    const conn = await prisma.ssoConnection.findFirst({ where: { id: connectionId, orgId } });
    if (!conn) {
      return reply.code(400).send('invalid_connection');
    }

    try {
      const tokens = await exchangeCodeForTokens(conn.config, String(code));
      const profile = await extractProfileFromIdToken(conn.config, tokens);

      const { user } = await findOrProvisionUserFromSso(orgId, 'oidc', conn.id, profile);

      const token = await signJwtForUser(user, orgId);

      await recordSsoLoginAudit({
        orgId,
        userId: user.id,
        type: 'oidc',
        connectionId: conn.id,
        email: profile.email,
        status: 'success',
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        rawPayload: null
      });

      const redirectUrl = `${process.env.APP_BASE_URL}/auth/sso/callback?token=${token}`;
      return reply.redirect(redirectUrl);
    } catch (err: any) {
      await recordSsoLoginAudit({
        orgId,
        type: 'oidc',
        connectionId: conn.id,
        email: undefined,
        status: 'failed',
        reason: err?.message || 'unknown',
        ip: req.ip,
        userAgent: req.headers['user-agent'],
        rawPayload: null
      });
      return reply.code(400).send('sso_failed');
    }
  });
}
```

Register in `main.ts`:

```ts
import ssoRoutes from './routes/sso';

await app.register(ssoRoutes);
```

---

## 48.7. Frontend – Login Page SSO Button

The login page must support **org‑aware SSO buttons**.

Assume we have a route structure like `/login/:orgSlug?`.

**File:** `apps/web/src/auth/LoginPage.tsx`

```tsx
import React from 'react';
import { Box, Button, Card, CardContent, TextField, Typography } from '@mui/material';
import LoginIcon from '@mui/icons-material/Login';
import LockIcon from '@mui/icons-material/Lock';
import { useParams } from 'react-router-dom';

export const LoginPage: React.FC = () => {
  const { orgSlug } = useParams();

  const handleSsoClick = () => {
    if (!orgSlug) return;
    // In real implementations, we might fetch available connections; here we assume default.
    const url = `${import.meta.env.VITE_API_BASE_URL}/auth/sso/${orgSlug}/default/start`;
    window.location.href = url;
  };

  const gradientBg =
    'radial-gradient(circle at top left, rgba(56,189,248,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(168,85,247,0.18), transparent 55%)';

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Card sx={{ borderRadius: 4, maxWidth: 420, width: '100%' }}>
        <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <Typography variant="h6">Sign in</Typography>
          <Typography variant="caption" color="text.secondary">
            Use your email & password or sign in with your organization SSO.
          </Typography>

          <Box display="flex" flexDirection="column" gap={1.5}>
            <TextField label="Email" type="email" fullWidth size="small" />
            <TextField label="Password" type="password" fullWidth size="small" />
            <Button variant="contained" fullWidth startIcon={<LoginIcon />}>
              Sign in
            </Button>
          </Box>

          {orgSlug && (
            <>
              <Box
                sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 1 }}
              >
                <Box sx={{ flex: 1, height: 1, bgcolor: 'divider' }} />
                <Typography variant="caption" color="text.secondary">
                  or
                </Typography>
                <Box sx={{ flex: 1, height: 1, bgcolor: 'divider' }} />
              </Box>
              <Button
                variant="outlined"
                fullWidth
                startIcon={<LockIcon />}
                onClick={handleSsoClick}
              >
                Continue with SSO
              </Button>
            </>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};
```

> The SSO button is visible only if `orgSlug` is known. A generic login (`/login`) can show a field to enter company domain, then redirect.

---

## 48.8. Org Admin – SSO Settings Page (Material 3)

Route: `/app/orgs/:orgId/settings/sso`

This page lets org admins configure SSO connections (high‑level fields; real implementation can add more).

**File:** `apps/web/src/org/OrgSsoSettingsPage.tsx`

```tsx
import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  Switch,
  TextField,
  Typography
} from '@mui/material';
import SecurityIcon from '@mui/icons-material/Security';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { apiRequest } from '../api/client';

interface SsoConnectionDto {
  id: string;
  orgId: string;
  type: 'saml' | 'oidc';
  name: string;
  isEnabled: boolean;
  enableJitProvisioning: boolean;
  config: Record<string, any>;
}

export const OrgSsoSettingsPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [connection, setConnection] = useState<SsoConnectionDto | null>(null);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);

  const load = async () => {
    if (!token || !orgId) return;
    setLoading(true);
    try {
      const res = await apiRequest<{ connections: SsoConnectionDto[] }>(
        `/orgs/${orgId}/sso-connections`,
        { method: 'GET' },
        token
      );
      setConnection(res.connections[0] ?? null);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [orgId, token]);

  const handleSave = async () => {
    if (!token || !orgId || !connection) return;
    setSaving(true);
    try {
      await apiRequest(
        `/orgs/${orgId}/sso-connections`,
        {
          method: 'PUT',
          body: JSON.stringify({
            id: connection.id,
            type: connection.type,
            name: connection.name,
            isEnabled: connection.isEnabled,
            enableJitProvisioning: connection.enableJitProvisioning,
            config: connection.config
          })
        },
        token
      );
      await load();
    } finally {
      setSaving(false);
    }
  };

  const gradientBg =
    'radial-gradient(circle at top left, rgba(239,68,68,0.16), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(59,130,246,0.16), transparent 55%)';

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box display="flex" alignItems="center" gap={1}>
        <SecurityIcon fontSize="small" />
        <Box>
          <Typography variant="h6">Single sign-on (SSO)</Typography>
          <Typography variant="caption" color="text.secondary">
            Connect your identity provider so your team can log in with SSO.
          </Typography>
        </Box>
      </Box>

      <Card sx={{ borderRadius: 3, maxWidth: 720 }}>
        <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <Box display="flex" gap={2} alignItems="center">
            <FormControl size="small" sx={{ minWidth: 160 }}>
              <InputLabel id="sso-type-label">Type</InputLabel>
              <Select
                labelId="sso-type-label"
                label="Type"
                value={connection?.type || 'saml'}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev
                      ? { ...prev, type: e.target.value as any }
                      : {
                          id: '',
                          orgId: orgId!,
                          type: e.target.value as any,
                          name: '',
                          isEnabled: false,
                          enableJitProvisioning: true,
                          config: {}
                        }
                  )
                }
              >
                <MenuItem value="saml">SAML 2.0</MenuItem>
                <MenuItem value="oidc">OIDC</MenuItem>
              </Select>
            </FormControl>
            <TextField
              label="Connection name"
              size="small"
              fullWidth
              value={connection?.name || ''}
              onChange={(e) =>
                setConnection((prev) =>
                  prev ? { ...prev, name: e.target.value } : null
                )
              }
            />
          </Box>

          <Box display="flex" gap={4}>
            <Box display="flex" alignItems="center" gap={1}>
              <Switch
                checked={connection?.isEnabled || false}
                onChange={(e) =>
                  setConnection((prev) => (prev ? { ...prev, isEnabled: e.target.checked } : prev))
                }
              />
              <Typography variant="body2">Enable SSO</Typography>
            </Box>
            <Box display="flex" alignItems="center" gap={1}>
              <Switch
                checked={connection?.enableJitProvisioning ?? true}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev ? { ...prev, enableJitProvisioning: e.target.checked } : prev
                  )
                }
              />
              <Typography variant="body2">Allow just-in-time user provisioning</Typography>
            </Box>
          </Box>

          {connection?.type === 'saml' && (
            <Box display="flex" flexDirection="column" gap={1.5}>
              <Typography variant="subtitle2">SAML configuration</Typography>
              <TextField
                label="IdP SSO URL"
                fullWidth
                size="small"
                value={connection.config.idpSsoUrl || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev ? { ...prev, config: { ...prev.config, idpSsoUrl: e.target.value } } : prev
                  )
                }
              />
              <TextField
                label="Entity ID"
                fullWidth
                size="small"
                value={connection.config.entityId || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev ? { ...prev, config: { ...prev.config, entityId: e.target.value } } : prev
                  )
                }
              />
              <TextField
                label="Certificate (PEM)"
                fullWidth
                size="small"
                multiline
                minRows={3}
                value={connection.config.certificate || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev
                      ? { ...prev, config: { ...prev.config, certificate: e.target.value } }
                      : prev
                  )
                }
              />
            </Box>
          )}

          {connection?.type === 'oidc' && (
            <Box display="flex" flexDirection="column" gap={1.5}>
              <Typography variant="subtitle2">OIDC configuration</Typography>
              <TextField
                label="Issuer URL"
                fullWidth
                size="small"
                value={connection.config.issuer || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev ? { ...prev, config: { ...prev.config, issuer: e.target.value } } : prev
                  )
                }
              />
              <TextField
                label="Client ID"
                fullWidth
                size="small"
                value={connection.config.clientId || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev ? { ...prev, config: { ...prev.config, clientId: e.target.value } } : prev
                  )
                }
              />
              <TextField
                label="Client secret"
                fullWidth
                size="small"
                value={connection.config.clientSecret || ''}
                onChange={(e) =>
                  setConnection((prev) =>
                    prev
                      ? { ...prev, config: { ...prev.config, clientSecret: e.target.value } }
                      : prev
                  )
                }
              />
            </Box>
          )}

          <Box display="flex" justifyContent="flex-end" mt={1.5}>
            <Button
              variant="contained"
              onClick={() => void handleSave()}
              disabled={saving || loading}
            >
              {saving ? 'Saving…' : 'Save SSO configuration'}
            </Button>
          </Box>
        </CardContent>
      </Card>
    </Box>
  );
};
```

Add routing entry:

```tsx
import { OrgSsoSettingsPage } from './org/OrgSsoSettingsPage';

<Route path="/app/orgs/:orgId/settings/sso" element={<OrgSsoSettingsPage />} />
```

### 48.8.1. Backend – SSO Connection Routes

**File:** `apps/api-gateway/src/routes/orgSsoConnections.ts`

```ts
// apps/api-gateway/src/routes/orgSsoConnections.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

export default async function orgSsoConnectionsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.get('/orgs/:orgId/sso-connections', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:read'
    );

    const connections = await prisma.ssoConnection.findMany({ where: { orgId } });
    return reply.send({ connections });
  });

  app.put('/orgs/:orgId/sso-connections', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;
    const body = req.body as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:write'
    );

    const { id, type, name, isEnabled, enableJitProvisioning, config } = body;

    const connection = await prisma.ssoConnection.upsert({
      where: { id: id || '___nonexistent___' },
      update: {
        type,
        name,
        isEnabled,
        enableJitProvisioning,
        config
      },
      create: {
        orgId,
        type,
        name,
        isEnabled,
        enableJitProvisioning,
        config
      }
    });

    return reply.send({ connection });
  });
}
```

Register in `main.ts`:

```ts
import orgSsoConnectionsRoutes from './routes/orgSsoConnections';

await app.register(orgSsoConnectionsRoutes);
```

---

## 48.9. Observability & Audit

- Use `SsoLoginAudit` for security analysis (suspicious login patterns).  
- Emit events (38.md):
  - `sso.login.success`, `sso.login.failed`.  
  - `sso.connection.updated`.  
  - `seat.limit.reached` when new user cannot be provisioned.
- Metrics (28.md):
  - `sso_logins_total{status,type}`.  
  - `sso_provisioned_users_total`.  
  - `seat_used_gauge{orgId}` (current used seats per org).  
  - `seat_limit_rejections_total{orgId}`.

This allows Grafana dashboards for SSO usage and seat utilization.

---

## 48.10. Sanity Checklist

Before offering SSO & seat‑based licenses to customers:

- [ ] Prisma migration applied for `SsoConnection` and `SsoLoginAudit`.  
- [ ] `BillingPlan.limits` includes `max_seats`, `sso_allowed`, `jit_provisioning_allowed` where relevant.  
- [ ] `seatService` uses the correct membership model and accurately counts active seats.  
- [ ] SSO flows (SAML & OIDC) work end‑to‑end in staging with at least one IdP (Okta/Azure AD).  
- [ ] Seat limits are enforced during invitations and JIT provisioning.  
- [ ] `OrgSsoSettingsPage` allows admins to configure SSO and toggle JIT provisioning.  
- [ ] Login page shows an SSO button when `orgSlug` is present and SSO is enabled.  
- [ ] SSO login events appear in `SsoLoginAudit` and metrics are exported to Prometheus.

If all items pass, the platform provides **enterprise‑ready SSO** and **seat‑based licensing** integrated with billing, analytics and RBAC – a key requirement for large customers.

---

_End of 48.md – Enterprise SSO (SAML/OIDC) & Seat‑Based Licensing_
