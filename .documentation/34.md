# 34. Knowledge Base UI – Uploads, Search & RAG Controls (Material 3)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human frontend engineers.  
> **Goal of this file:** Provide a **complete, production‑grade UI spec** for the Knowledge Base (KB) features introduced in 33.md so that:
>
> - Orgs can **manage knowledge spaces**, upload/ingest text, and monitor status.  
> - Users can **search the KB** and preview chunks/documents.  
> - Admins can configure per‑conversation **RAG settings** (enable/disable, space selection, max chunks).  
> - The UI is consistent with the rest of the app: **Material 3**, vivid gradients, subtle micro‑interactions, responsive layout.
>
> This file assumes:
>
> - Backend routes from 33.md exist (`/orgs/:orgId/knowledge/...`).  
> - Conversation model/settings already carry RAG configuration (33.7).  
> - The global shell / layout (sidebar, topbar) already exists.

---

## 34.1. High‑Level UX Overview

The Knowledge Base module has three main UI surfaces:

1. **Spaces & Documents Page** – Org KB home: manage spaces, see list of documents and ingestion status.  
2. **Search & Preview Panel** – Full‑screen or side‑panel search UI to quickly inspect chunks and documents.  
3. **Conversation RAG Settings** – A per‑conversation settings panel to toggle RAG and choose which space to use.

Navigation:

- From the org sidebar, a new item: **“Knowledge Base”** → `/app/orgs/:orgId/knowledge`.  
- From a conversation sidebar (chat UI), a **“Knowledge”** or **“RAG”** settings section.

---

## 34.2. Frontend API Layer

We add a thin API client layer for the KB endpoints.

### 34.2.1. Types & Functions

**File:** `apps/web/src/api/knowledge.ts`

```ts
// apps/web/src/api/knowledge.ts

import { apiRequest } from './client';

export interface KnowledgeSpace {
  id: string;
  orgId: string;
  name: string;
  slug: string;
  isDefault: boolean;
  createdAt: string;
}

export interface KnowledgeDocumentSummary {
  id: string;
  spaceId: string;
  orgId: string;
  title: string;
  sourceType: string;
  sourceUrl?: string | null;
  status: string;
  statusMessage?: string | null;
  createdAt: string;
}

export interface RetrievedChunk {
  chunkId: string;
  documentId: string;
  text: string;
  score: number;
}

export async function fetchKnowledgeSpaces(token: string, orgId: string): Promise<KnowledgeSpace[]> {
  const res = await apiRequest<{ spaces: KnowledgeSpace[] }>(
    `/orgs/${orgId}/knowledge/spaces`,
    { method: 'GET' },
    token
  );
  return res.spaces;
}

export async function createKnowledgeSpace(
  token: string,
  orgId: string,
  name: string
): Promise<{ id: string }> {
  return apiRequest<{ id: string }>(
    `/orgs/${orgId}/knowledge/spaces`,
    {
      method: 'POST',
      body: JSON.stringify({ name })
    },
    token
  );
}

export async function ingestTextDocument(
  token: string,
  orgId: string,
  spaceId: string,
  title: string,
  text: string
): Promise<{ documentId: string }> {
  return apiRequest<{ documentId: string }>(
    `/orgs/${orgId}/knowledge/documents:text`,
    {
      method: 'POST',
      body: JSON.stringify({ spaceId, title, text })
    },
    token
  );
}

export async function retrieveKnowledgeChunks(
  token: string,
  orgId: string,
  params: { spaceId?: string; query: string; limit?: number }
): Promise<RetrievedChunk[]> {
  const qs = new URLSearchParams();
  qs.set('query', params.query);
  if (params.spaceId) qs.set('spaceId', params.spaceId);
  if (params.limit && params.limit > 0) qs.set('limit', String(params.limit));

  const res = await apiRequest<{ chunks: RetrievedChunk[] }>(
    `/orgs/${orgId}/knowledge/retrieve?${qs.toString()}`,
    { method: 'GET' },
    token
  );

  return res.chunks;
}
```

If you later add document listing routes, extend this file with `fetchDocumentsForSpace` etc.

---

## 34.3. KB Hooks (React)

### 34.3.1. useKnowledgeSpaces

**File:** `apps/web/src/knowledge/useKnowledgeSpaces.ts`

```ts
// apps/web/src/knowledge/useKnowledgeSpaces.ts

import { useEffect, useState } from 'react';
import { useAuth } from '../auth/AuthContext';
import { KnowledgeSpace, fetchKnowledgeSpaces, createKnowledgeSpace } from '../api/knowledge';

export function useKnowledgeSpaces(orgId: string | null) {
  const { token } = useAuth();
  const [spaces, setSpaces] = useState<KnowledgeSpace[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!token || !orgId) return;

    let cancelled = false;

    async function load() {
      setLoading(true);
      setError(null);
      try {
        const data = await fetchKnowledgeSpaces(token, orgId);
        if (!cancelled) setSpaces(data);
      } catch (err) {
        if (!cancelled) setError((err as Error).message || 'Failed to load spaces');
      } finally {
        if (!cancelled) setLoading(false);
      }
    }

    void load();

    return () => {
      cancelled = true;
    };
  }, [token, orgId]);

  async function createSpace(name: string) {
    if (!token || !orgId) return;
    const res = await createKnowledgeSpace(token, orgId, name);
    // Reload spaces after creation
    const data = await fetchKnowledgeSpaces(token, orgId);
    setSpaces(data);
    return res.id;
  }

  return {
    spaces,
    loading,
    error,
    createSpace
  };
}
```

### 34.3.2. useKnowledgeSearch

**File:** `apps/web/src/knowledge/useKnowledgeSearch.ts`

```ts
// apps/web/src/knowledge/useKnowledgeSearch.ts

import { useState } from 'react';
import { useAuth } from '../auth/AuthContext';
import { RetrievedChunk, retrieveKnowledgeChunks } from '../api/knowledge';

export function useKnowledgeSearch(orgId: string | null) {
  const { token } = useAuth();
  const [query, setQuery] = useState('');
  const [spaceId, setSpaceId] = useState<string | undefined>(undefined);
  const [results, setResults] = useState<RetrievedChunk[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function search(limit = 8) {
    if (!token || !orgId || !query.trim()) return;

    setLoading(true);
    setError(null);
    try {
      const chunks = await retrieveKnowledgeChunks(token, orgId, {
        spaceId,
        query,
        limit
      });
      setResults(chunks);
    } catch (err) {
      setError((err as Error).message || 'Search failed');
    } finally {
      setLoading(false);
    }
  }

  return {
    query,
    setQuery,
    spaceId,
    setSpaceId,
    results,
    loading,
    error,
    search
  };
}
```

---

## 34.4. Knowledge Base Main Page

Route: `/app/orgs/:orgId/knowledge`

### 34.4.1. Component Shell

**File:** `apps/web/src/knowledge/KnowledgeBasePage.tsx`

```tsx
// apps/web/src/knowledge/KnowledgeBasePage.tsx

import React, { useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  MenuItem,
  Select,
  TextField,
  Typography
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import SearchIcon from '@mui/icons-material/Search';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { useParams } from 'react-router-dom';
import { useKnowledgeSpaces } from './useKnowledgeSpaces';
import { useKnowledgeSearch } from './useKnowledgeSearch';
import { ingestTextDocument } from '../api/knowledge';
import { useAuth } from '../auth/AuthContext';

export const KnowledgeBasePage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();
  const { spaces, loading: spacesLoading, error: spacesError, createSpace } = useKnowledgeSpaces(
    orgId || null
  );
  const search = useKnowledgeSearch(orgId || null);

  const [createSpaceOpen, setCreateSpaceOpen] = useState(false);
  const [newSpaceName, setNewSpaceName] = useState('');

  const [ingestDialogOpen, setIngestDialogOpen] = useState(false);
  const [ingestTitle, setIngestTitle] = useState('');
  const [ingestText, setIngestText] = useState('');
  const [ingestSpaceId, setIngestSpaceId] = useState<string | undefined>(undefined);
  const [ingesting, setIngesting] = useState(false);

  const handleCreateSpace = async () => {
    if (!newSpaceName.trim()) return;
    await createSpace(newSpaceName.trim());
    setNewSpaceName('');
    setCreateSpaceOpen(false);
  };

  const handleOpenIngestDialog = () => {
    if (spaces.length > 0 && !ingestSpaceId) {
      setIngestSpaceId(spaces[0].id);
    }
    setIngestDialogOpen(true);
  };

  const handleIngest = async () => {
    if (!token || !orgId) return;
    if (!ingestSpaceId || !ingestTitle.trim() || !ingestText.trim()) return;

    setIngesting(true);
    try {
      await ingestTextDocument(token, orgId, ingestSpaceId, ingestTitle.trim(), ingestText);
      setIngestDialogOpen(false);
      setIngestTitle('');
      setIngestText('');
    } catch (err) {
      // TODO: show toast/snackbar
      console.error(err);
    } finally {
      setIngesting(false);
    }
  };

  const gradientBg =
    'radial-gradient(circle at top left, rgba(56,189,248,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(139,92,246,0.22), transparent 55%)';

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        background: gradientBg
      }}
    >
      {/* Header */}
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1.2}>
          <AutoAwesomeIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Knowledge Base</Typography>
            <Typography variant="caption" color="text.secondary">
              Upload org content, search it, and power RAG‑enhanced conversations.
            </Typography>
          </Box>
        </Box>
        <Box display="flex" alignItems="center" gap={1}>
          <Button
            variant="outlined"
            size="small"
            startIcon={<AddIcon />}
            onClick={() => setCreateSpaceOpen(true)}
          >
            New space
          </Button>
          <Button
            variant="contained"
            size="small"
            startIcon={<CloudUploadIcon />}
            onClick={handleOpenIngestDialog}
          >
            Ingest text
          </Button>
        </Box>
      </Box>

      {/* Content */}
      <Box display="flex" flexDirection={{ xs: 'column', md: 'row' }} gap={2} flex={1}>
        {/* Left column: spaces & info */}
        <Box flex={{ xs: 0, md: 0.4 }} minWidth={280} display="flex" flexDirection="column" gap={1.5}>
          <Card sx={{ borderRadius: 3, flex: 1, minHeight: 160 }}>
            <CardContent>
              <Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
                <Typography variant="subtitle2">Spaces</Typography>
              </Box>
              {spacesLoading && (
                <Box display="flex" alignItems="center" justifyContent="center" py={2}>
                  <CircularProgress size={24} />
                </Box>
              )}
              {!spacesLoading && spacesError && (
                <Typography color="error" variant="body2">
                  {spacesError}
                </Typography>
              )}
              {!spacesLoading && !spacesError && spaces.length === 0 && (
                <Typography variant="body2" color="text.secondary">
                  No knowledge spaces yet. Create one to start ingesting documents.
                </Typography>
              )}
              {!spacesLoading && !spacesError && spaces.length > 0 && (
                <Box display="flex" flexDirection="column" gap={0.75} mt={1}>
                  {spaces.map((space) => (
                    <Box
                      key={space.id}
                      sx={{
                        px: 1,
                        py: 0.75,
                        borderRadius: 2,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        '&:hover': {
                          backgroundColor: 'action.hover'
                        },
                        transition: 'background-color 120ms ease-out'
                      }}
                    >
                      <Box>
                        <Typography variant="body2">{space.name}</Typography>
                        <Typography variant="caption" color="text.secondary">
                          {space.slug}
                        </Typography>
                      </Box>
                    </Box>
                  ))}
                </Box>
              )}
            </CardContent>
          </Card>
        </Box>

        {/* Right column: search & results */}
        <Box flex={{ xs: 1, md: 0.6 }} display="flex" flexDirection="column" gap={1.5}>
          <Card sx={{ borderRadius: 3, flex: 1, minHeight: 220, display: 'flex', flexDirection: 'column' }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1.5, flex: 1 }}>
              <Box display="flex" alignItems="center" gap={1.5}>
                <SearchIcon fontSize="small" />
                <Typography variant="subtitle2">Search knowledge</Typography>
              </Box>

              <Box display="flex" flexDirection={{ xs: 'column', sm: 'row' }} gap={1.5}>
                <TextField
                  size="small"
                  fullWidth
                  placeholder="Search across your org knowledge..."
                  value={search.query}
                  onChange={(e) => search.setQuery(e.target.value)}
                />
                <Select
                  size="small"
                  value={search.spaceId || ''}
                  onChange={(e) => search.setSpaceId(e.target.value || undefined)}
                  displayEmpty
                  sx={{ minWidth: 160 }}
                >
                  <MenuItem value="">
                    <em>All spaces</em>
                  </MenuItem>
                  {spaces.map((space) => (
                    <MenuItem key={space.id} value={space.id}>
                      {space.name}
                    </MenuItem>
                  ))}
                </Select>
                <Button
                  variant="contained"
                  size="small"
                  onClick={() => search.search(8)}
                  disabled={search.loading}
                >
                  {search.loading ? 'Searching…' : 'Search'}
                </Button>
              </Box>

              {search.error && (
                <Typography color="error" variant="body2">
                  {search.error}
                </Typography>
              )}

              <Box flex={1} mt={1} sx={{ overflow: 'auto' }}>
                {search.loading && (
                  <Box display="flex" alignItems="center" justifyContent="center" py={2}>
                    <CircularProgress size={24} />
                  </Box>
                )}

                {!search.loading && search.results.length === 0 && !search.error && (
                  <Typography variant="body2" color="text.secondary">
                    No results yet. Try running a search.
                  </Typography>
                )}

                {!search.loading && search.results.length > 0 && (
                  <Box display="flex" flexDirection="column" gap={1}>
                    {search.results.map((chunk) => (
                      <Card
                        key={chunk.chunkId}
                        variant="outlined"
                        sx={{
                          borderRadius: 2,
                          borderStyle: 'dashed',
                          '&:hover': {
                            borderColor: 'primary.main',
                            boxShadow: 3
                          },
                          transition: 'box-shadow 120ms ease-out, border-color 120ms ease-out'
                        }}
                      >
                        <CardContent>
                          <Box display="flex" justifyContent="space-between" alignItems="center" mb={0.5}>
                            <Typography variant="caption" color="text.secondary">
                              Score: {chunk.score.toFixed(3)}
                            </Typography>
                            <IconButton size="small">
                              {/* Placeholder for future actions (e.g. open full doc, pin, etc.) */}
                            </IconButton>
                          </Box>
                          <Typography
                            variant="body2"
                            sx={{ whiteSpace: 'pre-wrap', fontFamily: 'system-ui, -apple-system, BlinkMacSystemFont' }}
                          >
                            {chunk.text}
                          </Typography>
                        </CardContent>
                      </Card>
                    ))}
                  </Box>
                )}
              </Box>
            </CardContent>
          </Card>
        </Box>
      </Box>

      {/* Create space dialog */}
      <Dialog open={createSpaceOpen} onClose={() => setCreateSpaceOpen(false)} maxWidth="xs" fullWidth>
        <DialogTitle>Create knowledge space</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Name"
            fullWidth
            variant="outlined"
            value={newSpaceName}
            onChange={(e) => setNewSpaceName(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateSpaceOpen(false)}>Cancel</Button>
          <Button onClick={handleCreateSpace} variant="contained" disabled={!newSpaceName.trim()}>
            Create
          </Button>
        </DialogActions>
      </Dialog>

      {/* Ingest text dialog */}
      <Dialog
        open={ingestDialogOpen}
        onClose={() => (ingesting ? null : setIngestDialogOpen(false))}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Ingest text document</DialogTitle>
        <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
          <TextField
            label="Title"
            fullWidth
            value={ingestTitle}
            onChange={(e) => setIngestTitle(e.target.value)}
          />
          <Select
            fullWidth
            value={ingestSpaceId || ''}
            onChange={(e) => setIngestSpaceId(e.target.value || undefined)}
            displayEmpty
          >
            <MenuItem value="">
              <em>Select space</em>
            </MenuItem>
            {spaces.map((space) => (
              <MenuItem key={space.id} value={space.id}>
                {space.name}
              </MenuItem>
            ))}
          </Select>
          <TextField
            label="Text"
            fullWidth
            multiline
            minRows={6}
            value={ingestText}
            onChange={(e) => setIngestText(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setIngestDialogOpen(false)} disabled={ingesting}>
            Cancel
          </Button>
          <Button
            onClick={handleIngest}
            variant="contained"
            disabled={
              ingesting ||
              !ingestSpaceId ||
              !ingestTitle.trim() ||
              !ingestText.trim()
            }
          >
            {ingesting ? 'Ingesting…' : 'Ingest'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};
```

### 34.4.2. Route Wrapper

**File:** `apps/web/src/knowledge/KnowledgeBaseRouteWrapper.tsx`

```tsx
// apps/web/src/knowledge/KnowledgeBaseRouteWrapper.tsx

import React from 'react';
import { KnowledgeBasePage } from './KnowledgeBasePage';

export const KnowledgeBaseRouteWrapper: React.FC = () => {
  return <KnowledgeBasePage />;
};
```

In your main routes file (e.g. `AppRoutes.tsx`):

```tsx
import { KnowledgeBaseRouteWrapper } from './knowledge/KnowledgeBaseRouteWrapper';

// ... inside <Routes>
<Route path="/app/orgs/:orgId/knowledge" element={<KnowledgeBaseRouteWrapper />} />
```

---

## 34.5. Conversation RAG Settings UI

We now add a small panel in the conversation settings to control RAG behavior.

### 34.5.1. Conversation Settings Shape (Frontend)

Assume the conversation settings returned from the backend look like:

```ts
interface ConversationRagSettings {
  enabled: boolean;
  spaceId: string | null;
  maxChunks: number;
}

interface ConversationSettings {
  rag?: ConversationRagSettings;
  // other settings...
}
```

We expose an API to update these settings (you may already have a generic `updateConversationSettings`).

**File:** `apps/web/src/api/conversations.ts` (excerpt)

```ts
export async function updateConversationSettings(
  token: string,
  orgId: string,
  conversationId: string,
  settings: ConversationSettings
): Promise<void> {
  await apiRequest<void>(
    `/orgs/${orgId}/conversations/${conversationId}/settings`,
    {
      method: 'PATCH',
      body: JSON.stringify({ settings })
    },
    token
  );
}
```

### 34.5.2. RAG Settings Component

**File:** `apps/web/src/chat/ConversationRagSettings.tsx`

```tsx
// apps/web/src/chat/ConversationRagSettings.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  FormControlLabel,
  MenuItem,
  Select,
  Slider,
  Switch,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { useAuth } from '../auth/AuthContext';
import { useKnowledgeSpaces } from '../knowledge/useKnowledgeSpaces';
import { updateConversationSettings } from '../api/conversations';

interface ConversationRagSettings {
  enabled: boolean;
  spaceId: string | null;
  maxChunks: number;
}

interface ConversationRagSettingsProps {
  orgId: string;
  conversationId: string;
  value: ConversationRagSettings | undefined;
  onChange: (value: ConversationRagSettings) => void;
}

export const ConversationRagSettingsPanel: React.FC<ConversationRagSettingsProps> = ({
  orgId,
  conversationId,
  value,
  onChange
}) => {
  const { token } = useAuth();
  const { spaces } = useKnowledgeSpaces(orgId);

  const [local, setLocal] = useState<ConversationRagSettings>(() =>
    value ?? { enabled: false, spaceId: null, maxChunks: 4 }
  );

  useEffect(() => {
    if (value) {
      setLocal(value);
    }
  }, [value]);

  const handleSave = async (next: ConversationRagSettings) => {
    if (!token) return;
    setLocal(next);
    onChange(next);
    await updateConversationSettings(token, orgId, conversationId, {
      rag: next
    } as any);
  };

  const handleToggle = (_: React.ChangeEvent<HTMLInputElement>, checked: boolean) => {
    const next = { ...local, enabled: checked };
    void handleSave(next);
  };

  const handleSpaceChange = (spaceId: string | '') => {
    const next = { ...local, spaceId: spaceId || null };
    void handleSave(next);
  };

  const handleChunksChange = (_: Event, value: number | number[]) => {
    const maxChunks = Array.isArray(value) ? value[0] : value;
    const next = { ...local, maxChunks };
    void handleSave(next);
  };

  return (
    <Box display="flex" flexDirection="column" gap={1.5}>
      <Box display="flex" alignItems="center" gap={1}>
        <AutoAwesomeIcon fontSize="small" />
        <Typography variant="subtitle2">Knowledge‑augmented answers</Typography>
      </Box>

      <FormControlLabel
        control={<Switch checked={local.enabled} onChange={handleToggle} />}
        label="Use org knowledge base for this conversation"
      />

      {local.enabled && (
        <>
          <Box>
            <Typography variant="caption" color="text.secondary">
              Knowledge space
            </Typography>
            <Select
              size="small"
              fullWidth
              value={local.spaceId || ''}
              onChange={(e) => handleSpaceChange(e.target.value)}
              displayEmpty
            >
              <MenuItem value="">
                <em>All spaces</em>
              </MenuItem>
              {spaces.map((space) => (
                <MenuItem key={space.id} value={space.id}>
                  {space.name}
                </MenuItem>
              ))}
            </Select>
          </Box>

          <Box mt={1}>
            <Typography variant="caption" color="text.secondary">
              Max chunks per turn: {local.maxChunks}
            </Typography>
            <Slider
              size="small"
              value={local.maxChunks}
              min={1}
              max={12}
              step={1}
              valueLabelDisplay="auto"
              onChangeCommitted={handleChunksChange}
            />
          </Box>

          <Typography variant="caption" color="text.secondary">
            The model will receive the top matching chunks from the selected space(s) as additional context.
          </Typography>
        </>
      )}
    </Box>
  );
};
```

Integrate this panel into your conversation settings drawer/card, e.g. `ConversationSettingsPanel` component.

---

## 34.6. UX Details & Micro‑Interactions

- **Gradients & theming:** Use subtle radial gradients (as in other pages) and keep main surfaces on theme background. Do not overuse heavy shadows.  
- **Hover feedback:** Cards and rows in search results and spaces list have a hover elevation change (`boxShadow`, `borderColor`).  
- **Loading states:** All potentially slow actions (
  - loading spaces,  
  - running search,  
  - ingestion
  ) show spinners and disable buttons appropriately.
- **Empty states:** For spaces and search results, show friendly messages instead of blank surfaces.  
- **Error handling:** Display API errors as `Typography` or, ideally, snackbars (you can hook into your existing toast system).

Keyboard & accessibility:

- All interactive elements should be tabbable.  
- Dialogs should trap focus while open.  
- Provide accessible labels (Buttons already have icons + text; ensure icons alone have `aria-label` when needed).

---

## 34.7. Sanity Checklist

Before shipping the KB UI to users:

- [ ] Routes wired: `/app/orgs/:orgId/knowledge` is reachable from org sidebar.  
- [ ] Spaces load correctly and can be created.  
- [ ] Ingest dialog successfully calls `POST /knowledge/documents:text` and shows failures.  
- [ ] Search runs and shows retrieved chunks.  
- [ ] Conversation RAG settings panel updates settings and RAG actually affects model prompts (33.7).  
- [ ] UI behaves well on mobile (column stacking) and desktop (two‑column layout).

If all checks pass, your AI chat platform has a **fully functional, user‑friendly Knowledge Base UI**, completing the RAG feature from a product perspective.

---

_End of 34.md – Knowledge Base UI – Uploads, Search & RAG Controls (Material 3)_
