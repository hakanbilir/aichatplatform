# 13. Role & RBAC Model – Multi‑Tenant AI Chat Platform

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Define and implement a **Role‑Based Access Control (RBAC)** model for the AI chat platform:
>
> - Clear **role taxonomy** (SUPERADMIN, ORG_OWNER, ORG_ADMIN, ORG_MEMBER, ORG_VIEWER).  
> - DB representation via Prisma (`OrgMember.role`, `User.isSuperadmin`).  
> - Centralized RBAC helpers (`rbac/roles.ts`, `rbac/guards.ts`).  
> - Integration example on org routes (who can create/update/delete orgs, invite members, etc.).
>
> After following this file, the platform will have a solid, extensible RBAC foundation similar to other industry‑grade, multi‑tenant SaaS systems.

> **Important instructions to AI agents:**
> - Treat the code in this file as **canonical** when it conflicts with earlier drafts.  
> - When we say "create file X" or "replace file Y", do exactly that.  
> - Do **not** introduce TODOs or partially implemented functions.

---

## 13.1. RBAC Design Goals

We want an RBAC system that:

1. **Supports multi‑tenant organizations**  
   Users can belong to multiple orgs with different roles in each.

2. **Separates global ops from tenant ops**  
   - `SUPERADMIN` operates at the global platform level (all orgs, users, billing, monitoring).  
   - Org roles (`OWNER`, `ADMIN`, `MEMBER`, `VIEWER`) apply within a single organization.

3. **Is explicit and inspectable**  
   Permissions should be central, not scattered. It must be easy to answer:
   > "Who can do X on org Y or conversation Z?"

4. **Is easy to extend**  
   Adding a new permission (e.g., `analytics:view`) should be a single, obvious edit in a central file.


---

## 13.2. Role Taxonomy & Permission Matrix

### 13.2.1. Roles

We define two role layers:

1. **Global user flag**
   - `SUPERADMIN` – implied by `user.isSuperadmin === true`.

2. **Org membership role** (per organization):
   - `OWNER` – have full control over the org; one or more users per org.  
   - `ADMIN` – manage members, settings, and conversations; cannot delete org.  
   - `MEMBER` – can create and read conversations, use models, but not manage org membership.  
   - `VIEWER` – read‑only access to conversations and analytics.

### 13.2.2. Permission Matrix (Org Level)

We define the following permissions (scoped per org):

- `org:read` – view org profile & settings.  
- `org:update` – update org metadata (name, slug, settings).  
- `org:delete` – delete org.  
- `member:list` – list members.  
- `member:invite` – invite/add member.
- `member:update` – change member roles.  
- `member:remove` – remove member.
- `conversation:read` – list/get conversations in the org.  
- `conversation:write` – create/update/delete conversations in the org.  
- `conversation:chat` – send messages / stream completions.  
- `analytics:view` – view org‑level metrics and usage.

**Mapping roles → permissions**:

| Permission             | VIEWER | MEMBER | ADMIN | OWNER |
|------------------------|:------:|:------:|:-----:|:-----:|
| org:read               |   ✓    |   ✓    |   ✓   |   ✓   |
| org:update             |        |        |   ✓   |   ✓   |
| org:delete             |        |        |       |   ✓   |
| member:list            |        |        |   ✓   |   ✓   |
| member:invite          |        |        |   ✓   |   ✓   |
| member:update          |        |        |   ✓   |   ✓   |
| member:remove          |        |        |   ✓   |   ✓   |
| conversation:read      |   ✓    |   ✓    |   ✓   |   ✓   |
| conversation:write     |        |   ✓    |   ✓   |   ✓   |
| conversation:chat      |        |   ✓    |   ✓   |   ✓   |
| analytics:view         |   ✓    |   ✓    |   ✓   |   ✓   |

> **SUPERADMIN behavior:**  
> A `SUPERADMIN` **implicitly has all permissions on all orgs**, regardless of membership.

---

## 13.3. Prisma Schema – Users & Org Members

> **Note:** This section shows the target shape of the relevant Prisma models.  
> Merge these with your existing schema, keeping the field names identical.

### 13.3.1. `OrgRole` enum

Add to `packages/db/prisma/schema.prisma`:

```prisma
enum OrgRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}
```

### 13.3.2. `User` model – `isSuperadmin`

Ensure `User` has an `isSuperadmin` field:

```prisma
model User {
  id            String      @id @default(cuid())
  email         String      @unique
  passwordHash  String
  name          String?
  isSuperadmin  Boolean     @default(false)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  orgMemberships OrgMember[]
  conversations  Conversation[]
}
```

### 13.3.3. `OrgMember` model – role per org

```prisma
model OrgMember {
  id        String   @id @default(cuid())
  org       Org      @relation(fields: [orgId], references: [id])
  orgId     String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  role      OrgRole  @default(MEMBER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([orgId, userId])
}
```

### 13.3.4. `Org` model (excerpt)

```prisma
model Org {
  id        String      @id @default(cuid())
  name      String
  slug      String      @unique
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  members   OrgMember[]
}
```

After modifying the schema:

```bash
cd packages/db
pnpm prisma migrate dev --name add_rbac_roles
```

---

## 13.4. RBAC Core – Role & Permission Helpers

We centralize all RBAC logic in `apps/api-gateway/src/rbac`.

### 13.4.1. Create `apps/api-gateway/src/rbac/roles.ts`

```ts
// apps/api-gateway/src/rbac/roles.ts

export type OrgRole = 'OWNER' | 'ADMIN' | 'MEMBER' | 'VIEWER';

export type OrgPermission =
  | 'org:read'
  | 'org:update'
  | 'org:delete'
  | 'member:list'
  | 'member:invite'
  | 'member:update'
  | 'member:remove'
  | 'conversation:read'
  | 'conversation:write'
  | 'conversation:chat'
  | 'analytics:view';

export const ORG_ROLE_HIERARCHY: OrgRole[] = ['VIEWER', 'MEMBER', 'ADMIN', 'OWNER'];

export const ORG_ROLE_PERMISSIONS: Record<OrgRole, OrgPermission[]> = {
  VIEWER: ['org:read', 'conversation:read', 'analytics:view'],
  MEMBER: ['org:read', 'conversation:read', 'conversation:write', 'conversation:chat', 'analytics:view'],
  ADMIN: [
    'org:read',
    'org:update',
    'member:list',
    'member:invite',
    'member:update',
    'member:remove',
    'conversation:read',
    'conversation:write',
    'conversation:chat',
    'analytics:view'
  ],
  OWNER: [
    'org:read',
    'org:update',
    'org:delete',
    'member:list',
    'member:invite',
    'member:update',
    'member:remove',
    'conversation:read',
    'conversation:write',
    'conversation:chat',
    'analytics:view'
  ]
};

export function roleHasPermission(role: OrgRole, permission: OrgPermission): boolean {
  const perms = ORG_ROLE_PERMISSIONS[role] ?? [];
  return perms.includes(permission);
}
```

### 13.4.2. Create `apps/api-gateway/src/rbac/guards.ts`

```ts
// apps/api-gateway/src/rbac/guards.ts

import { prisma } from '@ai-chat/db';
import type { OrgPermission, OrgRole } from './roles';

interface UserLike {
  id: string;
  isSuperadmin: boolean;
}

export async function getUserOrgRole(userId: string, orgId: string): Promise<OrgRole | null> {
  const membership = await prisma.orgMember.findFirst({
    where: { userId, orgId },
    select: { role: true }
  });
  return membership?.role ?? null;
}

export async function userHasOrgPermission(
  user: UserLike,
  orgId: string,
  permission: OrgPermission
): Promise<boolean> {
  if (user.isSuperadmin) {
    return true;
  }

  const membership = await prisma.orgMember.findFirst({
    where: { userId: user.id, orgId },
    select: { role: true }
  });

  if (!membership) {
    return false;
  }

  const { role } = membership;

  // Lazy import to avoid circular deps if any
  const { roleHasPermission } = await import('./roles');
  return roleHasPermission(role as OrgRole, permission);
}

export async function assertOrgPermission(
  user: UserLike,
  orgId: string,
  permission: OrgPermission
): Promise<void> {
  const ok = await userHasOrgPermission(user, orgId, permission);
  if (!ok) {
    const error = new Error('Forbidden');
    (error as any).statusCode = 403;
    throw error;
  }
}
```

These helpers give us a single place to check permissions when implementing routes.

---

## 13.5. Org Routes with RBAC

We now update the org routes to use the RBAC helpers.

> **Important:** This replaces the previous `apps/api-gateway/src/routes/orgs.ts` implementation.

### 13.5.1. Replace `apps/api-gateway/src/routes/orgs.ts`

```ts
// apps/api-gateway/src/routes/orgs.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';
import { assertOrgPermission, getUserOrgRole } from '../rbac/guards';
import { OrgRole } from '../rbac/roles';

const createOrgBodySchema = z.object({
  name: z.string().min(1).max(200),
  slug: z.string().min(1).max(200).regex(/^[a-z0-9-]+$/)
});

const updateOrgBodySchema = z.object({
  name: z.string().min(1).max(200).optional(),
  slug: z.string().min(1).max(200).regex(/^[a-z0-9-]+$/).optional()
});

export default async function orgRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // List orgs the user belongs to
  app.get('/orgs', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      include: {
        org: true
      }
    });

    const orgs = memberships.map((m) => ({
      id: m.org.id,
      name: m.org.name,
      slug: m.org.slug,
      role: m.role
    }));

    return reply.send({ organizations: orgs });
  });

  // Create new org (any authenticated user can create an org; they become OWNER)
  app.post('/orgs', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parseBody = createOrgBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid org data', details: parseBody.error.format() });
    }

    const { name, slug } = parseBody.data;

    const org = await prisma.org.create({
      data: {
        name,
        slug,
        members: {
          create: {
            userId: payload.userId,
            role: 'OWNER'
          }
        }
      }
    });

    return reply.code(201).send({
      id: org.id,
      name: org.name,
      slug: org.slug
    });
  });

  // Get org details (must have org:read)
  app.get('/orgs/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }

    const orgId = parseParams.data.id;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:read'
    );

    const org = await prisma.org.findUnique({
      where: { id: orgId }
    });

    if (!org) {
      return reply.code(404).send({ error: 'Org not found' });
    }

    return reply.send({
      id: org.id,
      name: org.name,
      slug: org.slug,
      createdAt: org.createdAt,
      updatedAt: org.updatedAt
    });
  });

  // Update org metadata (must have org:update)
  app.patch('/orgs/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }

    const orgId = parseParams.data.id;

    const parseBody = updateOrgBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid org update', details: parseBody.error.format() });
    }

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:update'
    );

    const data: any = {};
    if (parseBody.data.name !== undefined) data.name = parseBody.data.name;
    if (parseBody.data.slug !== undefined) data.slug = parseBody.data.slug;

    const updated = await prisma.org.update({
      where: { id: orgId },
      data: {
        ...data,
        updatedAt: new Date()
      }
    });

    return reply.send({
      id: updated.id,
      name: updated.name,
      slug: updated.slug,
      createdAt: updated.createdAt,
      updatedAt: updated.updatedAt
    });
  });

  // Delete org (must be OWNER, or SUPERADMIN)
  app.delete('/orgs/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }

    const orgId = parseParams.data.id;

    if (!payload.isSuperadmin) {
      const role = await getUserOrgRole(payload.userId, orgId);
      if (role !== 'OWNER') {
        return reply.code(403).send({ error: 'Only OWNER or SUPERADMIN can delete org' });
      }
    }

    await prisma.org.delete({ where: { id: orgId } });

    return reply.code(204).send();
  });

  // List members (member:list)
  app.get('/orgs/:id/members', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }

    const orgId = parseParams.data.id;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'member:list'
    );

    const members = await prisma.orgMember.findMany({
      where: { orgId },
      include: {
        user: true
      }
    });

    return reply.send({
      members: members.map((m) => ({
        id: m.id,
        userId: m.userId,
        email: m.user.email,
        name: m.user.name,
        role: m.role
      }))
    });
  });

  // Invite/add member (member:invite)
  app.post('/orgs/:id/members', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }

    const orgId = parseParams.data.id;

    const bodySchema = z.object({
      userId: z.string().min(1),
      role: z.nativeEnum(OrgRole).default('MEMBER')
    });

    const parseBody = bodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid member data', details: parseBody.error.format() });
    }

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'member:invite'
    );

    const { userId, role } = parseBody.data;

    const membership = await prisma.orgMember.upsert({
      where: {
        orgId_userId: {
          orgId,
          userId
        }
      },
      update: {
        role
      },
      create: {
        orgId,
        userId,
        role
      }
    });

    return reply.code(201).send({
      id: membership.id,
      userId: membership.userId,
      role: membership.role
    });
  });

  // Update member role (member:update)
  app.patch('/orgs/:id/members/:memberId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({
      id: z.string().min(1),
      memberId: z.string().min(1)
    });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid params' });
    }

    const orgId = parseParams.data.id;
    const memberId = parseParams.data.memberId;

    const bodySchema = z.object({
      role: z.nativeEnum(OrgRole)
    });

    const parseBody = bodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid member update', details: parseBody.error.format() });
    }

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'member:update'
    );

    const updated = await prisma.orgMember.update({
      where: { id: memberId },
      data: {
        role: parseBody.data.role
      }
    });

    return reply.send({
      id: updated.id,
      userId: updated.userId,
      role: updated.role
    });
  });

  // Remove member (member:remove)
  app.delete('/orgs/:id/members/:memberId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({
      id: z.string().min(1),
      memberId: z.string().min(1)
    });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid params' });
    }

    const orgId = parseParams.data.id;
    const memberId = parseParams.data.memberId;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'member:remove'
    );

    await prisma.orgMember.delete({ where: { id: memberId } });

    return reply.code(204).send();
  });
}
```

This file enforces RBAC for:

- Reading and updating org profile.  
- Listing, inviting, updating, and removing members.  
- Deleting orgs (OWNER or SUPERADMIN only).

---

## 13.6. Frontend: Surfacing Org Role

The frontend already uses `/orgs` to list organizations and roles (see `auth.ts` + `OrgSwitcher`).  
With the updated `orgs` route, each org entry includes `role`, which can be used to:

- Show a badge (OWNER / ADMIN / MEMBER / VIEWER).  
- Conditionally enable UI elements (e.g., "Manage members" button only for ADMIN/OWNER).

A simple example (optional) in `OrgSwitcher.tsx` would be to display the role next to the name.

---

## 13.7. Sanity Checks

From the repo root:

1. **Run migrations (if schema changed):**

   ```bash
   cd packages/db
   pnpm prisma migrate dev --name add_rbac_roles
   ```

2. **Install deps (if needed):**

   ```bash
   pnpm install
   ```

3. **Start API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

4. **Test RBAC flows:**

   - Create a new user (A) and log in.  
   - `POST /orgs` – user A becomes `OWNER`.  
   - Add user B as `MEMBER` via `POST /orgs/:id/members`.  
   - Verify user B **cannot** call `PATCH /orgs/:id` (should get `403`).  
   - Promote user B to `ADMIN` via `PATCH /orgs/:id/members/:memberId`.  
   - Verify user B **can** now update the org and invite new members.

If these flows work, your platform now has a robust, extensible RBAC layer.

---

## 13.8. Next Steps

Future markdown files can extend RBAC by:

- Attaching **org ownership to conversations** (org‑scoped chats vs personal chats).  
- Implementing **API keys** with per‑org roles and rate limits.  
- Adding **feature flags** (e.g., some models or tools only available to specific roles).

> **AI Agent Instruction:**  
> Before moving on, ensure `orgs.ts` compiles cleanly and that RBAC checks work in practice using HTTP calls or the existing web UI.

---

_End of 13.md – Role & RBAC Model – Multi‑Tenant AI Chat Platform_
