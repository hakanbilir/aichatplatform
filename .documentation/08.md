# 8. Auth & Organization API (JWT + RBAC)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Implement **authentication, basic RBAC, and organization management APIs** inside `apps/api-gateway` so that:
>
> - Users can **sign up**, **log in**, and **retrieve their profile**.  
> - Users can **create organizations** and be assigned roles (OWNER/ADMIN/MEMBER).  
> - Every authenticated request has a clear, typed **JWT payload** with `userId` and `orgId`.  
> - Fastify has a reusable `authenticate` hook for protected routes.
>
> After following this file, the backend will have a **fully functional auth + org foundation**, ready to be used by the chat and admin UIs.

> **Important instructions to AI agents:**
> - Do **not** store raw passwords. Always hash them with bcrypt.  
> - Do **not** expose `passwordHash` or `keyHash` fields in API responses.  
> - Use the Prisma models defined in 5.md (`User`, `Organization`, `OrgMember`).  
> - Keep auth logic in `apps/api-gateway/src/auth` and `apps/api-gateway/src/routes` as defined here.

---

## 8.1. High-Level Auth & RBAC Design

### 8.1.1. Identity & Auth

- Identity is based on the **`User`** model (email + passwordHash).  
- Authentication uses **JWT** (signed with `JWT_SECRET` from config).  
- The JWT payload includes:
  - `userId` – mandatory.  
  - `orgId` – the currently active organization context (can be `null`).

### 8.1.2. Organizations & Roles

- Each user can belong to multiple **`Organization`** records via **`OrgMember`**.  
- `OrgMember.role` is one of `OWNER | ADMIN | MEMBER` (see Prisma enum `OrgRole`).  
- For now, we implement minimal RBAC:
  - Only **OWNER** and **ADMIN** can create new members in an organization.  
  - Later files can refine this to more granular permissions.

### 8.1.3. Core Endpoints (This File)

- `POST /auth/signup` – create user + default org + membership + JWT.  
- `POST /auth/login` – login with email/password, return JWT + profile.  
- `GET /auth/me` – get current user + memberships + active org.  
- `GET /orgs` – list organizations the user belongs to.  
- `POST /orgs` – create a new organization and set user as OWNER.

> **Note:** We will add more org/member management endpoints (invites, role changes) later. This file provides a solid functional base.

---

## 8.2. Update `apps/api-gateway/package.json`

We add dependencies for JWT, password hashing, Zod validation, and database access.

> **AI Agent Note:** Replace the entire `apps/api-gateway/package.json` with the content below.

```json
{
  "name": "api-gateway",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "ts-node --project tsconfig.json src/main.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/main.js",
    "lint": "eslint src --ext .ts",
    "test": "echo \"no tests yet\"",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "@ai-chat/config": "0.1.0",
    "@ai-chat/db": "0.1.0",
    "@ai-chat/core-types": "0.1.0",
    "@fastify/jwt": "^9.0.0",
    "bcryptjs": "^2.4.3",
    "fastify": "^5.0.0",
    "fastify-cors": "^9.0.0",
    "zod": "^3.23.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.2",
    "@types/node": "^22.0.0"
  }
}
```

> **AI Agent Note:**  
> Run `pnpm install` after modifying this file to ensure new dependencies are installed.

---

## 8.3. Adjust `apps/api-gateway/tsconfig.json`

We add support for a `types/` directory containing Fastify augmentations.

Replace `apps/api-gateway/tsconfig.json` with:

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist"
  },
  "include": ["src", "types"]
}
```

---

## 8.4. Define JWT Payload & Fastify Types

We define a shared JWT payload shape and augment Fastify’s typings.

### 8.4.1. Create `apps/api-gateway/src/auth/types.ts`

Create the directory if it does not exist:

```bash
mkdir -p apps/api-gateway/src/auth
```

Create `apps/api-gateway/src/auth/types.ts` with:

```ts
export interface JwtPayload {
  userId: string;
  orgId: string | null;
}
```

### 8.4.2. Fastify Type Augmentation – `types/fastify.d.ts`

Create directory:

```bash
mkdir -p apps/api-gateway/types
```

Create `apps/api-gateway/types/fastify.d.ts` with:

```ts
import '@fastify/jwt';
import { JwtPayload } from '../src/auth/types';

declare module '@fastify/jwt' {
  interface FastifyJWT {
    payload: JwtPayload; // payload used when signing
    user: JwtPayload; // payload decoded from token
  }
}

declare module 'fastify' {
  interface FastifyInstance {
    authenticate: import('fastify').preHandlerHookHandler;
  }
}
```

> **AI Agent Note:**  
> TypeScript will pick this up via the `include: ["src", "types"]` setting in `tsconfig.json`.

---

## 8.5. Password Hashing Helpers

We use `bcryptjs` to hash and verify passwords.

### 8.5.1. Create `apps/api-gateway/src/auth/password.ts`

Create `apps/api-gateway/src/auth/password.ts` with:

```ts
import bcrypt from 'bcryptjs';
import { getConfig } from '@ai-chat/config';

const config = getConfig();

export async function hashPassword(plain: string): Promise<string> {
  const rounds = config.BCRYPT_SALT_ROUNDS;
  const salt = await bcrypt.genSalt(rounds);
  return bcrypt.hash(plain, salt);
}

export async function verifyPassword(plain: string, hash: string): Promise<boolean> {
  return bcrypt.compare(plain, hash);
}
```

---

## 8.6. Auth Plugin (JWT + `authenticate` Hook)

We create a Fastify plugin that:

- Registers `@fastify/jwt` with `JWT_SECRET` and `JWT_EXPIRES_IN`.  
- Adds an `authenticate` hook for protected routes.

### 8.6.1. Create `apps/api-gateway/src/plugins/auth.ts`

Create directory if needed:

```bash
mkdir -p apps/api-gateway/src/plugins
```

Create `apps/api-gateway/src/plugins/auth.ts` with:

```ts
import fp from 'fastify-plugin';
import fastifyJwt from '@fastify/jwt';
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { getConfig } from '@ai-chat/config';

const config = getConfig();

async function authPlugin(app: FastifyInstance) {
  // Register JWT plugin
  await app.register(fastifyJwt, {
    secret: config.JWT_SECRET,
    sign: {
      expiresIn: config.JWT_EXPIRES_IN
    }
  });

  // Decorate a reusable authenticate hook
  app.decorate(
    'authenticate',
    async (request: FastifyRequest, reply: FastifyReply): Promise<void> => {
      try {
        await request.jwtVerify();
      } catch (err) {
        reply.code(401).send({ error: 'Unauthorized' });
      }
    }
  );
}

export default fp(authPlugin);
```

> **AI Agent Note:**  
> We use `fastify-plugin` (fp) pattern so this plugin can be registered cleanly in `main.ts`. If `fastify-plugin` is not yet installed, we will add it in the next section.

### 8.6.2. Add `fastify-plugin` Dependency

Update `apps/api-gateway/package.json` dependencies to include `fastify-plugin`:

```jsonc
{
  "dependencies": {
    // ...existing deps...
    "fastify-plugin": "^5.0.0"
  }
}
```

> **AI Agent Note:**  
> Ensure `fastify-plugin` is added (merge carefully). Run `pnpm install` afterwards.

---

## 8.7. Auth Routes – Signup, Login, Me

We now implement the `/auth` routes.

### 8.7.1. Create `apps/api-gateway/src/routes/auth.ts`

Create `apps/api-gateway/src/routes/auth.ts` with:

```ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { hashPassword, verifyPassword } from '../auth/password';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';

const signupBodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1),
  orgName: z.string().min(1).optional()
});

const loginBodySchema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

export default async function authRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  app.post('/auth/signup', async (request, reply) => {
    const parseResult = signupBodySchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.code(400).send({ error: 'Invalid signup data', details: parseResult.error.format() });
    }

    const { email, password, name, orgName } = parseResult.data;

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      return reply.code(409).send({ error: 'User with this email already exists' });
    }

    const passwordHash = await hashPassword(password);

    const orgDisplayName = orgName ?? `${name}'s Workspace`;
    const orgSlugBase = orgDisplayName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

    // Ensure org slug uniqueness by appending a suffix if necessary
    let slug = orgSlugBase || 'workspace';
    let suffix = 1;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const existingOrg = await prisma.organization.findUnique({ where: { slug } });
      if (!existingOrg) break;
      slug = `${orgSlugBase}-${suffix++}`;
    }

    const user = await prisma.user.create({
      data: {
        email,
        name,
        passwordHash,
        orgMemberships: {
          create: {
            role: 'OWNER',
            org: {
              create: {
                name: orgDisplayName,
                slug
              }
            }
          }
        }
      },
      include: {
        orgMemberships: {
          include: {
            org: true
          }
        }
      }
    });

    const primaryMembership = user.orgMemberships[0];
    const activeOrg = primaryMembership?.org ?? null;

    const payload: JwtPayload = {
      userId: user.id,
      orgId: activeOrg?.id ?? null
    };

    const token = app.jwt.sign(payload);

    return reply.send({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        isSuperadmin: user.isSuperadmin
      },
      activeOrg: activeOrg
        ? {
            id: activeOrg.id,
            name: activeOrg.name,
            slug: activeOrg.slug
          }
        : null
    });
  });

  app.post('/auth/login', async (request, reply) => {
    const parseResult = loginBodySchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.code(400).send({ error: 'Invalid login data', details: parseResult.error.format() });
    }

    const { email, password } = parseResult.data;

    const user = await prisma.user.findUnique({
      where: { email },
      include: {
        orgMemberships: {
          include: {
            org: true
          }
        }
      }
    });

    if (!user) {
      return reply.code(401).send({ error: 'Invalid email or password' });
    }

    const valid = await verifyPassword(password, user.passwordHash);
    if (!valid) {
      return reply.code(401).send({ error: 'Invalid email or password' });
    }

    const primaryMembership = user.orgMemberships[0] ?? null;
    const activeOrg = primaryMembership?.org ?? null;

    const payload: JwtPayload = {
      userId: user.id,
      orgId: activeOrg?.id ?? null
    };

    const token = app.jwt.sign(payload);

    return reply.send({
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        isSuperadmin: user.isSuperadmin
      },
      activeOrg: activeOrg
        ? {
            id: activeOrg.id,
            name: activeOrg.name,
            slug: activeOrg.slug
          }
        : null,
      organizations: user.orgMemberships.map((m) => ({
        id: m.org.id,
        name: m.org.name,
        slug: m.org.slug,
        role: m.role
      }))
    });
  });

  app.get('/auth/me', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
      include: {
        orgMemberships: {
          include: {
            org: true
          }
        }
      }
    });

    if (!user) {
      return reply.code(401).send({ error: 'User not found' });
    }

    const activeOrg = user.orgMemberships.find((m) => m.orgId === payload.orgId)?.org ?? null;

    return reply.send({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        isSuperadmin: user.isSuperadmin
      },
      activeOrg: activeOrg
        ? {
            id: activeOrg.id,
            name: activeOrg.name,
            slug: activeOrg.slug
          }
        : null,
      organizations: user.orgMemberships.map((m) => ({
        id: m.org.id,
        name: m.org.name,
        slug: m.org.slug,
        role: m.role
      }))
    });
  });
}
```

> **Security Note:**  
> Responses **never** include `passwordHash`. Only safe, public fields are returned.

---

## 8.8. Organization Routes – List & Create

We provide basic org management for the authenticated user.

### 8.8.1. Create `apps/api-gateway/src/routes/orgs.ts`

Create `apps/api-gateway/src/routes/orgs.ts` with:

```ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';

const createOrgBodySchema = z.object({
  name: z.string().min(1)
});

export default async function orgRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  app.get('/orgs', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const memberships = await prisma.orgMember.findMany({
      where: { userId: payload.userId },
      include: {
        org: true
      }
    });

    return reply.send({
      organizations: memberships.map((m) => ({
        id: m.org.id,
        name: m.org.name,
        slug: m.org.slug,
        role: m.role
      }))
    });
  });

  app.post('/orgs', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parseResult = createOrgBodySchema.safeParse(request.body);
    if (!parseResult.success) {
      return reply.code(400).send({ error: 'Invalid org data', details: parseResult.error.format() });
    }

    const { name } = parseResult.data;

    const orgSlugBase = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

    let slug = orgSlugBase || 'workspace';
    let suffix = 1;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const existingOrg = await prisma.organization.findUnique({ where: { slug } });
      if (!existingOrg) break;
      slug = `${orgSlugBase}-${suffix++}`;
    }

    const org = await prisma.organization.create({
      data: {
        name,
        slug,
        members: {
          create: {
            userId: payload.userId,
            role: 'OWNER'
          }
        }
      }
    });

    return reply.code(201).send({
      id: org.id,
      name: org.name,
      slug: org.slug
    });
  });
}
```

> **AI Agent Note:**  
> More advanced org endpoints (switch active org, invite users, change roles) will be added in future docs.

---

## 8.9. Wire Everything in `src/main.ts`

We now update `apps/api-gateway/src/main.ts` to:

- Use config’s `LOG_LEVEL`, `API_HOST`, `API_PORT`.  
- Ensure DB extensions (pgvector) are present.  
- Register the auth plugin and routes.

> **AI Agent Note:** Replace the entire `apps/api-gateway/src/main.ts` file with the content below.

```ts
import fastify from 'fastify';
import cors from 'fastify-cors';
import { getConfig } from '@ai-chat/config';
import { ensureDbExtensions, checkDbConnection } from '@ai-chat/db';
import authPlugin from './plugins/auth';
import authRoutes from './routes/auth';
import orgRoutes from './routes/orgs';

async function buildServer() {
  const config = getConfig();

  const app = fastify({
    logger: {
      level: config.LOG_LEVEL
    }
  });

  await app.register(cors, {
    origin: true,
    credentials: true
  });

  // Health check route (no auth)
  app.get('/health', async () => {
    const dbOk = await checkDbConnection();
    return {
      status: 'ok',
      env: config.NODE_ENV,
      db: dbOk ? 'up' : 'down',
      defaultModel: config.DEFAULT_MODEL
    };
  });

  // Auth plugin (JWT + authenticate hook)
  await app.register(authPlugin);

  // Routes
  await app.register(authRoutes);
  await app.register(orgRoutes);

  // Ensure DB extensions
  await ensureDbExtensions();

  return app;
}

async function start() {
  const config = getConfig();
  const port = config.API_PORT;
  const host = config.API_HOST;

  const app = await buildServer();

  app
    .listen({ port, host })
    .then(() => {
      app.log.info(`API Gateway listening on http://${host}:${port}`);
    })
    .catch((err) => {
      app.log.error(err, 'Failed to start API Gateway');
      process.exit(1);
    });
}

start();
```

> **Result:**  
> The API gateway now exposes `/health`, `/auth/*`, and `/orgs` endpoints, fully wired to DB, JWT, and config.

---

## 8.10. Sanity Checks

Run the following from the repo root after completing this file:

1. **Install dependencies (if not done yet):**

   ```bash
   pnpm install
   ```

2. **Ensure DB schema & client are ready (if not done previously):**

   ```bash
   pnpm db:migrate:dev -- --name init
   pnpm db:generate
   ```

3. **Build the monorepo:**

   ```bash
   pnpm build
   ```

4. **Start the API gateway:**

   ```bash
   pnpm dev:api
   ```

5. **Test endpoints (example with `curl`):**

   - Health:

     ```bash
     curl http://localhost:4000/health
     ```

   - Signup:

     ```bash
     curl -X POST http://localhost:4000/auth/signup \
       -H "Content-Type: application/json" \
       -d '{"email":"test@example.com","password":"Password123!","name":"Test User"}'
     ```

   - Login:

     ```bash
     curl -X POST http://localhost:4000/auth/login \
       -H "Content-Type: application/json" \
       -d '{"email":"test@example.com","password":"Password123!"}'
     ```

   - Me (replace `TOKEN` with the JWT from signup/login):

     ```bash
     curl http://localhost:4000/auth/me \
       -H "Authorization: Bearer TOKEN"
     ```

   - List orgs:

     ```bash
     curl http://localhost:4000/orgs \
       -H "Authorization: Bearer TOKEN"
     ```

   - Create org:

     ```bash
     curl -X POST http://localhost:4000/orgs \
       -H "Authorization: Bearer TOKEN" \
       -H "Content-Type: application/json" \
       -d '{"name":"Second Workspace"}'
     ```

If all requests behave as described (proper JSON responses, errors for invalid data, 401 for missing/invalid JWT), the auth & org layer is functioning correctly.

---

## 8.11. Next Steps

With authentication and basic RBAC in place:

- The frontend can:
  - Sign users up and log them in.  
  - Show current user and org list.  
  - Let users create additional organizations.
- The backend has a consistent way to:
  - Access `request.user` with typed `JwtPayload`.  
  - Protect routes via `preHandler: [app.authenticate]`.

Upcoming markdown files will:

- Implement **chat & conversation APIs** using `@ai-chat/chat-orchestrator` and `@ai-chat/db`.  
- Expose **streaming chat endpoints** (SSE) to the frontend.  
- Extend RBAC to control access to advanced features (tools, analytics, admin screens).

> **AI Agent Instruction:**  
> Before moving on, ensure `pnpm build` passes and that all auth/org endpoints work via manual tests or automated integration tests.

---

_End of 8.md – Auth & Organization API (JWT + RBAC)_
