# 42. Prompt Studio, Prompt Templates & Chat Profiles – Backend + Material 3 UI

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Provide an **enterprise‑grade Prompt Studio** so that:
>
> - Each org can define **reusable prompt templates** (system / pre / post prompts).  
> - Admins can create **Chat Profiles** ("Personas", like custom GPTs) that bundle model, tools, safety level and prompts.  
> - Conversations can be started **from a profile** so the entire chat behaves according to that configuration.  
> - Everything is versioned, auditable (38.md), observable (28.md), multi‑tenant and RBAC‑aware.
>
> This file is written so Cursor‑like agents can implement it end‑to‑end without further questions.

This spec builds on:

- 11–14.md – Users, orgs, roles & RBAC.  
- 19.md – Quotas & usage/limits (per profile).  
- 25.md – Conversation & message pipeline.  
- 33–37.md – RAG, tools & function calling.  
- 38.md – Events & audit log.  
- 40.md – Org Admin Console.  
- 41.md – Safety & moderation.

---

## 42.1. Concepts & Scope

We introduce three core concepts:

1. **Prompt Template**  
   - Reusable building block that can be attached to Chat Profiles or flows.  
   - Contains structured fields:
     - `systemPrompt` – system‑level instruction.  
     - `userPrefix` – prefix prepended to each user message (optional).  
     - `assistantStyle` – style hints for the assistant (tone, format).  
     - `variables` – named variables like `{{user_name}}`, `{{org_name}}`, `{{today}}` etc.  
   - Versioned with `PromptTemplateVersion`.

2. **Chat Profile**  
   - Equivalent to a "custom GPT" / persona / workspace preset.  
   - Defines:
     - Which **model** and **provider** to use (Ollama, OpenAI, etc.).  
     - Prompt template(s) to apply.  
     - Default sampling params (temperature, maxTokens, topP).  
     - Enabled tools / RAG / safety level.  
   - Can be **org‑private** or **org‑shared** (available to all members).

3. **Prompt Studio UI**  
   - Org admins & power users can:
     - Create/edit templates and preview prompt rendering.  
     - Build Chat Profiles with click‑configuration.  
     - Assign default profile(s) per org or per workspace.

All of this must be:

- Multi‑tenant (`orgId` scoped).  
- Auditable (events for template/profile changes).  
- Integrated into the **chat pipeline** so conversations created from a profile inherit the configuration.

---

## 42.2. Data Model – Prisma

Extend `packages/db/prisma/schema.prisma` with Prompt Studio models.

```prisma
model PromptTemplate {
  id        String   @id @default(cuid())
  orgId     String

  // Human-readable name, unique per org
  name      String

  description String?

  // Whether template is archived (hidden from UI)
  isArchived Boolean  @default(false)

  createdById String

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  org     Org   @relation(fields: [orgId], references: [id])
  creator User  @relation(fields: [createdById], references: [id])

  versions PromptTemplateVersion[]

  @@unique([orgId, name])
}

model PromptTemplateVersion {
  id        String   @id @default(cuid())
  templateId String

  // Simple increasing version for ordering
  version   Int

  // Main prompt fields
  systemPrompt    String
  userPrefix      String?
  assistantStyle  String?

  // JSON object with variable metadata (name, description, default)
  variables       Json

  // free-form JSON for advanced engines
  metadata        Json?

  createdAt DateTime @default(now())
  createdById String

  template PromptTemplate @relation(fields: [templateId], references: [id])
  creator  User           @relation(fields: [createdById], references: [id])

  @@unique([templateId, version])
}

model ChatProfile {
  id        String   @id @default(cuid())
  orgId     String

  name      String
  slug      String   @unique

  description String?

  // Whether org members can see/use this profile
  isShared  Boolean  @default(true)

  // If true, recommended as default when starting conversations
  isDefault Boolean  @default(false)

  // Model selection
  modelProvider String  // e.g. "ollama", "openai"
  modelName     String  // e.g. "llama3", "gpt-4.1"

  temperature   Float    @default(0.7)
  topP          Float    @default(1.0)
  maxTokens     Int?     // null = provider default

  // References latest template versions used
  systemTemplateId String?
  systemTemplateVersion Int?

  // Additional flags/controls
  enableTools   Boolean  @default(true)
  enableRag     Boolean  @default(false)
  safetyLevel   String   @default("standard") // e.g. "relaxed" | "standard" | "strict"

  // Optional JSON for provider-specific tuning
  providerConfig Json?

  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org     Org   @relation(fields: [orgId], references: [id])
  creator User  @relation(fields: [createdById], references: [id])

  @@index([orgId, isDefault])
}

// Optionally track which profile a conversation is bound to
model Conversation {
  id        String   @id @default(cuid())
  orgId     String

  // ...existing fields...

  chatProfileId String?
  chatProfile   ChatProfile? @relation(fields: [chatProfileId], references: [id])
}
```

> Note: `Conversation` modification is additive; keep all existing fields as defined in 25.md.

Run a Prisma migration after editing the schema.

---

## 42.3. Backend – Prompt Template CRUD

### 42.3.1. DTOs

**File:** `apps/api-gateway/src/promptStudio/types.ts`

```ts
// apps/api-gateway/src/promptStudio/types.ts

export interface PromptTemplateVersionDto {
  id: string;
  version: number;
  systemPrompt: string;
  userPrefix: string | null;
  assistantStyle: string | null;
  variables: Record<string, { description?: string; required?: boolean; defaultValue?: string }>;
  createdAt: string;
  createdByDisplayName: string | null;
}

export interface PromptTemplateDto {
  id: string;
  orgId: string;
  name: string;
  description: string | null;
  isArchived: boolean;
  createdAt: string;
  latestVersion: PromptTemplateVersionDto | null;
}
```

### 42.3.2. Routes – List & Create Templates

**File:** `apps/api-gateway/src/routes/promptTemplates.ts`

```ts
// apps/api-gateway/src/routes/promptTemplates.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

const createTemplateSchema = z.object({
  name: z.string().min(1).max(128),
  description: z.string().max(512).optional(),
  systemPrompt: z.string().min(1),
  userPrefix: z.string().optional(),
  assistantStyle: z.string().optional(),
  variables: z
    .record(
      z.object({
        description: z.string().optional(),
        required: z.boolean().optional(),
        defaultValue: z.string().optional()
      })
    )
    .optional(),
  metadata: z.record(z.any()).optional()
});

const updateTemplateMetaSchema = z.object({
  description: z.string().max(512).optional(),
  isArchived: z.boolean().optional()
});

export default async function promptTemplatesRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // List templates for an org
  app.get('/orgs/:orgId/prompt-templates', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:prompt-templates:read'
    );

    const templates = await prisma.promptTemplate.findMany({
      where: { orgId },
      orderBy: { createdAt: 'desc' },
      include: {
        versions: {
          orderBy: { version: 'desc' },
          take: 1,
          include: {
            creator: { select: { displayName: true } }
          }
        }
      }
    });

    const result = templates.map((t) => {
      const v = t.versions[0];
      return {
        id: t.id,
        orgId: t.orgId,
        name: t.name,
        description: t.description,
        isArchived: t.isArchived,
        createdAt: t.createdAt.toISOString(),
        latestVersion: v
          ? {
              id: v.id,
              version: v.version,
              systemPrompt: v.systemPrompt,
              userPrefix: v.userPrefix,
              assistantStyle: v.assistantStyle,
              variables: v.variables as any,
              createdAt: v.createdAt.toISOString(),
              createdByDisplayName: v.creator.displayName
            }
          : null
      };
    });

    return reply.send({ templates: result });
  });

  // Create template + initial version
  app.post('/orgs/:orgId/prompt-templates', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:prompt-templates:write'
    );

    const parsed = createTemplateSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const data = parsed.data;

    const tmpl = await prisma.promptTemplate.create({
      data: {
        orgId,
        name: data.name,
        description: data.description ?? null,
        createdById: payload.userId,
        versions: {
          create: {
            version: 1,
            systemPrompt: data.systemPrompt,
            userPrefix: data.userPrefix ?? null,
            assistantStyle: data.assistantStyle ?? null,
            variables: data.variables ?? {},
            metadata: data.metadata ?? {},
            createdById: payload.userId
          }
        }
      },
      include: {
        versions: {
          orderBy: { version: 'desc' },
          take: 1,
          include: { creator: { select: { displayName: true } } }
        }
      }
    });

    const latest = tmpl.versions[0];

    // Optional: emitEvent('prompt_template.created', ...)

    return reply.code(201).send({
      template: {
        id: tmpl.id,
        orgId: tmpl.orgId,
        name: tmpl.name,
        description: tmpl.description,
        isArchived: tmpl.isArchived,
        createdAt: tmpl.createdAt.toISOString(),
        latestVersion: {
          id: latest.id,
          version: latest.version,
          systemPrompt: latest.systemPrompt,
          userPrefix: latest.userPrefix,
          assistantStyle: latest.assistantStyle,
          variables: latest.variables as any,
          createdAt: latest.createdAt.toISOString(),
          createdByDisplayName: latest.creator.displayName
        }
      }
    });
  });

  // Update template metadata
  app.patch('/orgs/:orgId/prompt-templates/:templateId', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, templateId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:prompt-templates:write'
    );

    const parsed = updateTemplateMetaSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    await prisma.promptTemplate.updateMany({
      where: { id: templateId, orgId },
      data: {
        description: parsed.data.description,
        isArchived: parsed.data.isArchived ?? undefined
      }
    });

    return reply.send({ ok: true });
  });
}
```

### 42.3.3. Routes – Add New Version & Get Template Detail

Extend `promptTemplatesRoutes` with version endpoints.

```ts
const createVersionSchema = z.object({
  systemPrompt: z.string().min(1),
  userPrefix: z.string().optional(),
  assistantStyle: z.string().optional(),
  variables: z
    .record(
      z.object({
        description: z.string().optional(),
        required: z.boolean().optional(),
        defaultValue: z.string().optional()
      })
    )
    .optional(),
  metadata: z.record(z.any()).optional()
});

// Get template w/ all versions
app.get('/orgs/:orgId/prompt-templates/:templateId', { preHandler: [app.authenticate] }, async (req, reply) => {
  const payload = req.user as JwtPayload;
  const { orgId, templateId } = req.params as any;

  await assertOrgPermission(
    { id: payload.userId, isSuperadmin: payload.isSuperadmin },
    orgId,
    'org:prompt-templates:read'
  );

  const tmpl = await prisma.promptTemplate.findFirst({
    where: { id: templateId, orgId },
    include: {
      versions: {
        orderBy: { version: 'desc' },
        include: { creator: { select: { displayName: true } } }
      }
    }
  });

  if (!tmpl) {
    return reply.code(404).send({ error: 'NOT_FOUND' });
  }

  return reply.send({
    template: {
      id: tmpl.id,
      orgId: tmpl.orgId,
      name: tmpl.name,
      description: tmpl.description,
      isArchived: tmpl.isArchived,
      createdAt: tmpl.createdAt.toISOString(),
      versions: tmpl.versions.map((v) => ({
        id: v.id,
        version: v.version,
        systemPrompt: v.systemPrompt,
        userPrefix: v.userPrefix,
        assistantStyle: v.assistantStyle,
        variables: v.variables as any,
        createdAt: v.createdAt.toISOString(),
        createdByDisplayName: v.creator.displayName
      }))
    }
  });
});

// Add new version
app.post('/orgs/:orgId/prompt-templates/:templateId/versions', { preHandler: [app.authenticate] }, async (req, reply) => {
  const payload = req.user as JwtPayload;
  const { orgId, templateId } = req.params as any;

  await assertOrgPermission(
    { id: payload.userId, isSuperadmin: payload.isSuperadmin },
    orgId,
    'org:prompt-templates:write'
  );

  const parsed = createVersionSchema.safeParse(req.body);
  if (!parsed.success) {
    return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
  }

  const latest = await prisma.promptTemplateVersion.findFirst({
    where: { templateId },
    orderBy: { version: 'desc' }
  });

  const newVersionNumber = (latest?.version ?? 0) + 1;

  const v = await prisma.promptTemplateVersion.create({
    data: {
      templateId,
      version: newVersionNumber,
      systemPrompt: parsed.data.systemPrompt,
      userPrefix: parsed.data.userPrefix ?? null,
      assistantStyle: parsed.data.assistantStyle ?? null,
      variables: parsed.data.variables ?? {},
      metadata: parsed.data.metadata ?? {},
      createdById: payload.userId
    },
    include: { creator: { select: { displayName: true } } }
  });

  // Optional: emitEvent('prompt_template.version_created', ...)

  return reply.code(201).send({
    version: {
      id: v.id,
      version: v.version,
      systemPrompt: v.systemPrompt,
      userPrefix: v.userPrefix,
      assistantStyle: v.assistantStyle,
      variables: v.variables as any,
      createdAt: v.createdAt.toISOString(),
      createdByDisplayName: v.creator.displayName
    }
  });
});
```

Register route in `main.ts`:

```ts
import promptTemplatesRoutes from './routes/promptTemplates';

await app.register(promptTemplatesRoutes);
```

---

## 42.4. Backend – Chat Profiles

### 42.4.1. DTOs

**File:** `apps/api-gateway/src/promptStudio/chatProfileTypes.ts`

```ts
// apps/api-gateway/src/promptStudio/chatProfileTypes.ts

export interface ChatProfileDto {
  id: string;
  orgId: string;
  name: string;
  slug: string;
  description: string | null;
  isShared: boolean;
  isDefault: boolean;
  modelProvider: string;
  modelName: string;
  temperature: number;
  topP: number;
  maxTokens: number | null;
  systemTemplateId: string | null;
  systemTemplateVersion: number | null;
  enableTools: boolean;
  enableRag: boolean;
  safetyLevel: string;
  createdAt: string;
}
```

### 42.4.2. Routes – List & CRUD

**File:** `apps/api-gateway/src/routes/chatProfiles.ts`

```ts
// apps/api-gateway/src/routes/chatProfiles.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import slugify from 'slugify';

const createProfileSchema = z.object({
  name: z.string().min(1).max(128),
  description: z.string().max(512).optional(),
  isShared: z.boolean().optional(),
  isDefault: z.boolean().optional(),
  modelProvider: z.string().min(1),
  modelName: z.string().min(1),
  temperature: z.number().min(0).max(2).optional(),
  topP: z.number().min(0).max(1).optional(),
  maxTokens: z.number().int().min(1).max(32768).nullable().optional(),
  systemTemplateId: z.string().nullable().optional(),
  systemTemplateVersion: z.number().int().nullable().optional(),
  enableTools: z.boolean().optional(),
  enableRag: z.boolean().optional(),
  safetyLevel: z.string().optional(),
  providerConfig: z.record(z.any()).optional()
});

const updateProfileSchema = createProfileSchema.partial();

export default async function chatProfilesRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // List profiles for org (optionally only shared)
  app.get('/orgs/:orgId/chat-profiles', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat-profiles:read'
    );

    const onlyShared = (req.query as any).onlyShared === 'true';

    const profiles = await prisma.chatProfile.findMany({
      where: { orgId, ...(onlyShared ? { isShared: true } : {}) },
      orderBy: { createdAt: 'desc' }
    });

    return reply.send({
      profiles: profiles.map((p) => ({
        id: p.id,
        orgId: p.orgId,
        name: p.name,
        slug: p.slug,
        description: p.description,
        isShared: p.isShared,
        isDefault: p.isDefault,
        modelProvider: p.modelProvider,
        modelName: p.modelName,
        temperature: p.temperature,
        topP: p.topP,
        maxTokens: p.maxTokens,
        systemTemplateId: p.systemTemplateId,
        systemTemplateVersion: p.systemTemplateVersion,
        enableTools: p.enableTools,
        enableRag: p.enableRag,
        safetyLevel: p.safetyLevel,
        createdAt: p.createdAt.toISOString()
      }))
    });
  });

  // Create
  app.post('/orgs/:orgId/chat-profiles', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat-profiles:write'
    );

    const parsed = createProfileSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const data = parsed.data;
    const slugBase = slugify(data.name, { lower: true, strict: true });

    // ensure slug uniqueness
    let slug = slugBase || 'profile';
    let attempt = 1;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const exists = await prisma.chatProfile.findFirst({ where: { slug } });
      if (!exists) break;
      attempt += 1;
      slug = `${slugBase}-${attempt}`;
    }

    if (data.isDefault) {
      // unset previous defaults
      await prisma.chatProfile.updateMany({
        where: { orgId, isDefault: true },
        data: { isDefault: false }
      });
    }

    const profile = await prisma.chatProfile.create({
      data: {
        orgId,
        name: data.name,
        slug,
        description: data.description ?? null,
        isShared: data.isShared ?? true,
        isDefault: data.isDefault ?? false,
        modelProvider: data.modelProvider,
        modelName: data.modelName,
        temperature: data.temperature ?? 0.7,
        topP: data.topP ?? 1.0,
        maxTokens: typeof data.maxTokens === 'number' ? data.maxTokens : null,
        systemTemplateId: data.systemTemplateId ?? null,
        systemTemplateVersion: data.systemTemplateVersion ?? null,
        enableTools: data.enableTools ?? true,
        enableRag: data.enableRag ?? false,
        safetyLevel: data.safetyLevel ?? 'standard',
        providerConfig: data.providerConfig ?? {},
        createdById: payload.userId
      }
    });

    // Optional: emitEvent('chat_profile.created', ...)

    return reply.code(201).send({
      profile: {
        id: profile.id,
        orgId: profile.orgId,
        name: profile.name,
        slug: profile.slug,
        description: profile.description,
        isShared: profile.isShared,
        isDefault: profile.isDefault,
        modelProvider: profile.modelProvider,
        modelName: profile.modelName,
        temperature: profile.temperature,
        topP: profile.topP,
        maxTokens: profile.maxTokens,
        systemTemplateId: profile.systemTemplateId,
        systemTemplateVersion: profile.systemTemplateVersion,
        enableTools: profile.enableTools,
        enableRag: profile.enableRag,
        safetyLevel: profile.safetyLevel,
        createdAt: profile.createdAt.toISOString()
      }
    });
  });

  // Update
  app.patch('/orgs/:orgId/chat-profiles/:profileId', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, profileId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat-profiles:write'
    );

    const parsed = updateProfileSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const data = parsed.data;

    if (data.isDefault === true) {
      await prisma.chatProfile.updateMany({ where: { orgId, isDefault: true }, data: { isDefault: false } });
    }

    await prisma.chatProfile.updateMany({
      where: { id: profileId, orgId },
      data: {
        name: data.name ?? undefined,
        description: data.description ?? undefined,
        isShared: typeof data.isShared === 'boolean' ? data.isShared : undefined,
        isDefault: typeof data.isDefault === 'boolean' ? data.isDefault : undefined,
        modelProvider: data.modelProvider ?? undefined,
        modelName: data.modelName ?? undefined,
        temperature: typeof data.temperature === 'number' ? data.temperature : undefined,
        topP: typeof data.topP === 'number' ? data.topP : undefined,
        maxTokens:
          typeof data.maxTokens === 'number' ? data.maxTokens : data.maxTokens === null ? null : undefined,
        systemTemplateId:
          data.systemTemplateId !== undefined ? data.systemTemplateId : undefined,
        systemTemplateVersion:
          data.systemTemplateVersion !== undefined ? data.systemTemplateVersion : undefined,
        enableTools: typeof data.enableTools === 'boolean' ? data.enableTools : undefined,
        enableRag: typeof data.enableRag === 'boolean' ? data.enableRag : undefined,
        safetyLevel: data.safetyLevel ?? undefined,
        providerConfig: data.providerConfig ?? undefined
      }
    });

    return reply.send({ ok: true });
  });

  // Delete
  app.delete('/orgs/:orgId/chat-profiles/:profileId', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, profileId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat-profiles:write'
    );

    await prisma.chatProfile.deleteMany({ where: { id: profileId, orgId } });

    return reply.send({ ok: true });
  });
}
```

Register route in `main.ts`:

```ts
import chatProfilesRoutes from './routes/chatProfiles';

await app.register(chatProfilesRoutes);
```

---

## 42.5. Integrating Chat Profiles into Conversation Creation

When a conversation is created, the client may specify a `chatProfileId` (or `slug`).

### 42.5.1. Request Shape

Conversation creation (25.md) can accept:

```jsonc
{
  "title": "Data analysis assistant",
  "chatProfileId": "cp_123", // optional
  "initialMessage": {
    "content": "Help me explore this dataset..."
  }
}
```

Backend logic:

1. If `chatProfileId` is provided:
   - Load `ChatProfile` for the org.  
   - Attach `chatProfileId` to Conversation row.  
   - When building LLM request, use profile’s `modelProvider`, `modelName`, `temperature`, `topP`, `maxTokens`, `enableTools`, `enableRag`, `safetyLevel`.  
   - If `systemTemplateId`+`version` present, load `PromptTemplateVersion` and **render** prompts.

2. If not provided: fallback to org default profile (first `isDefault = true`, or platform default).

### 42.5.2. Prompt Rendering Helper

**File:** `apps/api-gateway/src/promptStudio/render.ts`

```ts
// apps/api-gateway/src/promptStudio/render.ts

import { prisma } from '@ai-chat/db';

interface RenderContext {
  orgId: string;
  userId: string;
  conversationId?: string;
  variables?: Record<string, string>;
}

export async function renderSystemPromptFromProfile(
  chatProfileId: string,
  ctx: RenderContext
): Promise<string | null> {
  const profile = await prisma.chatProfile.findUnique({ where: { id: chatProfileId } });
  if (!profile || !profile.systemTemplateId || !profile.systemTemplateVersion) return null;

  const version = await prisma.promptTemplateVersion.findFirst({
    where: {
      templateId: profile.systemTemplateId,
      version: profile.systemTemplateVersion
    }
  });

  if (!version) return null;

  const vars = (version.variables as any) || {};

  const mergedVars: Record<string, string> = {};

  for (const [key, meta] of Object.entries<any>(vars)) {
    const provided = ctx.variables?.[key];
    if (provided) {
      mergedVars[key] = provided;
    } else if (meta.defaultValue) {
      mergedVars[key] = meta.defaultValue;
    }
  }

  // Some built-in variables
  mergedVars['org_id'] = ctx.orgId;
  mergedVars['user_id'] = ctx.userId;
  mergedVars['conversation_id'] = ctx.conversationId ?? '';
  mergedVars['today'] = new Date().toISOString().split('T')[0];

  return interpolate(version.systemPrompt, mergedVars);
}

function interpolate(template: string, vars: Record<string, string>): string {
  return template.replace(/{{(\w+)}}/g, (_, key) => {
    return vars[key] ?? `{{${key}}}`;
  });
}
```

In the message pipeline, call `renderSystemPromptFromProfile` when constructing the LLM request.

---

## 42.6. Frontend – API Wrappers

### 42.6.1. Prompt Templates

**File:** `apps/web/src/api/promptTemplates.ts`

```ts
// apps/web/src/api/promptTemplates.ts

import { apiRequest } from './client';

export interface PromptTemplateVersionDto {
  id: string;
  version: number;
  systemPrompt: string;
  userPrefix: string | null;
  assistantStyle: string | null;
  variables: Record<string, { description?: string; required?: boolean; defaultValue?: string }>;
  createdAt: string;
  createdByDisplayName: string | null;
}

export interface PromptTemplateDto {
  id: string;
  orgId: string;
  name: string;
  description: string | null;
  isArchived: boolean;
  createdAt: string;
  latestVersion: PromptTemplateVersionDto | null;
  versions?: PromptTemplateVersionDto[];
}

export async function fetchPromptTemplates(
  token: string,
  orgId: string
): Promise<{ templates: PromptTemplateDto[] }> {
  return apiRequest<{ templates: PromptTemplateDto[]}>(
    `/orgs/${orgId}/prompt-templates`,
    { method: 'GET' },
    token
  );
}

export async function fetchPromptTemplateDetail(
  token: string,
  orgId: string,
  templateId: string
): Promise<{ template: PromptTemplateDto }> {
  return apiRequest<{ template: PromptTemplateDto}>(
    `/orgs/${orgId}/prompt-templates/${templateId}`,
    { method: 'GET' },
    token
  );
}

export async function createPromptTemplate(
  token: string,
  orgId: string,
  input: {
    name: string;
    description?: string;
    systemPrompt: string;
    userPrefix?: string;
    assistantStyle?: string;
    variables?: Record<string, { description?: string; required?: boolean; defaultValue?: string }>;
    metadata?: Record<string, any>;
  }
): Promise<{ template: PromptTemplateDto }> {
  return apiRequest<{ template: PromptTemplateDto }>(
    `/orgs/${orgId}/prompt-templates`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function createPromptTemplateVersion(
  token: string,
  orgId: string,
  templateId: string,
  input: {
    systemPrompt: string;
    userPrefix?: string;
    assistantStyle?: string;
    variables?: Record<string, { description?: string; required?: boolean; defaultValue?: string }>;
    metadata?: Record<string, any>;
  }
): Promise<{ version: PromptTemplateVersionDto }> {
  return apiRequest<{ version: PromptTemplateVersionDto }>(
    `/orgs/${orgId}/prompt-templates/${templateId}/versions`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}
```

### 42.6.2. Chat Profiles

**File:** `apps/web/src/api/chatProfiles.ts`

```ts
// apps/web/src/api/chatProfiles.ts

import { apiRequest } from './client';

export interface ChatProfileDto {
  id: string;
  orgId: string;
  name: string;
  slug: string;
  description: string | null;
  isShared: boolean;
  isDefault: boolean;
  modelProvider: string;
  modelName: string;
  temperature: number;
  topP: number;
  maxTokens: number | null;
  systemTemplateId: string | null;
  systemTemplateVersion: number | null;
  enableTools: boolean;
  enableRag: boolean;
  safetyLevel: string;
  createdAt: string;
}

export async function fetchChatProfiles(
  token: string,
  orgId: string,
  onlyShared = false
): Promise<{ profiles: ChatProfileDto[] }> {
  const search = new URLSearchParams();
  if (onlyShared) search.set('onlyShared', 'true');

  return apiRequest<{ profiles: ChatProfileDto[]}>(
    `/orgs/${orgId}/chat-profiles${search.toString() ? `?${search.toString()}` : ''}`,
    { method: 'GET' },
    token
  );
}

export async function createChatProfile(
  token: string,
  orgId: string,
  input: Partial<ChatProfileDto> & {
    name: string;
    modelProvider: string;
    modelName: string;
  }
): Promise<{ profile: ChatProfileDto }> {
  return apiRequest<{ profile: ChatProfileDto }>(
    `/orgs/${orgId}/chat-profiles`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function updateChatProfile(
  token: string,
  orgId: string,
  profileId: string,
  input: Partial<ChatProfileDto>
): Promise<void> {
  await apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/chat-profiles/${profileId}`,
    {
      method: 'PATCH',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function deleteChatProfile(
  token: string,
  orgId: string,
  profileId: string
): Promise<void> {
  await apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/chat-profiles/${profileId}`,
    { method: 'DELETE' },
    token
  );
}
```

---

## 42.7. Material 3 UI – Prompt Studio Pages

We add two main Prompt Studio areas under the org:

- `/app/orgs/:orgId/prompt-studio/templates` – Template list & editor.  
- `/app/orgs/:orgId/prompt-studio/profiles` – Chat Profile list & editor.

### 42.7.1. Templates Page

**File:** `apps/web/src/org/PromptTemplatesPage.tsx`

```tsx
// apps/web/src/org/PromptTemplatesPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  List,
  ListItemButton,
  ListItemText,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import AddIcon from '@mui/icons-material/Add';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import {
  PromptTemplateDto,
  PromptTemplateVersionDto,
  fetchPromptTemplates,
  fetchPromptTemplateDetail,
  createPromptTemplate,
  createPromptTemplateVersion
} from '../api/promptTemplates';

export const PromptTemplatesPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [templates, setTemplates] = useState<PromptTemplateDto[]>([]);
  const [selected, setSelected] = useState<PromptTemplateDto | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [newName, setNewName] = useState('');
  const [newDesc, setNewDesc] = useState('');
  const [newSystemPrompt, setNewSystemPrompt] = useState('');

  const [newVersionPrompt, setNewVersionPrompt] = useState('');

  const gradientBg =
    'radial-gradient(circle at top left, rgba(96,165,250,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(56,189,248,0.18), transparent 55%)';

  const load = async () => {
    if (!token || !orgId) return;
    const res = await fetchPromptTemplates(token, orgId);
    setTemplates(res.templates);
  };

  const loadDetail = async (id: string) => {
    if (!token || !orgId) return;
    const res = await fetchPromptTemplateDetail(token, orgId, id);
    setSelected(res.template);
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [orgId, token]);

  const handleCreateTemplate = async () => {
    if (!token || !orgId) return;
    const res = await createPromptTemplate(token, orgId, {
      name: newName,
      description: newDesc || undefined,
      systemPrompt: newSystemPrompt
    });
    setDialogOpen(false);
    setNewName('');
    setNewDesc('');
    setNewSystemPrompt('');
    await load();
    setSelected(res.template);
  };

  const handleAddVersion = async () => {
    if (!token || !orgId || !selected) return;
    const res = await createPromptTemplateVersion(token, orgId, selected.id, {
      systemPrompt: newVersionPrompt
    });
    setNewVersionPrompt('');
    await loadDetail(selected.id);
  };

  const renderVersions = (versions: PromptTemplateVersionDto[] | undefined) => {
    if (!versions || versions.length === 0) {
      return (
        <Typography variant="body2" color="text.secondary">
          No versions yet.
        </Typography>
      );
    }

    return (
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, mt: 1 }}>
        {versions.map((v) => (
          <Card key={v.id} sx={{ borderRadius: 2 }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Typography variant="subtitle2">v{v.version}</Typography>
                <Typography variant="caption" color="text.secondary">
                  {v.createdByDisplayName || 'Unknown'} ·{' '}
                  {new Date(v.createdAt).toLocaleString()}
                </Typography>
              </Box>
              <Typography
                variant="body2"
                sx={{ whiteSpace: 'pre-wrap', fontFamily: 'monospace', fontSize: 12 }}
              >
                {v.systemPrompt}
              </Typography>
            </CardContent>
          </Card>
        ))}
      </Box>
    );
  };

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box sx={{ width: 260, display: 'flex', flexDirection: 'column', gap: 1 }}>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box display="flex" alignItems="center" gap={1}>
            <AutoAwesomeIcon fontSize="small" />
            <Typography variant="subtitle1">Prompt templates</Typography>
          </Box>
          <Button
            size="small"
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setDialogOpen(true)}
          >
            New
          </Button>
        </Box>

        <Card sx={{ flex: 1, borderRadius: 3, overflow: 'auto' }}>
          <CardContent sx={{ p: 0 }}>
            <List dense>
              {templates.map((t) => (
                <ListItemButton
                  key={t.id}
                  selected={selected?.id === t.id}
                  onClick={() => void loadDetail(t.id)}
                >
                  <ListItemText
                    primary={t.name}
                    secondary={t.description || t.latestVersion?.systemPrompt.slice(0, 60)}
                  />
                </ListItemButton>
              ))}
              {templates.length === 0 && (
                <Box p={2}>
                  <Typography variant="body2" color="text.secondary">
                    No templates yet.
                  </Typography>
                </Box>
              )}
            </List>
          </CardContent>
        </Card>
      </Box>

      <Box sx={{ flex: 1, minWidth: 0 }}>
        {selected ? (
          <Card sx={{ borderRadius: 3, height: '100%', display: 'flex', flexDirection: 'column' }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, height: '100%' }}>
              <Typography variant="h6">{selected.name}</Typography>
              {selected.description && (
                <Typography variant="body2" color="text.secondary">
                  {selected.description}
                </Typography>
              )}

              <Typography variant="subtitle2">Versions</Typography>
              {renderVersions(selected.versions)}

              <Box mt={1}>
                <Typography variant="subtitle2" gutterBottom>
                  Add new version
                </Typography>
                <TextField
                  multiline
                  minRows={4}
                  fullWidth
                  placeholder="Enter updated system prompt..."
                  value={newVersionPrompt}
                  onChange={(e) => setNewVersionPrompt(e.target.value)}
                />
                <Box mt={1} display="flex" justifyContent="flex-end">
                  <Button
                    size="small"
                    variant="contained"
                    disabled={!newVersionPrompt.trim()}
                    onClick={handleAddVersion}
                  >
                    Save new version
                  </Button>
                </Box>
              </Box>
            </CardContent>
          </Card>
        ) : (
          <Card sx={{ borderRadius: 3, height: '100%' }}>
            <CardContent
              sx={{
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
            >
              <Typography variant="body2" color="text.secondary">
                Select a template to view details.
              </Typography>
            </CardContent>
          </Card>
        )}
      </Box>

      <Dialog open={dialogOpen} onClose={() => setDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>New prompt template</DialogTitle>
        <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
          <TextField
            label="Name"
            fullWidth
            value={newName}
            onChange={(e) => setNewName(e.target.value)}
          />
          <TextField
            label="Description"
            fullWidth
            value={newDesc}
            onChange={(e) => setNewDesc(e.target.value)}
          />
          <TextField
            label="System prompt"
            multiline
            minRows={4}
            fullWidth
            value={newSystemPrompt}
            onChange={(e) => setNewSystemPrompt(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDialogOpen(false)}>Cancel</Button>
          <Button
            onClick={handleCreateTemplate}
            disabled={!newName.trim() || !newSystemPrompt.trim()}
          >
            Create
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};
```

### 42.7.2. Chat Profiles Page

**File:** `apps/web/src/org/ChatProfilesPage.tsx`

```tsx
// apps/web/src/org/ChatProfilesPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  FormControlLabel,
  Switch,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import AddIcon from '@mui/icons-material/Add';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import {
  ChatProfileDto,
  fetchChatProfiles,
  createChatProfile,
  deleteChatProfile
} from '../api/chatProfiles';
import { fetchPromptTemplates, PromptTemplateDto } from '../api/promptTemplates';

export const ChatProfilesPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [profiles, setProfiles] = useState<ChatProfileDto[]>([]);
  const [templates, setTemplates] = useState<PromptTemplateDto[]>([]);
  const [dialogOpen, setDialogOpen] = useState(false);

  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [modelProvider, setModelProvider] = useState('ollama');
  const [modelName, setModelName] = useState('llama3');
  const [isShared, setIsShared] = useState(true);
  const [isDefault, setIsDefault] = useState(false);
  const [systemTemplateId, setSystemTemplateId] = useState<string | null>(null);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(236,72,153,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(56,189,248,0.18), transparent 55%)';

  const load = async () => {
    if (!token || !orgId) return;
    const [p, t] = await Promise.all([
      fetchChatProfiles(token, orgId),
      fetchPromptTemplates(token, orgId)
    ]);
    setProfiles(p.profiles);
    setTemplates(t.templates);
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [orgId, token]);

  const handleCreate = async () => {
    if (!token || !orgId) return;
    await createChatProfile(token, orgId, {
      name,
      description,
      modelProvider,
      modelName,
      isShared,
      isDefault,
      systemTemplateId: systemTemplateId || null
    });

    setDialogOpen(false);
    setName('');
    setDescription('');
    setSystemTemplateId(null);
    setIsDefault(false);
    await load();
  };

  const handleDelete = async (id: string) => {
    if (!token || !orgId) return;
    await deleteChatProfile(token, orgId, id);
    await load();
  };

  const findTemplateName = (id: string | null) => {
    if (!id) return 'None';
    const t = templates.find((t) => t.id === id);
    return t?.name || 'Unknown';
  };

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1}>
          <AutoAwesomeIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Chat profiles</Typography>
            <Typography variant="caption" color="text.secondary">
              Create personas that define model, prompts and tools for new conversations.
            </Typography>
          </Box>
        </Box>
        <Button
          size="small"
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => setDialogOpen(true)}
        >
          New profile
        </Button>
      </Box>

      <Card sx={{ borderRadius: 3, flex: 1 }}>
        <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1.5 }}>
          {profiles.length === 0 && (
            <Typography variant="body2" color="text.secondary">
              No profiles yet.
            </Typography>
          )}

          {profiles.map((p) => (
            <Box
              key={p.id}
              sx={{
                p: 1.25,
                borderRadius: 2,
                border: '1px solid',
                borderColor: p.isDefault ? 'primary.main' : 'divider',
                display: 'flex',
                flexDirection: 'column',
                gap: 0.5
              }}
            >
              <Box display="flex" justifyContent="space-between" alignItems="center">
                <Box display="flex" alignItems="center" gap={1}>
                  <Typography variant="body1">{p.name}</Typography>
                  {p.isDefault && <Chip size="small" label="Default" />}
                  {!p.isShared && <Chip size="small" label="Private" />}
                </Box>
                <Box display="flex" alignItems="center" gap={1}>
                  <Typography variant="caption" color="text.secondary">
                    {p.modelProvider} · {p.modelName}
                  </Typography>
                  <Button size="small" onClick={() => void handleDelete(p.id)}>
                    Delete
                  </Button>
                </Box>
              </Box>
              {p.description && (
                <Typography variant="body2" color="text.secondary">
                  {p.description}
                </Typography>
              )}

              <Box display="flex" flexWrap="wrap" gap={0.5} mt={0.5}>
                <Chip
                  size="small"
                  label={`System template: ${findTemplateName(p.systemTemplateId)}`}
                />
                <Chip size="small" label={`Tools: ${p.enableTools ? 'On' : 'Off'}`} />
                <Chip size="small" label={`RAG: ${p.enableRag ? 'On' : 'Off'}`} />
                <Chip size="small" label={`Safety: ${p.safetyLevel}`} />
              </Box>
            </Box>
          ))}
        </CardContent>
      </Card>

      <Dialog open={dialogOpen} onClose={() => setDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>New chat profile</DialogTitle>
        <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
          <TextField
            label="Name"
            fullWidth
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
          <TextField
            label="Description"
            fullWidth
            value={description}
            onChange={(e) => setDescription(e.target.value)}
          />
          <TextField
            label="Model provider"
            fullWidth
            value={modelProvider}
            onChange={(e) => setModelProvider(e.target.value)}
            helperText="Example: ollama, openai, anthropic"
          />
          <TextField
            label="Model name"
            fullWidth
            value={modelName}
            onChange={(e) => setModelName(e.target.value)}
            helperText="Example: llama3, gpt-4.1, claude-3.5"
          />

          <TextField
            label="System template (ID)"
            fullWidth
            value={systemTemplateId || ''}
            onChange={(e) => setSystemTemplateId(e.target.value || null)}
            helperText="Paste template ID from Prompt Templates or leave blank"
          />

          <FormControlLabel
            control={
              <Switch
                checked={isShared}
                onChange={(e) => setIsShared(e.target.checked)}
              />
            }
            label="Shared with org"
          />
          <FormControlLabel
            control={
              <Switch
                checked={isDefault}
                onChange={(e) => setIsDefault(e.target.checked)}
              />
            }
            label="Use as default profile for new conversations"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleCreate} disabled={!name.trim() || !modelProvider || !modelName}>
            Create
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};
```

Register routes in your router:

```tsx
import { PromptTemplatesPage } from './org/PromptTemplatesPage';
import { ChatProfilesPage } from './org/ChatProfilesPage';

<Route path="/app/orgs/:orgId/prompt-studio/templates" element={<PromptTemplatesPage />} />
<Route path="/app/orgs/:orgId/prompt-studio/profiles" element={<ChatProfilesPage />} />
```

---

## 42.8. Observability & Audit

- **Events (38.md):**  
  - `prompt_template.created` / `prompt_template.version_created`.  
  - `chat_profile.created` / `chat_profile.updated` / `chat_profile.deleted`.  
- **Metrics (28.md):**  
  - `chat_profile_usage_total{orgId,profileSlug}` – conversations started with each profile.  
  - `prompt_template_usage_total{orgId,templateId}` – LLM calls that use a given template.  

These metrics allow Grafana dashboards like:

- Top used profiles per org.  
- Performance comparison per profile (latency, cost, satisfaction score if tracked).

---

## 42.9. Sanity Checklist

Before enabling Prompt Studio in production:

- [ ] Prisma migration for `PromptTemplate`, `PromptTemplateVersion`, `ChatProfile` applied.  
- [ ] Prompt template CRUD APIs and UI pages working.  
- [ ] Chat profile CRUD APIs and UI pages working.  
- [ ] Conversation creation correctly binds `chatProfileId` and uses its model/config.  
- [ ] System prompt rendering from templates works and variables are substituted.  
- [ ] Events & metrics are flowing into audit log and Grafana.

If all checks pass, the platform now has a **full Prompt Studio** comparable to modern "custom GPT" features: reusable templates, configurable personas and per‑org prompt governance.

---

_End of 42.md – Prompt Studio, Prompt Templates & Chat Profiles – Backend + Material 3 UI_
