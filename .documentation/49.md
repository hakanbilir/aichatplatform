# 49. SCIM 2.0 User & Group Provisioning – Directory Sync & Deprovisioning

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend engineers.  
> **Goal of this file:** Add **enterprise‑grade SCIM 2.0 provisioning** so that:
>
> - Orgs can connect their IdP (Okta, Azure AD, Google Workspace, etc.) using **SCIM 2.0**.  
> - Users and groups are created/updated/deprovisioned automatically via SCIM.  
> - Seat limits from billing plans (46.md, 48.md) are respected when provisioning.  
> - Group membership maps to platform roles and org membership (11–14.md, 48.md).  
> - All activity is auditable and observable (28.md, 38.md).
>
> This spec is written so Cursor‑like agents can implement it end‑to‑end without further questions.

This file builds on:

- 11–14.md – Orgs, users, roles & RBAC.  
- 18.md – Auth & JWT (for admin UI, not SCIM itself).  
- 46.md – Billing & plans.  
- 48.md – Seat‑based licensing & SSO.  
- 28.md – Observability & metrics.  
- 38.md – Event bus & audit log.

---

## 49.1. Concepts & Scope

We implement a minimal but enterprise‑ready subset of **SCIM 2.0**:

- **Inbound SCIM** (IdP → our platform):
  - `/scim/:orgSlug/v2/Users`  
  - `/scim/:orgSlug/v2/Groups`
- The platform acts as **SCIM Service Provider**.  
- IdP acts as **SCIM Client**.

Main flows:

1. **User Provisioning**  
   - IdP calls `POST /Users` → create local `User` + `OrgMembership`.  
   - `PATCH /Users/{id}` or `PUT` → update local user (name, active flag).  
   - `DELETE /Users/{id}` or `PATCH active=false` → disable membership & possibly user.

2. **Group Provisioning**  
   - IdP calls `POST /Groups` → create a logical group mapped to roles or tags.  
   - Group `members` array drives membership changes.

3. **Seat Limits & Licensing**  
   - Before provisioning/activating a membership, we check `max_seats` (48.md).  
   - If exceeded, we reject provisioning with a SCIM error response.

4. **SCIM Security**  
   - Per‑org **bearer token** is stored in `ScimConnection`.  
   - All SCIM requests must include `Authorization: Bearer <token>`.

Non‑goals (for this version):

- Outbound SCIM or full directory sync back to IdP.  
- Complex multi‑org groups.  
- Advanced attribute mapping UI (we expose basic config JSON instead).

---

## 49.2. Data Model – Prisma

Extend `packages/db/prisma/schema.prisma`.

```prisma
/// SCIM connection per org (distinct from SsoConnection)
model ScimConnection {
  id        String   @id @default(cuid())

  orgId     String

  // Random bearer token used by IdP to authenticate SCIM calls
  bearerToken String @unique

  // Display name, e.g. 'Acme Okta SCIM'
  name      String

  isEnabled Boolean  @default(false)

  // Optional JSON mapping config
  // Example keys:
  // { "group_admin_roles": ["org_admin"], "group_viewer_roles": ["viewer"] }
  config    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Org      @relation(fields: [orgId], references: [id])

  @@index([orgId])
}

/// SCIM object mapping for Users/Groups
model ScimResourceMap {
  id        String   @id @default(cuid())

  orgId     String

  // 'User' or 'Group'
  resourceType String

  // IdP-side SCIM id (e.g. user id in Okta)
  scimId    String

  // Local object id (User.id or OrgGroup.id, depending on resourceType)
  localId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org       Org      @relation(fields: [orgId], references: [id])

  @@index([orgId, resourceType, scimId], name: "scim_resource_idx")
  @@index([orgId, resourceType, localId])
}

/// SCIM audit for provisioning actions
model ScimAudit {
  id        String   @id @default(cuid())

  orgId     String

  // 'User' or 'Group'
  resourceType String

  scimId    String?
  localId   String?

  action    String   // 'create', 'update', 'delete'
  status    String   // 'success', 'failed'
  reason    String?

  rawPayload Json?

  createdAt DateTime @default(now())

  org       Org      @relation(fields: [orgId], references: [id])

  @@index([orgId])
}
```

> **Note:** `OrgMembership` is assumed to exist from earlier files (11–14.md, 48.md) with fields like `orgId`, `userId`, `roles`, `isDisabled`.

Run a Prisma migration after updating.

---

## 49.3. SCIM Connection Admin API

We need API endpoints for org admins to:

- View SCIM connection details.  
- Enable/disable SCIM.  
- Rotate bearer token.

**File:** `apps/api-gateway/src/routes/orgScimConnections.ts`

```ts
// apps/api-gateway/src/routes/orgScimConnections.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import crypto from 'crypto';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

function generateBearerToken() {
  return crypto.randomBytes(48).toString('base64url');
}

export default async function orgScimConnectionsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.get('/orgs/:orgId/scim-connection', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:read'
    );

    const conn = await prisma.scimConnection.findFirst({ where: { orgId } });

    return reply.send({ connection: conn });
  });

  app.put('/orgs/:orgId/scim-connection', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;
    const body = req.body as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:write'
    );

    const { name, isEnabled, config } = body;

    let conn = await prisma.scimConnection.findFirst({ where: { orgId } });

    if (!conn) {
      conn = await prisma.scimConnection.create({
        data: {
          orgId,
          name: name || 'SCIM connection',
          isEnabled: Boolean(isEnabled),
          bearerToken: generateBearerToken(),
          config: config ?? {}
        }
      });
    } else {
      conn = await prisma.scimConnection.update({
        where: { id: conn.id },
        data: {
          name: name ?? conn.name,
          isEnabled: typeof isEnabled === 'boolean' ? isEnabled : conn.isEnabled,
          config: config ?? conn.config
        }
      });
    }

    return reply.send({ connection: conn });
  });

  app.post('/orgs/:orgId/scim-connection/rotate-token', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:write'
    );

    const conn = await prisma.scimConnection.findFirst({ where: { orgId } });
    if (!conn) {
      return reply.code(404).send({ error: 'SCIM_CONNECTION_NOT_FOUND' });
    }

    const updated = await prisma.scimConnection.update({
      where: { id: conn.id },
      data: { bearerToken: generateBearerToken() }
    });

    return reply.send({ connection: updated });
  });
}
```

Register in `main.ts`:

```ts
import orgScimConnectionsRoutes from './routes/orgScimConnections';

await app.register(orgScimConnectionsRoutes);
```

Org admin UI can be added under `/app/orgs/:orgId/settings/scim` similar to SSO settings (48.md) using Material 3.

---

## 49.4. SCIM Auth – Bearer Token Validation

SCIM endpoints will be unauthenticated from the user’s perspective but secured via **SCIM bearer token**.

**File:** `apps/api-gateway/src/scim/scimAuth.ts`

```ts
// apps/api-gateway/src/scim/scimAuth.ts

import { prisma } from '@ai-chat/db';

export interface ScimAuthContext {
  orgId: string;
  connectionId: string;
}

export async function authenticateScimRequest(
  orgSlug: string,
  authHeader: string | undefined
): Promise<ScimAuthContext> {
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error('SCIM_UNAUTHORIZED');
  }

  const token = authHeader.substring('Bearer '.length).trim();
  if (!token) {
    throw new Error('SCIM_UNAUTHORIZED');
  }

  const org = await prisma.org.findFirst({ where: { slug: orgSlug } });
  if (!org) {
    throw new Error('SCIM_ORG_NOT_FOUND');
  }

  const conn = await prisma.scimConnection.findFirst({
    where: { orgId: org.id, bearerToken: token, isEnabled: true }
  });

  if (!conn) {
    throw new Error('SCIM_UNAUTHORIZED');
  }

  return { orgId: org.id, connectionId: conn.id };
}
```

All SCIM routes must call this function at the beginning and handle errors with SCIM‑style responses (`401` or `403`).

---

## 49.5. SCIM Service – Mapping Users & Groups

We build a small SCIM service to:

- Map SCIM user payloads ⇄ local `User` + `OrgMembership`.  
- Respect seat limits (48.md).  
- Record `ScimResourceMap` and `ScimAudit`.

**File:** `apps/api-gateway/src/scim/scimService.ts`

```ts
// apps/api-gateway/src/scim/scimService.ts

import { prisma } from '@ai-chat/db';
import { canAddSeat } from '../billing/seatService';

interface ScimUserAttributes {
  userName: string;
  active?: boolean;
  emails?: { value: string; primary?: boolean }[];
  name?: { givenName?: string; familyName?: string };
  displayName?: string;
}

export interface ScimUser {
  id: string;
  userName: string;
  active: boolean;
  emails?: { value: string; primary?: boolean }[];
  name?: { givenName?: string; familyName?: string };
  displayName?: string;
}

export async function getLocalUserIdByScimId(orgId: string, scimId: string): Promise<string | null> {
  const map = await prisma.scimResourceMap.findFirst({
    where: { orgId, resourceType: 'User', scimId }
  });
  return map?.localId ?? null;
}

export async function createOrUpdateUserFromScim(
  orgId: string,
  scimId: string,
  attrs: ScimUserAttributes
) {
  const primaryEmail = attrs.emails?.find((e) => e.primary)?.value || attrs.emails?.[0]?.value;
  const email = primaryEmail || attrs.userName;

  const active = attrs.active !== false;

  let map = await prisma.scimResourceMap.findFirst({
    where: { orgId, resourceType: 'User', scimId }
  });

  let userId: string;

  if (map) {
    // Update existing user
    const user = await prisma.user.update({
      where: { id: map.localId },
      data: {
        email,
        name: attrs.displayName || [attrs.name?.givenName, attrs.name?.familyName].filter(Boolean).join(' ') || email
      }
    });
    userId = user.id;
  } else {
    // Enforce seat limit
    const canSeat = await canAddSeat(orgId);
    if (!canSeat) {
      throw new Error('SEAT_LIMIT_EXCEEDED');
    }

    const user = await prisma.user.create({
      data: {
        email,
        name: attrs.displayName || [attrs.name?.givenName, attrs.name?.familyName].filter(Boolean).join(' ') || email
      }
    });

    await prisma.scimResourceMap.create({
      data: {
        orgId,
        resourceType: 'User',
        scimId,
        localId: user.id
      }
    });

    userId = user.id;
  }

  // Upsert org membership
  await prisma.orgMembership.upsert({
    where: {
      orgId_userId: {
        orgId,
        userId
      }
    },
    update: {
      isDisabled: !active
    },
    create: {
      orgId,
      userId,
      isDisabled: !active,
      roles: ['member']
    }
  });

  return userId;
}

export async function deactivateUserFromScim(orgId: string, scimId: string) {
  const map = await prisma.scimResourceMap.findFirst({
    where: { orgId, resourceType: 'User', scimId }
  });

  if (!map) return;

  await prisma.orgMembership.updateMany({
    where: { orgId, userId: map.localId },
    data: { isDisabled: true }
  });
}

export async function recordScimAudit(params: {
  orgId: string;
  resourceType: 'User' | 'Group';
  scimId?: string;
  localId?: string;
  action: 'create' | 'update' | 'delete';
  status: 'success' | 'failed';
  reason?: string;
  rawPayload?: any;
}) {
  await prisma.scimAudit.create({
    data: {
      orgId: params.orgId,
      resourceType: params.resourceType,
      scimId: params.scimId ?? null,
      localId: params.localId ?? null,
      action: params.action,
      status: params.status,
      reason: params.reason ?? null,
      rawPayload: params.rawPayload ?? null
    }
  });
}
```

> Group handling can be implemented similarly, mapping SCIM groups to logical `OrgGroup` or role sets. For brevity, we focus on Users as the critical path.

---

## 49.6. SCIM Routes – Users

We expose SCIM 2.0 endpoints under `/scim/:orgSlug/v2/Users`.

**File:** `apps/api-gateway/src/routes/scimUsers.ts`

```ts
// apps/api-gateway/src/routes/scimUsers.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { authenticateScimRequest } from '../scim/scimAuth';
import {
  createOrUpdateUserFromScim,
  deactivateUserFromScim,
  recordScimAudit,
  getLocalUserIdByScimId
} from '../scim/scimService';

export default async function scimUsersRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // List users (basic pagination)
  app.get('/scim/:orgSlug/v2/Users', async (req, reply) => {
    const { orgSlug } = req.params as any;

    try {
      const { orgId } = await authenticateScimRequest(orgSlug, req.headers.authorization);

      const users = await prisma.orgMembership.findMany({
        where: { orgId },
        include: { user: true },
        take: 200
      });

      const resources = users.map((m) => ({
        id: m.userId,
        userName: m.user.email,
        active: !m.isDisabled,
        emails: [{ value: m.user.email, primary: true }],
        displayName: m.user.name
      }));

      return reply.send({
        totalResults: resources.length,
        Resources: resources,
        itemsPerPage: resources.length,
        startIndex: 1,
        schemas: ['urn:ietf:params:scim:api:messages:2.0:ListResponse']
      });
    } catch (err: any) {
      return reply.code(401).send({
        schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
        detail: 'Unauthorized',
        status: '401'
      });
    }
  });

  // Create user
  app.post('/scim/:orgSlug/v2/Users', async (req, reply) => {
    const { orgSlug } = req.params as any;
    const body = req.body as any;

    try {
      const { orgId } = await authenticateScimRequest(orgSlug, req.headers.authorization);

      const scimId = body.id || body.externalId || body.userName;
      const attrs = {
        userName: body.userName,
        active: body.active,
        emails: body.emails,
        name: body.name,
        displayName: body.displayName
      };

      const userId = await createOrUpdateUserFromScim(orgId, scimId, attrs);

      await recordScimAudit({
        orgId,
        resourceType: 'User',
        scimId,
        localId: userId,
        action: 'create',
        status: 'success',
        rawPayload: body
      });

      const user = await prisma.user.findUnique({ where: { id: userId } });

      return reply.code(201).send({
        id: scimId,
        userName: attrs.userName,
        active: attrs.active !== false,
        emails: attrs.emails,
        displayName: user?.name,
        schemas: ['urn:ietf:params:scim:schemas:core:2.0:User']
      });
    } catch (err: any) {
      const statusCode = err?.message === 'SEAT_LIMIT_EXCEEDED' ? 409 : 400;
      const detail = err?.message === 'SEAT_LIMIT_EXCEEDED'
        ? 'Seat limit exceeded for this organization.'
        : 'Failed to create user.';

      return reply.code(statusCode).send({
        schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
        detail,
        status: String(statusCode)
      });
    }
  });

  // Update user (PUT)
  app.put('/scim/:orgSlug/v2/Users/:id', async (req, reply) => {
    const { orgSlug, id } = req.params as any;
    const body = req.body as any;

    try {
      const { orgId } = await authenticateScimRequest(orgSlug, req.headers.authorization);

      const scimId = id as string;
      const attrs = {
        userName: body.userName,
        active: body.active,
        emails: body.emails,
        name: body.name,
        displayName: body.displayName
      };

      const userId = await createOrUpdateUserFromScim(orgId, scimId, attrs);

      await recordScimAudit({
        orgId,
        resourceType: 'User',
        scimId,
        localId: userId,
        action: 'update',
        status: 'success',
        rawPayload: body
      });

      const user = await prisma.user.findUnique({ where: { id: userId } });

      return reply.send({
        id: scimId,
        userName: attrs.userName,
        active: attrs.active !== false,
        emails: attrs.emails,
        displayName: user?.name,
        schemas: ['urn:ietf:params:scim:schemas:core:2.0:User']
      });
    } catch (err: any) {
      return reply.code(400).send({
        schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
        detail: 'Failed to update user.',
        status: '400'
      });
    }
  });

  // Deactivate / delete user
  app.delete('/scim/:orgSlug/v2/Users/:id', async (req, reply) => {
    const { orgSlug, id } = req.params as any;

    try {
      const { orgId } = await authenticateScimRequest(orgSlug, req.headers.authorization);

      const scimId = id as string;
      const localId = await getLocalUserIdByScimId(orgId, scimId);

      await deactivateUserFromScim(orgId, scimId);

      await recordScimAudit({
        orgId,
        resourceType: 'User',
        scimId,
        localId: localId ?? undefined,
        action: 'delete',
        status: 'success'
      });

      return reply.code(204).send();
    } catch (err: any) {
      return reply.code(400).send({
        schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
        detail: 'Failed to delete user.',
        status: '400'
      });
    }
  });
}
```

Register in `main.ts`:

```ts
import scimUsersRoutes from './routes/scimUsers';

await app.register(scimUsersRoutes);
```

---

## 49.7. Groups (Outline)

Full SCIM group support can be added similarly:

- Data model: `OrgGroup` + `OrgGroupMember` or reuse roles.  
- SCIM mapping: `ScimResourceMap` with `resourceType = 'Group'`.  
- Routes: `/scim/:orgSlug/v2/Groups` (GET/POST/PUT/PATCH/DELETE).  
- Logic: group `members` array drives membership creation/activation/deactivation and possibly role assignments.

This is optional but easy to add on top of the existing abstraction.

---

## 49.8. Observability & Metrics

Use `ScimAudit` as the primary source of truth for provisioning operations.

- Emit events (38.md):
  - `scim.user.created`, `scim.user.updated`, `scim.user.deleted`.  
  - `scim.seat_limit_exceeded` when `SEAT_LIMIT_EXCEEDED` is thrown.  
  - `scim.connection.updated` when SCIM connection is created/updated/rotated.
- Metrics (28.md):
  - `scim_requests_total{orgId,resourceType,action,status}`.  
  - `scim_provisioned_users_total{orgId}`.  
  - `scim_seat_limit_rejections_total{orgId}`.

Grafana panelleri:

- SCIM istek sayısı (başarılı / hatalı).  
- Zaman içindeki toplam provisioned user sayısı.  
- Seat limit’e takılan girişim sayısı.

---

## 49.9. Sanity Checklist

Before enabling SCIM for customers:

- [ ] Prisma migration applied for `ScimConnection`, `ScimResourceMap`, `ScimAudit`.  
- [ ] SCIM connection admin API works and bearer token can be rotated.  
- [ ] `/scim/:orgSlug/v2/Users` endpoints return valid SCIM 2.0 responses (tested with at least one IdP).  
- [ ] Seat limits are enforced when provisioning users via SCIM.  
- [ ] `ScimAudit` records appear for create/update/delete.  
- [ ] Metrics are visible in Prometheus/Grafana.  
- [ ] Failure paths (invalid token, invalid orgSlug, seat limit exceeded) return SCIM error objects.

If all items pass, the platform now supports **SCIM 2.0 user provisioning**, tightly integrated with **seat‑based licensing**, **RBAC** and **observability**, making it suitable for large enterprise deployments.

---

_End of 49.md – SCIM 2.0 User & Group Provisioning – Directory Sync & Deprovisioning_
