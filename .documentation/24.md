# 24. Per‑Conversation Settings Drawer (Model, Temperature, System Prompt & Tools)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Add a **per‑conversation settings drawer** that makes each chat configurable, similar to advanced ChatGPT features:
>
> - Data model: store per‑conversation **model**, **temperature**, **system prompt**, and **tool flags**.  
> - Backend: APIs to **read/update** conversation settings.  
> - Frontend API: typed client for conversation settings.  
> - Frontend UI: a **Material 3 / Grafana‑styled drawer** attached to ChatPage header.
>
> After this file, each conversation can have its own model + behavior, and users can adjust them in a modern, interactive UI without leaving the chat.

> **Important instructions to AI agents:**
> - Treat this file as canonical for **per‑conversation settings**.  
> - Do **not** change quota enforcement (19.md) or analytics (18.md); they keep working transparently.  
> - All code must be complete and compilable; no TODOs / stubs.

---

## 24.1. Data Model – Conversation Settings

We extend the `Conversation` model to store:

- `model`: the default model name used by this conversation (already present in 22.md; we will keep using it).  
- `temperature`: optional float; defaults to `0.7`.  
- `systemPrompt`: optional, longer text field; per‑conversation system instructions.  
- `toolsEnabled`: JSON field with booleans for features like tools / code‑runner / web search (we keep it minimal but extensible).

### 24.1.1. Update `packages/db/prisma/schema.prisma`

Locate the `Conversation` model and add (or adjust) the following fields:

```prisma
model Conversation {
  id        String   @id @default(cuid())

  orgId     String?
  org       Org?     @relation(fields: [orgId], references: [id])

  ownerId   String

  title     String   @default("New chat")

  lastActivityAt DateTime @default(now())
  archivedAt     DateTime?
  pinned         Boolean  @default(false)

  /// Default model key for this conversation (e.g. "gpt-4.1", "ollama:llama3")
  model          String   @default("default")

  /// Temperature (0–2 range). If null, use system default (e.g. 0.7)
  temperature    Float?   @default(0.7)

  /// Optional per‑conversation system prompt / instructions
  systemPrompt   String?  @db.Text

  /// Structured feature flags (e.g. tools, web search). Kept flexible for future extensions.
  toolsEnabled   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // messages Message[]
}
```

> If `temperature`, `systemPrompt` or `toolsEnabled` already exist, keep them; ensure their types match the above.  
> If your database requires a different JSON type annotation (e.g. `@db.Json`), adjust accordingly.

Run the migration:

```bash
cd packages/db
pnpm prisma migrate dev --name add_conversation_settings_fields
cd ../..
```

---

## 24.2. Backend – Conversation Settings API

We add an endpoint to **fetch and update** per‑conversation settings:

- `GET /conversations/:id/settings`  
- `PATCH /conversations/:id/settings`

Permissions:

- User must have access to the conversation’s org (`chat:use`), same as in 22.md.

### 24.2.1. Create `apps/api-gateway/src/routes/conversationSettings.ts`

```ts
// apps/api-gateway/src/routes/conversationSettings.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';
import { assertOrgPermission } from '../rbac/guards';

const paramsSchema = z.object({ id: z.string().min(1) });

const patchBodySchema = z.object({
  model: z.string().min(1).max(200).optional(),
  temperature: z
    .number()
    .min(0)
    .max(2)
    .optional(),
  systemPrompt: z.string().max(20000).nullable().optional(),
  toolsEnabled: z
    .object({
      codeExecution: z.boolean().optional(),
      webSearch: z.boolean().optional(),
      structuredTools: z.boolean().optional()
    })
    .partial()
    .optional()
});

export default async function conversationSettingsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // Get settings for a conversation
  app.get('/conversations/:id/settings', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parsedParams = paramsSchema.safeParse(request.params);
    if (!parsedParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }

    const conversationId = parsedParams.data.id;

    const convo = await prisma.conversation.findUnique({
      where: { id: conversationId },
      select: {
        id: true,
        orgId: true,
        model: true,
        temperature: true,
        systemPrompt: true,
        toolsEnabled: true
      }
    });

    if (!convo) {
      return reply.code(404).send({ error: 'NOT_FOUND', message: 'Conversation not found.' });
    }

    if (convo.orgId) {
      await assertOrgPermission(
        { id: payload.userId, isSuperadmin: payload.isSuperadmin },
        convo.orgId,
        'chat:use'
      );
    }

    return reply.send({
      id: convo.id,
      model: convo.model,
      temperature: convo.temperature ?? 0.7,
      systemPrompt: convo.systemPrompt ?? null,
      toolsEnabled: (convo.toolsEnabled as any) ?? {}
    });
  });

  // Update settings for a conversation
  app.patch('/conversations/:id/settings', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parsedParams = paramsSchema.safeParse(request.params);
    if (!parsedParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }

    const conversationId = parsedParams.data.id;

    const convo = await prisma.conversation.findUnique({
      where: { id: conversationId },
      select: {
        id: true,
        orgId: true,
        toolsEnabled: true
      }
    });

    if (!convo) {
      return reply.code(404).send({ error: 'NOT_FOUND', message: 'Conversation not found.' });
    }

    if (convo.orgId) {
      await assertOrgPermission(
        { id: payload.userId, isSuperadmin: payload.isSuperadmin },
        convo.orgId,
        'chat:use'
      );
    }

    const parsedBody = patchBodySchema.safeParse(request.body);
    if (!parsedBody.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsedBody.error.format() });
    }

    const { model, temperature, systemPrompt, toolsEnabled } = parsedBody.data;

    const data: any = {};

    if (typeof model === 'string') {
      data.model = model.trim();
    }

    if (typeof temperature === 'number') {
      data.temperature = temperature;
    }

    if (systemPrompt !== undefined) {
      data.systemPrompt = systemPrompt && systemPrompt.trim() ? systemPrompt : null;
    }

    if (toolsEnabled) {
      const existing = (convo.toolsEnabled as any) || {};
      data.toolsEnabled = {
        ...existing,
        ...toolsEnabled
      };
    }

    const updated = await prisma.conversation.update({
      where: { id: conversationId },
      data,
      select: {
        id: true,
        model: true,
        temperature: true,
        systemPrompt: true,
        toolsEnabled: true
      }
    });

    return reply.send({
      id: updated.id,
      model: updated.model,
      temperature: updated.temperature ?? 0.7,
      systemPrompt: updated.systemPrompt ?? null,
      toolsEnabled: (updated.toolsEnabled as any) ?? {}
    });
  });
}
```

### 24.2.2. Register route in `apps/api-gateway/src/main.ts`

Add import:

```ts
import conversationSettingsRoutes from './routes/conversationSettings';
```

Register plugin alongside other routes:

```ts
await app.register(conversationSettingsRoutes);
```

---

## 24.3. Frontend API – Conversation Settings Client

We add a typed client for the new settings endpoints.

### 24.3.1. Create `apps/web/src/api/conversationSettings.ts`

```ts
// apps/web/src/api/conversationSettings.ts

import { apiRequest } from './client';

export interface ConversationToolsEnabled {
  codeExecution?: boolean;
  webSearch?: boolean;
  structuredTools?: boolean;
}

export interface ConversationSettings {
  id: string;
  model: string;
  temperature: number;
  systemPrompt: string | null;
  toolsEnabled: ConversationToolsEnabled;
}

export interface UpdateConversationSettingsPayload {
  model?: string;
  temperature?: number;
  systemPrompt?: string | null;
  toolsEnabled?: ConversationToolsEnabled;
}

export async function getConversationSettings(
  token: string,
  conversationId: string
): Promise<ConversationSettings> {
  return apiRequest<ConversationSettings>(
    `/conversations/${conversationId}/settings`,
    { method: 'GET' },
    token
  );
}

export async function updateConversationSettings(
  token: string,
  conversationId: string,
  payload: UpdateConversationSettingsPayload
): Promise<ConversationSettings> {
  return apiRequest<ConversationSettings>(
    `/conversations/${conversationId}/settings`,
    {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    },
    token
  );
}
```

---

## 24.4. Frontend UI – Settings Drawer Component

We add a settings drawer that can slide from the **right** in the chat layout.

Behavior:

- Trigger: a **"Settings"** / gear icon in the ChatPage header.  
- Shows:
  - Model select.  
  - Temperature slider.  
  - System prompt textarea.  
  - Tool toggles (code execution, web search, structured tools).  
- Persists settings via `updateConversationSettings`.  
- Reflects in chat logic (e.g. which model to call, which tools to enable) – the low‑level usage is handled in earlier chat backend files; here we focus on UI + data.

### 24.4.1. Create `apps/web/src/chat/ConversationSettingsDrawer.tsx`

```tsx
// apps/web/src/chat/ConversationSettingsDrawer.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Divider,
  Drawer,
  FormControlLabel,
  IconButton,
  Slider,
  Switch,
  TextField,
  Typography
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { useAuth } from '../auth/AuthContext';
import {
  ConversationSettings,
  UpdateConversationSettingsPayload,
  getConversationSettings,
  updateConversationSettings
} from '../api/conversationSettings';

export interface ConversationSettingsDrawerProps {
  open: boolean;
  onClose: () => void;
  conversationId: string | null;
}

const marks = [
  { value: 0, label: '0.0' },
  { value: 0.7, label: '0.7' },
  { value: 1.0, label: '1.0' },
  { value: 1.5, label: '1.5' },
  { value: 2.0, label: '2.0' }
];

export const ConversationSettingsDrawer: React.FC<ConversationSettingsDrawerProps> = ({
  open,
  onClose,
  conversationId
}) => {
  const { token } = useAuth();

  const [settings, setSettings] = useState<ConversationSettings | null>(null);
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [model, setModel] = useState('default');
  const [temperature, setTemperature] = useState(0.7);
  const [systemPrompt, setSystemPrompt] = useState('');
  const [codeExecution, setCodeExecution] = useState(false);
  const [webSearch, setWebSearch] = useState(false);
  const [structuredTools, setStructuredTools] = useState(false);

  useEffect(() => {
    if (!open || !conversationId || !token) {
      return;
    }

    let cancelled = false;

    async function load() {
      setLoading(true);
      setError(null);
      try {
        const data = await getConversationSettings(token, conversationId);
        if (cancelled) return;
        setSettings(data);
        setModel(data.model);
        setTemperature(data.temperature ?? 0.7);
        setSystemPrompt(data.systemPrompt ?? '');
        setCodeExecution(Boolean(data.toolsEnabled?.codeExecution));
        setWebSearch(Boolean(data.toolsEnabled?.webSearch));
        setStructuredTools(Boolean(data.toolsEnabled?.structuredTools));
      } catch (err) {
        if (cancelled) return;
        setError((err as Error).message || 'Failed to load conversation settings');
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    void load();

    return () => {
      cancelled = true;
    };
  }, [open, conversationId, token]);

  const handleSave = async () => {
    if (!token || !conversationId) return;

    const payload: UpdateConversationSettingsPayload = {
      model,
      temperature,
      systemPrompt: systemPrompt.trim() ? systemPrompt : null,
      toolsEnabled: {
        codeExecution,
        webSearch,
        structuredTools
      }
    };

    setSaving(true);
    setError(null);
    try {
      const updated = await updateConversationSettings(token, conversationId, payload);
      setSettings(updated);
    } catch (err) {
      setError((err as Error).message || 'Failed to update conversation settings');
    } finally {
      setSaving(false);
    }
  };

  return (
    <Drawer anchor="right" open={open} onClose={onClose} PaperProps={{ sx: { width: 360 } }}>
      <Box
        sx={{
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          background:
            'radial-gradient(circle at top left, rgba(124,77,255,0.16), transparent 55%), radial-gradient(circle at bottom right, rgba(3,218,198,0.12), transparent 55%)'
        }}
      >
        <Box display="flex" alignItems="center" justifyContent="space-between" px={2} py={1.5}>
          <Box>
            <Typography variant="subtitle1">Conversation settings</Typography>
            <Typography variant="caption" color="text.secondary">
              Tune model behavior for this chat.
            </Typography>
          </Box>
          <IconButton size="small" onClick={onClose}>
            <CloseIcon fontSize="small" />
          </IconButton>
        </Box>

        <Divider />

        <Box flex={1} overflow="auto" px={2} py={2}>
          {error && (
            <Typography variant="caption" color="error" display="block" mb={1}>
              {error}
            </Typography>
          )}

          {/* Model */}
          <Box mb={2}>
            <Typography variant="subtitle2" gutterBottom>
              Model
            </Typography>
            <TextField
              fullWidth
              size="small"
              label="Model key"
              value={model}
              onChange={(e) => setModel(e.target.value)}
              helperText="For example: gpt-4.1, ollama:llama3, local:my-model"
            />
          </Box>

          {/* Temperature */}
          <Box mb={2}>
            <Typography variant="subtitle2" gutterBottom>
              Temperature
            </Typography>
            <Typography variant="caption" color="text.secondary">
              Lower = more deterministic. Higher = more creative.
            </Typography>
            <Slider
              value={temperature}
              onChange={(_, value) => {
                if (typeof value === 'number') {
                  setTemperature(value);
                }
              }}
              min={0}
              max={2}
              step={0.1}
              marks={marks}
              sx={{ mt: 1.5 }}
            />
          </Box>

          {/* System prompt */}
          <Box mb={2}>
            <Typography variant="subtitle2" gutterBottom>
              System instructions
            </Typography>
            <Typography variant="caption" color="text.secondary">
              Optional high‑level instructions that guide the assistant in this conversation.
            </Typography>
            <TextField
              fullWidth
              multiline
              minRows={4}
              maxRows={10}
              value={systemPrompt}
              onChange={(e) => setSystemPrompt(e.target.value)}
              placeholder="You are an expert Node.js engineer helping with an Ollama‑backed chat system..."
              sx={{ mt: 1 }}
            />
          </Box>

          {/* Tools */}
          <Box mb={1}>
            <Typography variant="subtitle2" gutterBottom>
              Tools & integrations
            </Typography>
            <FormControlLabel
              control={
                <Switch
                  checked={codeExecution}
                  onChange={(e) => setCodeExecution(e.target.checked)}
                />
              }
              label="Code execution / sandbox"
            />
            <FormControlLabel
              control={
                <Switch
                  checked={webSearch}
                  onChange={(e) => setWebSearch(e.target.checked)}
                />
              }
              label="Web search / external knowledge"
            />
            <FormControlLabel
              control={
                <Switch
                  checked={structuredTools}
                  onChange={(e) => setStructuredTools(e.target.checked)}
                />
              }
              label="Structured tools (functions, agents)"
            />
          </Box>
        </Box>

        <Divider />

        <Box px={2} py={1.5} display="flex" justifyContent="space-between" alignItems="center">
          <Typography variant="caption" color="text.secondary">
            Changes take effect the next time you send a message.
          </Typography>
          <Button
            variant="contained"
            size="small"
            onClick={handleSave}
            disabled={saving || !conversationId}
          >
            {saving ? 'Saving…' : 'Save'}
          </Button>
        </Box>
      </Box>
    </Drawer>
  );
};
```

---

## 24.5. Frontend – Integrate Drawer into ChatPage

We integrate the drawer into the Chat UI header.

> **Assumption:** `ChatPage` from 21.md already renders a header and uses `conversationId` and `orgId` from route params.

### 24.5.1. Update `apps/web/src/chat/ChatPage.tsx` Header

In `ChatPage.tsx`, import the drawer and add a **settings icon** to the header.

Add imports at the top:

```tsx
import SettingsIcon from '@mui/icons-material/Settings';
import { ConversationSettingsDrawer } from './ConversationSettingsDrawer';
```

Inside the component, add local state:

```tsx
const [settingsOpen, setSettingsOpen] = React.useState(false);
```

Update the header section to include a settings button, e.g. replace the simple header from 21.md with:

```tsx
<Box display="flex" alignItems="center" justifyContent="space-between" mb={1}>
  <Typography variant="h6">Conversation</Typography>
  <IconButton size="small" onClick={() => setSettingsOpen(true)}>
    <SettingsIcon fontSize="small" />
  </IconButton>
</Box>
```

Finally, render the drawer at the bottom of `ChatPage` JSX (inside the root `Box`):

```tsx
<ConversationSettingsDrawer
  open={settingsOpen}
  onClose={() => setSettingsOpen(false)}
  conversationId={conversationId ?? null}
/>
```

This keeps the drawer mounted alongside the chat and uses the current `conversationId`.

---

## 24.6. Sanity Checks

From the repo root:

1. **Migrate DB:**

   ```bash
   cd packages/db
   pnpm prisma migrate dev --name add_conversation_settings_fields
   cd ../..
   ```

2. **Run API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

   - Test `GET /conversations/:id/settings` with a valid token.  
   - Test `PATCH /conversations/:id/settings` with various payloads (model, temperature, systemPrompt, toolsEnabled).

3. **Run web app:**

   ```bash
   cd apps/web
   pnpm dev
   ```

   - Navigate to `/app/orgs/<orgId>/chat/<conversationId>`.  
   - Click the **Settings** icon in the chat header.  
   - Verify that:
     - Drawer loads current model, temperature, system instructions and tool toggles.  
     - Changing values and clicking **Save** persists the data (confirmed via reload or new browser tab).  
     - Changes take effect on subsequent chat messages according to your backend’s model/tool selection logic.

If all checks pass, your AI chat app now supports **per‑conversation behavior tuning**: each chat can behave differently, use different models, and have distinct system prompts and tools, all exposed via a modern Material 3 / Grafana‑flavored settings drawer.

---

_End of 24.md – Per‑Conversation Settings Drawer (Model, Temperature, System Prompt & Tools)_
