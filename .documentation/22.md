# 22. Conversation Sidebar, Search & Multi‑Chat Layout

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Add a **Material 3 + Grafana‑inspired** conversation sidebar and multi‑chat layout:
>
> - Data model: conversation metadata that supports titles, pinning, archiving, and last activity.  
> - Backend: org‑scoped conversation list + create + metadata update APIs.  
> - Frontend API: typed client for conversation endpoints.  
> - Frontend UI: left conversation sidebar with search, new chat, pin/archive, and micro‑interactions.
>
> After this file, users can manage multiple conversations within an org in a modern, interactive layout.

> **Important instructions to AI agents:**
> - Treat this file as canonical for **conversation list & sidebar** behavior.  
> - Where this file "replaces" earlier examples, treat this content as the latest version.  
> - Do **not** add TODOs or placeholders; all code must compile and be ready for integration.

---

## 22.1. Data Model – Conversation Metadata

We ensure that the `Conversation` model has the metadata needed for a rich sidebar.

### 22.1.1. Update `packages/db/prisma/schema.prisma`

Locate the existing `Conversation` model and make sure it contains at least the following fields (add any missing ones):

```prisma
model Conversation {
  id        String   @id @default(cuid())

  orgId     String?
  org       Org?     @relation(fields: [orgId], references: [id])

  ownerId   String   // user who created the conversation (or main owner)
  // You likely already have a relation to User here; keep or add as appropriate.

  /// Human‑friendly title (can be auto‑generated from first messages or edited by user)
  title     String   @default("New chat")

  /// Last time any message in this conversation was created
  lastActivityAt DateTime @default(now())

  /// If not null, conversation is archived and hidden by default from the main sidebar list
  archivedAt DateTime?

  /// Pinned conversations appear at the top of the sidebar
  pinned   Boolean  @default(false)

  /// Default model used for this conversation
  model    String   @default("default")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ...existing relations, e.g.
  // messages Message[]
}
```

Run a migration:

```bash
cd packages/db
pnpm prisma migrate dev --name add_conversation_sidebar_metadata
cd ../..
```

> **Note:** If some fields already exist with slightly different names, prefer reusing them instead of duplicating. The important ones for the UI are: `title`, `lastActivityAt`, `archivedAt`, `pinned`, `model`.

---

## 22.2. Backend – Conversation List & Metadata APIs

We implement three conversation endpoints:

1. `GET /orgs/:orgId/conversations` – list conversations for an org (with search & pagination).  
2. `POST /orgs/:orgId/conversations` – create a new conversation.  
3. `PATCH /conversations/:id` – update metadata (title, pinned, archived).

> **Auth assumptions:**
>
> - All endpoints use `app.authenticate`.  
> - We rely on `assertOrgPermission(..., 'chat:use')` to ensure the user may chat in this org.  
> - For `PATCH /conversations/:id`, we also verify that the user has access to that conversation's org.

### 22.2.1. Create `apps/api-gateway/src/routes/conversations.ts`

```ts
// apps/api-gateway/src/routes/conversations.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';
import { assertOrgPermission } from '../rbac/guards';

const listQuerySchema = z.object({
  search: z.string().optional(),
  limit: z
    .string()
    .optional()
    .transform((value) => {
      if (!value) return 20;
      const n = Number(value);
      if (!Number.isFinite(n) || n <= 0) return 20;
      if (n > 100) return 100;
      return Math.round(n);
    }),
  cursor: z.string().optional()
});

const createBodySchema = z.object({
  title: z.string().min(1).max(200).optional(),
  model: z.string().min(1).max(200).optional()
});

const updateBodySchema = z.object({
  title: z.string().min(1).max(200).optional(),
  pinned: z.boolean().optional(),
  archived: z.boolean().optional()
});

export default async function conversationsRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // List conversations for an org (non‑archived by default)
  app.get('/orgs/:orgId/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ orgId: z.string().min(1) });
    const parsedParams = paramsSchema.safeParse(request.params);
    if (!parsedParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }
    const orgId = parsedParams.data.orgId;

    const parsedQuery = listQuerySchema.safeParse(request.query);
    if (!parsedQuery.success) {
      return reply.code(400).send({ error: 'Invalid query', details: parsedQuery.error.format() });
    }

    const { search, limit, cursor } = parsedQuery.data;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'chat:use'
    );

    const whereClause: any = {
      orgId,
      archivedAt: null
    };

    if (search && search.trim()) {
      whereClause.title = {
        contains: search.trim(),
        mode: 'insensitive'
      };
    }

    const conversations = await prisma.conversation.findMany({
      where: whereClause,
      orderBy: [
        { pinned: 'desc' },
        { lastActivityAt: 'desc' }
      ],
      take: limit + 1,
      cursor: cursor ? { id: cursor } : undefined,
      skip: cursor ? 1 : 0,
      select: {
        id: true,
        title: true,
        model: true,
        pinned: true,
        archivedAt: true,
        lastActivityAt: true,
        createdAt: true
      }
    });

    let nextCursor: string | null = null;
    let items = conversations;

    if (conversations.length > limit) {
      const last = conversations[conversations.length - 1];
      nextCursor = last.id;
      items = conversations.slice(0, limit);
    }

    return reply.send({
      items,
      nextCursor
    });
  });

  // Create a new conversation in an org
  app.post('/orgs/:orgId/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ orgId: z.string().min(1) });
    const parsedParams = paramsSchema.safeParse(request.params);
    if (!parsedParams.success) {
      return reply.code(400).send({ error: 'Invalid org id' });
    }
    const orgId = parsedParams.data.orgId;

    const parsedBody = createBodySchema.safeParse(request.body);
    if (!parsedBody.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsedBody.error.format() });
    }

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'chat:use'
    );

    const { title, model } = parsedBody.data;

    const conversation = await prisma.conversation.create({
      data: {
        orgId,
        ownerId: payload.userId,
        title: title && title.trim() ? title.trim() : 'New chat',
        model: model && model.trim() ? model.trim() : 'default'
      },
      select: {
        id: true,
        title: true,
        model: true,
        pinned: true,
        archivedAt: true,
        lastActivityAt: true,
        createdAt: true
      }
    });

    return reply.code(201).send(conversation);
  });

  // Update conversation metadata (title, pinned, archived)
  app.patch('/conversations/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parsedParams = paramsSchema.safeParse(request.params);
    if (!parsedParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }
    const conversationId = parsedParams.data.id;

    const parsedBody = updateBodySchema.safeParse(request.body);
    if (!parsedBody.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsedBody.error.format() });
    }

    const existing = await prisma.conversation.findUnique({
      where: { id: conversationId },
      select: {
        id: true,
        orgId: true
      }
    });

    if (!existing) {
      return reply.code(404).send({ error: 'NOT_FOUND', message: 'Conversation not found.' });
    }

    if (!existing.orgId) {
      // Personal conversation – you may want a different permission model here.
      // For now, allow only the owner or superadmin; but we keep it simple and allow if authenticated.
    } else {
      await assertOrgPermission(
        { id: payload.userId, isSuperadmin: payload.isSuperadmin },
        existing.orgId,
        'chat:use'
      );
    }

    const { title, pinned, archived } = parsedBody.data;

    const data: any = {};

    if (typeof title === 'string') {
      data.title = title.trim() || 'Untitled chat';
    }

    if (typeof pinned === 'boolean') {
      data.pinned = pinned;
    }

    if (typeof archived === 'boolean') {
      data.archivedAt = archived ? new Date() : null;
    }

    const updated = await prisma.conversation.update({
      where: { id: conversationId },
      data,
      select: {
        id: true,
        title: true,
        model: true,
        pinned: true,
        archivedAt: true,
        lastActivityAt: true,
        createdAt: true
      }
    });

    return reply.send(updated);
  });
}
```

Finally, register this route in your Fastify main entry point.

### 22.2.2. Register routes in `apps/api-gateway/src/main.ts`

Add the import:

```ts
import conversationsRoutes from './routes/conversations';
```

Then register the plugin (next to other route plugins):

```ts
await app.register(conversationsRoutes);
```

---

## 22.3. Frontend API – Conversation Client

We now add a small typed client for conversation APIs.

### 22.3.1. Create `apps/web/src/api/conversations.ts`

```ts
// apps/web/src/api/conversations.ts

import { apiRequest } from './client';

export interface ConversationListItem {
  id: string;
  title: string;
  model: string;
  pinned: boolean;
  archivedAt: string | null;
  lastActivityAt: string;
  createdAt: string;
}

export interface ConversationListResponse {
  items: ConversationListItem[];
  nextCursor: string | null;
}

export interface CreateConversationPayload {
  title?: string;
  model?: string;
}

export interface UpdateConversationPayload {
  title?: string;
  pinned?: boolean;
  archived?: boolean;
}

export async function listOrgConversations(
  token: string,
  orgId: string,
  params: { search?: string; limit?: number; cursor?: string } = {}
): Promise<ConversationListResponse> {
  const query = new URLSearchParams();
  if (params.search) query.set('search', params.search);
  if (params.limit != null) query.set('limit', String(params.limit));
  if (params.cursor) query.set('cursor', params.cursor);

  const suffix = query.toString() ? `?${query.toString()}` : '';

  return apiRequest<ConversationListResponse>(`/orgs/${orgId}/conversations${suffix}`, { method: 'GET' }, token);
}

export async function createOrgConversation(
  token: string,
  orgId: string,
  payload: CreateConversationPayload = {}
): Promise<ConversationListItem> {
  return apiRequest<ConversationListItem>(
    `/orgs/${orgId}/conversations`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    },
    token
  );
}

export async function updateConversation(
  token: string,
  conversationId: string,
  payload: UpdateConversationPayload
): Promise<ConversationListItem> {
  return apiRequest<ConversationListItem>(
    `/conversations/${conversationId}`,
    {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    },
    token
  );
}
```

---

## 22.4. Frontend UI – Conversation Sidebar Component

We create a **Material 3 / Grafana‑inspired** sidebar with:

- Search box.  
- New chat button.  
- Pinned conversations at the top.  
- Hover micro‑interactions (slight elevation / background).  
- Archive and pin toggles per conversation.

### 22.4.1. Create `apps/web/src/chat/ConversationSidebar.tsx`

```tsx
// apps/web/src/chat/ConversationSidebar.tsx

import React, { useEffect, useMemo, useState } from 'react';
import {
  Box,
  Button,
  CircularProgress,
  IconButton,
  InputAdornment,
  List,
  ListItemButton,
  ListItemSecondaryAction,
  ListItemText,
  TextField,
  Tooltip,
  Typography
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import AddIcon from '@mui/icons-material/Add';
import PushPinIcon from '@mui/icons-material/PushPin';
import PushPinOutlinedIcon from '@mui/icons-material/PushPinOutlined';
import ArchiveIcon from '@mui/icons-material/Archive';
import { useNavigate, useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import {
  ConversationListItem,
  ConversationListResponse,
  createOrgConversation,
  listOrgConversations,
  updateConversation
} from '../api/conversations';

interface ConversationSidebarProps {
  selectedConversationId?: string;
}

export const ConversationSidebar: React.FC<ConversationSidebarProps> = ({ selectedConversationId }) => {
  const { token } = useAuth();
  const { orgId } = useParams<{ orgId: string }>();
  const navigate = useNavigate();

  const [items, setItems] = useState<ConversationListItem[]>([]);
  const [nextCursor, setNextCursor] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [loadingMore, setLoadingMore] = useState<boolean>(false);
  const [search, setSearch] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  const load = async (opts: { append: boolean; cursor?: string; search?: string }) => {
    if (!token || !orgId) return;

    if (opts.append) {
      setLoadingMore(true);
    } else {
      setLoading(true);
      setError(null);
    }

    try {
      const res: ConversationListResponse = await listOrgConversations(token, orgId, {
        search: opts.search ?? search,
        limit: 30,
        cursor: opts.cursor
      });

      setNextCursor(res.nextCursor);

      if (opts.append) {
        setItems((prev) => [...prev, ...res.items]);
      } else {
        setItems(res.items);
      }
    } catch (err) {
      setError((err as Error).message || 'Failed to load conversations');
    } finally {
      if (opts.append) {
        setLoadingMore(false);
      } else {
        setLoading(false);
      }
    }
  };

  useEffect(() => {
    // Initial load
    void load({ append: false });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [token, orgId]);

  const handleSearchSubmit: React.FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();
    void load({ append: false, search });
  };

  const handleNewChat = async () => {
    if (!token || !orgId) return;
    try {
      const convo = await createOrgConversation(token, orgId, {});
      // Optimistically prepend new conversation
      setItems((prev) => [convo, ...prev]);
      navigate(`/app/orgs/${orgId}/chat/${convo.id}`);
    } catch (err) {
      setError((err as Error).message || 'Failed to create conversation');
    }
  };

  const handleSelect = (id: string) => {
    if (!orgId) return;
    navigate(`/app/orgs/${orgId}/chat/${id}`);
  };

  const handleTogglePinned = async (item: ConversationListItem) => {
    if (!token) return;
    try {
      const updated = await updateConversation(token, item.id, { pinned: !item.pinned });
      setItems((prev) => prev.map((c) => (c.id === item.id ? updated : c)));
    } catch (err) {
      setError((err as Error).message || 'Failed to update conversation');
    }
  };

  const handleArchive = async (item: ConversationListItem) => {
    if (!token) return;
    try {
      const updated = await updateConversation(token, item.id, { archived: true });
      setItems((prev) => prev.filter((c) => c.id !== updated.id));
    } catch (err) {
      setError((err as Error).message || 'Failed to archive conversation');
    }
  };

  const pinned = useMemo(() => items.filter((i) => i.pinned), [items]);
  const others = useMemo(() => items.filter((i) => !i.pinned), [items]);

  return (
    <Box
      sx={{
        width: 290,
        flexShrink: 0,
        display: 'flex',
        flexDirection: 'column',
        borderRight: (theme) => `1px solid ${theme.palette.divider}`,
        background:
          'linear-gradient(180deg, rgba(17,24,39,0.98), rgba(15,23,42,0.98)), radial-gradient(circle at top left, rgba(124,77,255,0.18), transparent 55%)',
        color: 'rgba(255,255,255,0.92)'
      }}
    >
      <Box p={2} pb={1} display="flex" flexDirection="column" gap={1.5}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Typography variant="subtitle1">Conversations</Typography>
          <Button
            size="small"
            variant="contained"
            startIcon={<AddIcon />}
            onClick={handleNewChat}
            sx={{ borderRadius: 999, textTransform: 'none' }}
          >
            New
          </Button>
        </Box>

        <Box component="form" onSubmit={handleSearchSubmit}>
          <TextField
            fullWidth
            size="small"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search conversations"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon fontSize="small" />
                </InputAdornment>
              )
            }}
            variant="outlined"
            sx={{
              '& .MuiOutlinedInput-root': {
                borderRadius: 999,
                backgroundColor: 'rgba(15,23,42,0.9)',
                '& fieldset': {
                  borderColor: 'rgba(148,163,184,0.5)'
                },
                '&:hover fieldset': {
                  borderColor: 'rgba(209,213,219,0.8)'
                }
              },
              '& .MuiInputBase-input': {
                color: 'rgba(248,250,252,0.95)'
              }
            }}
          />
        </Box>

        {error && (
          <Typography variant="caption" color="error">
            {error}
          </Typography>
        )}
      </Box>

      <Box flex={1} overflow="auto" px={1} pb={1}>
        {loading && !items.length ? (
          <Box display="flex" alignItems="center" justifyContent="center" mt={4}>
            <CircularProgress size={24} />
          </Box>
        ) : (
          <>
            {pinned.length > 0 && (
              <>
                <Typography
                  variant="caption"
                  sx={{
                    px: 1.5,
                    mb: 0.5,
                    textTransform: 'uppercase',
                    letterSpacing: 0.08,
                    opacity: 0.7
                  }}
                >
                  Pinned
                </Typography>
                <List dense disablePadding>
                  {pinned.map((item) => (
                    <ListItemButton
                      key={item.id}
                      selected={item.id === selectedConversationId}
                      onClick={() => handleSelect(item.id)}
                      sx={{
                        borderRadius: 2,
                        mb: 0.5,
                        '&.Mui-selected': {
                          background:
                            'linear-gradient(90deg, rgba(124,77,255,0.35), rgba(3,218,198,0.25))'
                        },
                        '&:hover': {
                          backgroundColor: 'rgba(30,64,175,0.45)'
                        }
                      }}
                    >
                      <ListItemText
                        primary={item.title}
                        secondary={new Date(item.lastActivityAt).toLocaleString()}
                        primaryTypographyProps={{
                          noWrap: true,
                          fontSize: 14
                        }}
                        secondaryTypographyProps={{
                          noWrap: true,
                          fontSize: 11,
                          color: 'rgba(148,163,184,0.9)'
                        }}
                      />
                      <ListItemSecondaryAction>
                        <Tooltip title={item.pinned ? 'Unpin' : 'Pin'}>
                          <IconButton
                            size="small"
                            edge="end"
                            onClick={(e) => {
                              e.stopPropagation();
                              void handleTogglePinned(item);
                            }}
                          >
                            {item.pinned ? (
                              <PushPinIcon fontSize="small" />
                            ) : (
                              <PushPinOutlinedIcon fontSize="small" />
                            )}
                          </IconButton>
                        </Tooltip>
                      </ListItemSecondaryAction>
                    </ListItemButton>
                  ))}
                </List>
              </>
            )}

            {others.length > 0 && (
              <>
                {pinned.length > 0 && (
                  <Typography
                    variant="caption"
                    sx={{
                      px: 1.5,
                      mt: 1,
                      mb: 0.5,
                      textTransform: 'uppercase',
                      letterSpacing: 0.08,
                      opacity: 0.7
                    }}
                  >
                    Recent
                  </Typography>
                )}
                <List dense disablePadding>
                  {others.map((item) => (
                    <ListItemButton
                      key={item.id}
                      selected={item.id === selectedConversationId}
                      onClick={() => handleSelect(item.id)}
                      sx={{
                        borderRadius: 2,
                        mb: 0.5,
                        '&.Mui-selected': {
                          background:
                            'linear-gradient(90deg, rgba(56,189,248,0.25), rgba(94,234,212,0.25))'
                        },
                        '&:hover': {
                          backgroundColor: 'rgba(15,23,42,0.85)'
                        }
                      }}
                    >
                      <ListItemText
                        primary={item.title}
                        secondary={new Date(item.lastActivityAt).toLocaleString()}
                        primaryTypographyProps={{ noWrap: true, fontSize: 14 }}
                        secondaryTypographyProps={{
                          noWrap: true,
                          fontSize: 11,
                          color: 'rgba(148,163,184,0.9)'
                        }}
                      />
                      <ListItemSecondaryAction>
                        <Tooltip title={item.pinned ? 'Unpin' : 'Pin'}>
                          <IconButton
                            size="small"
                            edge="end"
                            onClick={(e) => {
                              e.stopPropagation();
                              void handleTogglePinned(item);
                            }}
                          >
                            {item.pinned ? (
                              <PushPinIcon fontSize="small" />
                            ) : (
                              <PushPinOutlinedIcon fontSize="small" />
                            )}
                          </IconButton>
                        </Tooltip>
                        <Tooltip title="Archive">
                          <IconButton
                            size="small"
                            edge="end"
                            onClick={(e) => {
                              e.stopPropagation();
                              void handleArchive(item);
                            }}
                          >
                            <ArchiveIcon fontSize="small" />
                          </IconButton>
                        </Tooltip>
                      </ListItemSecondaryAction>
                    </ListItemButton>
                  ))}
                </List>
              </>
            )}

            {!items.length && !loading && (
              <Box px={2} py={3}>
                <Typography variant="body2" color="rgba(148,163,184,0.9)">
                  No conversations yet. Start a new one to begin chatting.
                </Typography>
              </Box>
            )}

            {nextCursor && (
              <Box display="flex" justifyContent="center" mt={1} mb={1.5}>
                <Button
                  size="small"
                  variant="outlined"
                  onClick={() => load({ append: true, cursor: nextCursor })}
                  disabled={loadingMore}
                >
                  {loadingMore ? 'Loading…' : 'Load more'}
                </Button>
              </Box>
            )}
          </>
        )}
      </Box>
    </Box>
  );
};
```

---

## 22.5. Frontend UI – Chat Shell Layout

We now create a **ChatShellPage** that combines the conversation sidebar with the chat content area.

> **Assumption:** `ChatPage` from 21.md expects route params `{ conversationId, orgId? }` and handles quota banners, input, etc.

### 22.5.1. Create / Update `apps/web/src/chat/ChatShellPage.tsx`

If the file already exists, treat this content as the **latest reference** and merge quota‑aware pieces from 21.md as needed.

```tsx
// apps/web/src/chat/ChatShellPage.tsx

import React from 'react';
import { Box } from '@mui/material';
import { Outlet, useParams } from 'react-router-dom';
import { ConversationSidebar } from './ConversationSidebar';

/**
 * Layout that combines the left conversation sidebar with the chat content area.
 *
 * Route pattern example:
 *   /app/orgs/:orgId/chat/:conversationId
 */
export const ChatShellPage: React.FC = () => {
  const { conversationId } = useParams<{ conversationId: string }>();

  return (
    <Box display="flex" flex={1} minHeight={0}>
      <ConversationSidebar selectedConversationId={conversationId} />
      <Box flex={1} minWidth={0} display="flex" flexDirection="column">
        <Outlet />
      </Box>
    </Box>
  );
};
```

> In your router, ensure that `ChatShellPage` is used as a layout that wraps `ChatPage` as its child.

### 22.5.2. Router Integration Example

Update your routes to use the chat shell layout. For example:

```tsx
// apps/web/src/AppRoutes.tsx (excerpt)

import React from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AppLayout } from './layout/AppLayout';
import { ChatShellPage } from './chat/ChatShellPage';
import { ChatPage } from './chat/ChatPage';
import { OrgAnalyticsPage } from './orgs/OrgAnalyticsPage';
import { OrgBillingPage } from './admin/OrgBillingPage';

export const AppRoutes: React.FC = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/app" element={<AppLayout />}>
          <Route path="orgs/:orgId" element={<ChatShellPage />}>
            <Route path="chat/:conversationId" element={<ChatPage />} />
            <Route path="analytics" element={<OrgAnalyticsPage />} />
            <Route path="admin/billing" element={<OrgBillingPage />} />
          </Route>
        </Route>
      </Routes>
    </BrowserRouter>
  );
};
```

> Adjust paths to match your final structure. The key is that `ChatShellPage` wraps `ChatPage`, and the `ConversationSidebar` is always visible while switching between conversations.

---

## 22.6. Sanity Checks

From the repo root:

1. **Migrate DB (if you added/changed conversation metadata):**

   ```bash
   cd packages/db
   pnpm prisma migrate dev --name add_conversation_sidebar_metadata
   cd ../..
   ```

2. **Run API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

   - Test `GET /orgs/:orgId/conversations` with a valid token.  
   - Test `POST /orgs/:orgId/conversations` to create a new chat.  
   - Test `PATCH /conversations/:id` to pin/archive.

3. **Run web app:**

   ```bash
   cd apps/web
   pnpm dev
   ```

   - Navigate to `/app/orgs/<orgId>/chat/<conversationId>` (or your equivalent route).  
   - Verify the left sidebar shows conversations with:
     - Pinned section (if any pinned).  
     - Recent section for others.  
     - Hover & selection micro‑interactions.  
     - New chat button creates a conversation and navigates to it.  
     - Pin & Archive actions work and update the list.

If all checks pass, your AI chat app now has a **full multi‑conversation experience**, with a Grafana‑styled sidebar, search, and micro‑interactions, tightly integrated with orgs, analytics, and quota systems from previous markdown files.

---

_End of 22.md – Conversation Sidebar, Search & Multi‑Chat Layout_
