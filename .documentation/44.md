# 44. Playground, Experiments & Evals – Multi‑Run Prompt Testing with Material 3 UI

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Provide an **industry‑grade Playground & Evaluation** layer so that:
>
> - Users can interactively test prompts/models in a **Playground**.  
> - Org admins can create **Experiments** with multiple variants and run them on **test datasets**.  
> - Results can be **evaluated** (manual thumbs up/down + numeric scores) and inspected via a rich Material 3 UI.  
> - All usage is **tracked, observable and auditable** (28.md, 38.md).  
> - Everything is driven by the same **ChatProfiles + ModelRegistry + Ollama** stack (42.md, 43.md).
>
> This spec is written so Cursor‑like agents can implement it end‑to‑end without further questions.

This file builds on:

- 19.md – Quotas & usage accounting.  
- 25.md – Conversation & message pipeline & SSE.  
- 33–37.md – Tools, RAG & function calling.  
- 38.md – Events & audit log.  
- 40.md – Org Admin Console.  
- 41.md – Safety.  
- 42.md – ChatProfiles/Prompt Studio.  
- 43.md – Model Registry & provider routing.

---

## 44.1. Concepts & Scope

We introduce three main concepts:

1. **Playground Session**  
   - Ad‑hoc chat playground detached from long‑term conversations.  
   - User selects profile/model, writes a prompt, runs once or multiple times.  
   - Not meant as permanent storage; short‑lived but **loggable**.

2. **Experiment**  
   - Structured prompt test consisting of:  
     - A **base task description** (what we’re testing).  
     - A list of **inputs** (test set).  
     - One or more **variants** (prompt templates + config).  
   - Generates **Experiment Runs** containing output for each (input × variant).

3. **Evaluation**  
   - Per (input, variant) result can have:  
     - **Manual feedback**: thumbs up/down, optional note.  
     - **Numeric scores** under named metrics (e.g. `correctness`, `style`, `latency_ms`).  
   - Later we can plug LLM‑based auto‑evaluation; this spec keeps the function surface ready.

**Non‑goals (for now):** complex test orchestration, scheduled nightly evals, external judges. Those can be layered on top later.

---

## 44.2. Data Model – Prisma

Extend `packages/db/prisma/schema.prisma`.

```prisma
model PlaygroundSession {
  id        String   @id @default(cuid())
  orgId     String
  userId    String

  // Optional link to a ChatProfile
  chatProfileId String?

  // Basic config snapshot
  modelProvider String
  modelName     String
  temperature   Float   @default(0.7)
  topP          Float   @default(1.0)
  maxTokens     Int?

  createdAt DateTime @default(now())

  org   Org   @relation(fields: [orgId], references: [id])
  user  User  @relation(fields: [userId], references: [id])
}

model PlaygroundMessage {
  id        String   @id @default(cuid())
  sessionId String
  role      String   // 'user' | 'assistant'
  content   String

  createdAt DateTime @default(now())

  session PlaygroundSession @relation(fields: [sessionId], references: [id])

  @@index([sessionId, createdAt])
}

model Experiment {
  id        String   @id @default(cuid())
  orgId     String
  createdById String

  name        String
  description String?

  // e.g. 'offline_eval', 'prompt_tuning'
  type        String   @default("prompt_eval")

  // Free-form JSON for future extensions (tags, domain, etc.)
  metadata    Json?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org         Org      @relation(fields: [orgId], references: [id])
  creator     User     @relation(fields: [createdById], references: [id])

  variants    ExperimentVariant[]
  inputs      ExperimentInput[]
  runs        ExperimentRun[]

  @@index([orgId])
}

model ExperimentVariant {
  id           String   @id @default(cuid())
  experimentId String

  name         String
  description  String?

  // Link to a ChatProfile, or explicit provider/model + prompt text
  chatProfileId String?

  // Optional inline prompts for quick tests
  systemPrompt String?

  // JSON for per-variant config override (temperature, tools, etc.)
  config       Json?

  createdAt    DateTime @default(now())

  experiment   Experiment @relation(fields: [experimentId], references: [id])

  runs         ExperimentRun[]
}

model ExperimentInput {
  id           String   @id @default(cuid())
  experimentId String

  // A short human-readable key, e.g. 'case_01'
  key          String

  // Main input text
  content      String

  metadata     Json?

  createdAt    DateTime @default(now())

  experiment   Experiment @relation(fields: [experimentId], references: [id])

  @@index([experimentId])
}

model ExperimentRun {
  id             String   @id @default(cuid())
  experimentId   String
  variantId      String
  inputId        String

  // Snapshot of config used for this run
  modelProvider  String
  modelName      String
  temperature    Float
  topP           Float
  maxTokens      Int?

  // Raw output text
  output         String

  // Latency (ms) and token estimates
  latencyMs      Int?
  inputTokens    Int?
  outputTokens   Int?

  // Manual feedback
  thumbsUp       Boolean?
  feedbackNote   String?

  createdAt      DateTime @default(now())

  experiment     Experiment       @relation(fields: [experimentId], references: [id])
  variant        ExperimentVariant @relation(fields: [variantId], references: [id])
  input          ExperimentInput   @relation(fields: [inputId], references: [id])

  scores         EvalScore[]

  @@index([experimentId])
  @@index([variantId])
  @@index([inputId])
}

model EvalMetricDefinition {
  id        String   @id @default(cuid())
  orgId     String

  key       String   // 'correctness', 'style', 'hallucination_risk', etc.
  name      String
  description String?

  // 1–5, 0–100, etc.
  scale      String   // free-form description of the scale

  createdAt  DateTime @default(now())

  org        Org      @relation(fields: [orgId], references: [id])

  @@index([orgId, key])
}

model EvalScore {
  id        String   @id @default(cuid())

  runId     String
  metricId  String

  // Numeric score for this run+metric
  value     Float

  // Optional explanation / notes
  note      String?

  createdAt DateTime @default(now())

  run       ExperimentRun        @relation(fields: [runId], references: [id])
  metric    EvalMetricDefinition @relation(fields: [metricId], references: [id])

  @@index([runId])
  @@index([metricId])
}
```

> **Note:** These models do not conflict with the main `Conversation` table and can live beside it.

Run a Prisma migration after updating the schema.

---

## 44.3. Backend – Playground API

Playground uses the same LLM routing as normal chat, but in a simplified, stateless way.

### 44.3.1. Types

**File:** `apps/api-gateway/src/playground/types.ts`

```ts
// apps/api-gateway/src/playground/types.ts

export interface PlaygroundCompletionRequest {
  orgId: string;
  userId: string;

  // Optional ChatProfile ID. If provided, overrides model config.
  chatProfileId?: string | null;

  modelProvider?: string;
  modelName?: string;

  // Direct prompt for single-turn
  prompt: string;

  // Optional system prompt (if no ChatProfile or template)
  systemPrompt?: string;

  temperature?: number;
  topP?: number;
  maxTokens?: number | null;

  stream?: boolean;
}

export interface PlaygroundCompletionResponse {
  sessionId: string;
  output: string;
}
```

### 44.3.2. Route – Non‑Streaming Playground Completion

**File:** `apps/api-gateway/src/routes/playground.ts`

```ts
// apps/api-gateway/src/routes/playground.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { completeWithRouting } from '../llm/router';
import { resolveModelForOrg } from '../llm/modelRegistryService';

const playgroundSchema = z.object({
  chatProfileId: z.string().optional(),
  modelProvider: z.string().optional(),
  modelName: z.string().optional(),
  prompt: z.string().min(1),
  systemPrompt: z.string().optional(),
  temperature: z.number().min(0).max(2).optional(),
  topP: z.number().min(0).max(1).optional(),
  maxTokens: z.number().int().min(1).max(32768).nullable().optional()
});

export default async function playgroundRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.post('/orgs/:orgId/playground/complete', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    const parsed = playgroundSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const d = parsed.data;

    // Resolve profile/model
    let modelProvider: string;
    let modelName: string;
    let temperature = d.temperature ?? 0.7;
    let topP = d.topP ?? 1.0;
    let maxTokens = d.maxTokens ?? null;

    if (d.chatProfileId) {
      const profile = await prisma.chatProfile.findFirst({
        where: { id: d.chatProfileId, orgId }
      });
      if (!profile) {
        return reply.code(404).send({ error: 'CHAT_PROFILE_NOT_FOUND' });
      }
      modelProvider = profile.modelProvider;
      modelName = profile.modelName;
      temperature = profile.temperature;
      topP = profile.topP;
      maxTokens = profile.maxTokens ?? maxTokens;
    } else {
      modelProvider = d.modelProvider || 'ollama';
      modelName = d.modelName || 'llama3';
    }

    // Validate against Model Registry
    await resolveModelForOrg(orgId, modelProvider, modelName);

    // Create PlaygroundSession
    const session = await prisma.playgroundSession.create({
      data: {
        orgId,
        userId: payload.userId,
        chatProfileId: d.chatProfileId ?? null,
        modelProvider,
        modelName,
        temperature,
        topP,
        maxTokens
      }
    });

    const userMessage = await prisma.playgroundMessage.create({
      data: {
        sessionId: session.id,
        role: 'user',
        content: d.prompt
      }
    });

    // Construct messages
    const messages: { role: 'system' | 'user' | 'assistant'; content: string }[] = [];
    if (d.systemPrompt) {
      messages.push({ role: 'system', content: d.systemPrompt });
    }
    messages.push({ role: 'user', content: d.prompt });

    const startedAt = Date.now();

    const completion = await completeWithRouting({
      orgId,
      modelProvider,
      modelName,
      messages,
      temperature,
      topP,
      maxTokens,
      metadata: {
        orgId,
        chatProfileId: d.chatProfileId ?? undefined,
        conversationId: undefined,
        messageId: userMessage.id
      }
    });

    const latency = Date.now() - startedAt;

    await prisma.playgroundMessage.create({
      data: {
        sessionId: session.id,
        role: 'assistant',
        content: completion.content
      }
    });

    // Optional: emitEvent('playground.completion', { orgId, userId: payload.userId, ... })

    return reply.send({
      sessionId: session.id,
      output: completion.content,
      latencyMs: latency
    });
  });
}
```

Register in `main.ts`:

```ts
import playgroundRoutes from './routes/playground';

await app.register(playgroundRoutes);
```

> Streaming playground (`/playground/stream`) can be implemented analogously with SSE using `streamWithRouting` (25.md). The UI below supports both patterns.

---

## 44.4. Backend – Experiments & Evals API

We provide minimal but powerful endpoints to:

- Create experiments.  
- Add variants & inputs.  
- Run an experiment (sync for small sets).  
- Attach manual feedback & numeric scores.  
- List aggregated results.

### 44.4.1. Experiment CRUD Routes

**File:** `apps/api-gateway/src/routes/experiments.ts`

```ts
// apps/api-gateway/src/routes/experiments.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

const createExperimentSchema = z.object({
  name: z.string().min(1).max(256),
  description: z.string().optional(),
  metadata: z.record(z.any()).optional()
});

const addVariantSchema = z.object({
  name: z.string().min(1).max(128),
  description: z.string().optional(),
  chatProfileId: z.string().optional(),
  systemPrompt: z.string().optional(),
  config: z.record(z.any()).optional()
});

const addInputsSchema = z.object({
  inputs: z.array(
    z.object({
      key: z.string().min(1),
      content: z.string().min(1),
      metadata: z.record(z.any()).optional()
    })
  )
});

export default async function experimentsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // List experiments
  app.get('/orgs/:orgId/experiments', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:read'
    );

    const experiments = await prisma.experiment.findMany({
      where: { orgId },
      orderBy: { createdAt: 'desc' },
      include: {
        variants: true,
        inputs: true,
        runs: true
      }
    });

    return reply.send({ experiments });
  });

  // Create experiment
  app.post('/orgs/:orgId/experiments', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const orgId = (req.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = createExperimentSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const exp = await prisma.experiment.create({
      data: {
        orgId,
        createdById: payload.userId,
        name: parsed.data.name,
        description: parsed.data.description ?? null,
        metadata: parsed.data.metadata ?? {}
      }
    });

    // Optional: emitEvent('experiment.created', ...)

    return reply.code(201).send({ experiment: exp });
  });

  // Add variant
  app.post('/orgs/:orgId/experiments/:experimentId/variants', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, experimentId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = addVariantSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const v = await prisma.experimentVariant.create({
      data: {
        experimentId,
        name: parsed.data.name,
        description: parsed.data.description ?? null,
        chatProfileId: parsed.data.chatProfileId ?? null,
        systemPrompt: parsed.data.systemPrompt ?? null,
        config: parsed.data.config ?? {}
      }
    });

    return reply.code(201).send({ variant: v });
  });

  // Add inputs
  app.post('/orgs/:orgId/experiments/:experimentId/inputs', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, experimentId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = addInputsSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    await prisma.experimentInput.createMany({
      data: parsed.data.inputs.map((i) => ({
        experimentId,
        key: i.key,
        content: i.content,
        metadata: i.metadata ?? {}
      }))
    });

    return reply.code(201).send({ ok: true });
  });
}
```

Register in `main.ts`:

```ts
import experimentsRoutes from './routes/experiments';

await app.register(experimentsRoutes);
```

### 44.4.2. Running Experiments

For simplicity, we define a **synchronous** run endpoint suitable for small test sets (e.g. ≤ 20 inputs × 4 variants). Larger runs can be managed by background workers later.

**File:** `apps/api-gateway/src/routes/experimentRun.ts`

```ts
// apps/api-gateway/src/routes/experimentRun.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { completeWithRouting } from '../llm/router';
import { resolveModelForOrg } from '../llm/modelRegistryService';

const runExperimentSchema = z.object({
  inputIds: z.array(z.string()).optional(),
  variantIds: z.array(z.string()).optional()
});

export default async function experimentRunRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.post('/orgs/:orgId/experiments/:experimentId/run', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, experimentId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = runExperimentSchema.safeParse(req.body ?? {});
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const experiment = await prisma.experiment.findFirst({
      where: { id: experimentId, orgId },
      include: { variants: true, inputs: true }
    });

    if (!experiment) {
      return reply.code(404).send({ error: 'EXPERIMENT_NOT_FOUND' });
    }

    const variants = experiment.variants.filter((v) =>
      parsed.data.variantIds ? parsed.data.variantIds.includes(v.id) : true
    );
    const inputs = experiment.inputs.filter((i) =>
      parsed.data.inputIds ? parsed.data.inputIds.includes(i.id) : true
    );

    const results: any[] = [];

    for (const variant of variants) {
      // Derive model + config
      let modelProvider = 'ollama';
      let modelName = 'llama3';
      let temperature = 0.7;
      let topP = 1.0;
      let maxTokens: number | null = null;

      if (variant.chatProfileId) {
        const profile = await prisma.chatProfile.findFirst({ where: { id: variant.chatProfileId } });
        if (profile) {
          modelProvider = profile.modelProvider;
          modelName = profile.modelName;
          temperature = profile.temperature;
          topP = profile.topP;
          maxTokens = profile.maxTokens ?? null;
        }
      }

      await resolveModelForOrg(orgId, modelProvider, modelName);

      for (const input of inputs) {
        const startedAt = Date.now();

        const messages = [] as { role: 'system' | 'user'; content: string }[];
        if (variant.systemPrompt) {
          messages.push({ role: 'system', content: variant.systemPrompt });
        }
        messages.push({ role: 'user', content: input.content });

        const completion = await completeWithRouting({
          orgId,
          modelProvider,
          modelName,
          messages,
          temperature,
          topP,
          maxTokens
        });

        const latency = Date.now() - startedAt;

        const run = await prisma.experimentRun.create({
          data: {
            experimentId: experiment.id,
            variantId: variant.id,
            inputId: input.id,
            modelProvider,
            modelName,
            temperature,
            topP,
            maxTokens,
            output: completion.content,
            latencyMs: latency
          }
        });

        results.push({ runId: run.id, variantId: variant.id, inputId: input.id });

        // Optional: emitEvent('experiment.run.completed', { orgId, experimentId, runId: run.id })
      }
    }

    return reply.send({ ok: true, runs: results });
  });
}
```

Register in `main.ts`:

```ts
import experimentRunRoutes from './routes/experimentRun';

await app.register(experimentRunRoutes);
```

### 44.4.3. Feedback & Eval Score Routes

**File:** `apps/api-gateway/src/routes/experimentFeedback.ts`

```ts
// apps/api-gateway/src/routes/experimentFeedback.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';

const feedbackSchema = z.object({
  thumbsUp: z.boolean().optional(),
  note: z.string().optional()
});

const scoreSchema = z.object({
  metricKey: z.string().min(1),
  value: z.number(),
  note: z.string().optional()
});

export default async function experimentFeedbackRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  // Manual thumbs + note
  app.post('/orgs/:orgId/experiments/runs/:runId/feedback', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, runId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = feedbackSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const run = await prisma.experimentRun.findFirst({
      where: { id: runId, experiment: { orgId } },
      include: { experiment: true }
    });

    if (!run) {
      return reply.code(404).send({ error: 'RUN_NOT_FOUND' });
    }

    await prisma.experimentRun.update({
      where: { id: runId },
      data: {
        thumbsUp: parsed.data.thumbsUp ?? run.thumbsUp,
        feedbackNote: parsed.data.note ?? run.feedbackNote
      }
    });

    return reply.send({ ok: true });
  });

  // Add numeric score (will create metric definition if not exists)
  app.post('/orgs/:orgId/experiments/runs/:runId/scores', { preHandler: [app.authenticate] }, async (req, reply) => {
    const payload = req.user as JwtPayload;
    const { orgId, runId } = req.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:experiments:write'
    );

    const parsed = scoreSchema.safeParse(req.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const run = await prisma.experimentRun.findFirst({
      where: { id: runId, experiment: { orgId } },
      include: { experiment: true }
    });

    if (!run) {
      return reply.code(404).send({ error: 'RUN_NOT_FOUND' });
    }

    let metric = await prisma.evalMetricDefinition.findFirst({
      where: { orgId, key: parsed.data.metricKey }
    });

    if (!metric) {
      metric = await prisma.evalMetricDefinition.create({
        data: {
          orgId,
          key: parsed.data.metricKey,
          name: parsed.data.metricKey,
          scale: 'custom'
        }
      });
    }

    const score = await prisma.evalScore.create({
      data: {
        runId: run.id,
        metricId: metric.id,
        value: parsed.data.value,
        note: parsed.data.note ?? null
      }
    });

    return reply.code(201).send({ score });
  });
}
```

Register in `main.ts`:

```ts
import experimentFeedbackRoutes from './routes/experimentFeedback';

await app.register(experimentFeedbackRoutes);
```

---

## 44.5. Frontend – API Wrappers

### 44.5.1. Playground API – Web

**File:** `apps/web/src/api/playground.ts`

```ts
// apps/web/src/api/playground.ts

import { apiRequest } from './client';

export interface PlaygroundCompletionResponse {
  sessionId: string;
  output: string;
  latencyMs?: number;
}

export async function playgroundComplete(
  token: string,
  orgId: string,
  body: {
    chatProfileId?: string;
    modelProvider?: string;
    modelName?: string;
    prompt: string;
    systemPrompt?: string;
    temperature?: number;
    topP?: number;
    maxTokens?: number | null;
  }
): Promise<PlaygroundCompletionResponse> {
  return apiRequest<PlaygroundCompletionResponse>(
    `/orgs/${orgId}/playground/complete`,
    {
      method: 'POST',
      body: JSON.stringify(body)
    },
    token
  );
}
```

### 44.5.2. Experiments API – Web

**File:** `apps/web/src/api/experiments.ts`

```ts
// apps/web/src/api/experiments.ts

import { apiRequest } from './client';

export interface ExperimentDto {
  id: string;
  orgId: string;
  name: string;
  description: string | null;
  createdAt: string;
}

export interface ExperimentRunDto {
  id: string;
  experimentId: string;
  variantId: string;
  inputId: string;
  output: string;
  latencyMs: number | null;
  thumbsUp: boolean | null;
  feedbackNote: string | null;
}

export async function fetchExperiments(
  token: string,
  orgId: string
): Promise<{ experiments: any[] }> {
  return apiRequest<{ experiments: any[] }>(
    `/orgs/${orgId}/experiments`,
    { method: 'GET' },
    token
  );
}

export async function createExperiment(
  token: string,
  orgId: string,
  input: { name: string; description?: string }
): Promise<{ experiment: ExperimentDto }> {
  return apiRequest<{ experiment: ExperimentDto }>(
    `/orgs/${orgId}/experiments`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function addExperimentVariant(
  token: string,
  orgId: string,
  experimentId: string,
  input: { name: string; description?: string; chatProfileId?: string; systemPrompt?: string }
): Promise<{ variant: any }> {
  return apiRequest<{ variant: any }>(
    `/orgs/${orgId}/experiments/${experimentId}/variants`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function addExperimentInputs(
  token: string,
  orgId: string,
  experimentId: string,
  inputs: { key: string; content: string }[]
): Promise<{ ok: boolean }> {
  return apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/experiments/${experimentId}/inputs`,
    {
      method: 'POST',
      body: JSON.stringify({ inputs })
    },
    token
  );
}

export async function runExperiment(
  token: string,
  orgId: string,
  experimentId: string,
  body: { inputIds?: string[]; variantIds?: string[] }
): Promise<{ ok: boolean; runs: any[] }> {
  return apiRequest<{ ok: boolean; runs: any[] }>(
    `/orgs/${orgId}/experiments/${experimentId}/run`,
    {
      method: 'POST',
      body: JSON.stringify(body)
    },
    token
  );
}

export async function sendExperimentFeedback(
  token: string,
  orgId: string,
  runId: string,
  body: { thumbsUp?: boolean; note?: string }
): Promise<{ ok: boolean }> {
  return apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/experiments/runs/${runId}/feedback`,
    {
      method: 'POST',
      body: JSON.stringify(body)
    },
    token
  );
}

export async function sendExperimentScore(
  token: string,
  orgId: string,
  runId: string,
  body: { metricKey: string; value: number; note?: string }
): Promise<{ score: any }> {
  return apiRequest<{ score: any }>(
    `/orgs/${orgId}/experiments/runs/${runId}/scores`,
    {
      method: 'POST',
      body: JSON.stringify(body)
    },
    token
  );
}
```

---

## 44.6. Material 3 Playground UI

Route: `/app/orgs/:orgId/playground`

### 44.6.1. Component – PlaygroundPage

**File:** `apps/web/src/org/PlaygroundPage.tsx`

```tsx
// apps/web/src/org/PlaygroundPage.tsx

import React, { useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  CircularProgress,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  Slider,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import { playgroundComplete } from '../api/playground';
import { useChatProfiles } from '../hooks/useChatProfiles';

export const PlaygroundPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();
  const { profiles } = useChatProfiles();

  const [chatProfileId, setChatProfileId] = useState<string | ''>('');
  const [prompt, setPrompt] = useState('');
  const [systemPrompt, setSystemPrompt] = useState('');
  const [temperature, setTemperature] = useState(0.7);
  const [topP, setTopP] = useState(1.0);
  const [maxTokens, setMaxTokens] = useState<number | null>(null);

  const [output, setOutput] = useState('');
  const [latencyMs, setLatencyMs] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(129,140,248,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(45,212,191,0.18), transparent 55%)';

  const handleRun = async () => {
    if (!token || !orgId || !prompt.trim()) return;
    setLoading(true);
    setOutput('');
    setLatencyMs(null);
    try {
      const res = await playgroundComplete(token, orgId, {
        chatProfileId: chatProfileId || undefined,
        prompt,
        systemPrompt: systemPrompt || undefined,
        temperature,
        topP,
        maxTokens
      });
      setOutput(res.output);
      setLatencyMs(res.latencyMs ?? null);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1}>
          <AutoAwesomeIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Playground</Typography>
            <Typography variant="caption" color="text.secondary">
              Quickly test prompts, profiles and model parameters.
            </Typography>
          </Box>
        </Box>
      </Box>

      <Box sx={{ display: 'flex', gap: 2, flex: 1, minHeight: 0 }}>
        {/* Left: controls + prompt */}
        <Box sx={{ width: 360, display: 'flex', flexDirection: 'column', gap: 2 }}>
          <Card sx={{ borderRadius: 3 }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
              <FormControl fullWidth size="small">
                <InputLabel id="profile-select-label">Chat profile</InputLabel>
                <Select
                  labelId="profile-select-label"
                  label="Chat profile"
                  value={chatProfileId}
                  onChange={(e) => setChatProfileId(e.target.value)}
                >
                  <MenuItem value="">
                    <em>None (custom)</em>
                  </MenuItem>
                  {profiles.map((p) => (
                    <MenuItem key={p.id} value={p.id}>
                      {p.name}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <Box>
                <Typography variant="caption" color="text.secondary">
                  Temperature
                </Typography>
                <Slider
                  size="small"
                  min={0}
                  max={2}
                  step={0.1}
                  value={temperature}
                  onChange={(_, v) => setTemperature(v as number)}
                />
              </Box>

              <Box>
                <Typography variant="caption" color="text.secondary">
                  Top P
                </Typography>
                <Slider
                  size="small"
                  min={0}
                  max={1}
                  step={0.05}
                  value={topP}
                  onChange={(_, v) => setTopP(v as number)}
                />
              </Box>

              <TextField
                label="Max tokens (optional)"
                size="small"
                fullWidth
                value={maxTokens ?? ''}
                onChange={(e) => {
                  const v = e.target.value;
                  setMaxTokens(v ? Number(v) : null);
                }}
              />

              <Button
                variant="contained"
                startIcon={loading ? <CircularProgress size={18} /> : <PlayArrowIcon />}
                disabled={!prompt.trim() || loading}
                onClick={() => void handleRun()}
              >
                Run
              </Button>

              {latencyMs != null && (
                <Typography variant="caption" color="text.secondary">
                  Latency: {latencyMs} ms
                </Typography>
              )}
            </CardContent>
          </Card>

          <Card sx={{ borderRadius: 3, flex: 1 }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              <Typography variant="subtitle2">System prompt (optional)</Typography>
              <TextField
                multiline
                minRows={4}
                fullWidth
                placeholder="High-level instructions for the assistant..."
                value={systemPrompt}
                onChange={(e) => setSystemPrompt(e.target.value)}
              />
            </CardContent>
          </Card>
        </Box>

        {/* Right: prompt + output */}
        <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 2, minWidth: 0 }}>
          <Card sx={{ borderRadius: 3, flex: 1 }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1, height: '100%' }}>
              <Typography variant="subtitle2">Prompt</Typography>
              <TextField
                multiline
                minRows={6}
                maxRows={16}
                fullWidth
                placeholder="Ask something..."
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
              />
            </CardContent>
          </Card>

          <Card sx={{ borderRadius: 3, flex: 1 }}>
            <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1, height: '100%' }}>
              <Typography variant="subtitle2">Output</Typography>
              <Box
                sx={{
                  flex: 1,
                  minHeight: 0,
                  borderRadius: 2,
                  bgcolor: 'background.paper',
                  border: '1px solid',
                  borderColor: 'divider',
                  p: 1.5,
                  fontFamily: 'monospace',
                  fontSize: 13,
                  whiteSpace: 'pre-wrap',
                  overflowY: 'auto'
                }}
              >
                {loading ? 'Running...' : output || 'Run a prompt to see the output here.'}
              </Box>
            </CardContent>
          </Card>
        </Box>
      </Box>
    </Box>
  );
};
```

Register in router:

```tsx
import { PlaygroundPage } from './org/PlaygroundPage';

<Route path="/app/orgs/:orgId/playground" element={<PlaygroundPage />} />
```

---

## 44.7. Material 3 Experiments UI

We add an **Experiments** page for managing test sets and viewing results.

Route: `/app/orgs/:orgId/experiments`

### 44.7.1. Component – ExperimentsPage

**File:** `apps/web/src/org/ExperimentsPage.tsx`

```tsx
// apps/web/src/org/ExperimentsPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import AddIcon from '@mui/icons-material/Add';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ThumbUpOffAltIcon from '@mui/icons-material/ThumbUpOffAlt';
import ThumbDownOffAltIcon from '@mui/icons-material/ThumbDownOffAlt';
import { useParams } from 'react-router-dom';
import { useAuth } from '../auth/AuthContext';
import {
  fetchExperiments,
  createExperiment,
  addExperimentVariant,
  addExperimentInputs,
  runExperiment,
  sendExperimentFeedback
} from '../api/experiments';

export const ExperimentsPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [experiments, setExperiments] = useState<any[]>([]);
  const [selectedExp, setSelectedExp] = useState<any | null>(null);

  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [newName, setNewName] = useState('');
  const [newDesc, setNewDesc] = useState('');

  const [variantDialogOpen, setVariantDialogOpen] = useState(false);
  const [variantName, setVariantName] = useState('');
  const [variantPrompt, setVariantPrompt] = useState('');

  const [inputsText, setInputsText] = useState('');
  const [running, setRunning] = useState(false);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(251,146,60,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(79,70,229,0.18), transparent 55%)';

  const load = async () => {
    if (!token || !orgId) return;
    const res = await fetchExperiments(token, orgId);
    setExperiments(res.experiments);
    if (res.experiments.length && !selectedExp) {
      setSelectedExp(res.experiments[0]);
    } else if (selectedExp) {
      const match = res.experiments.find((e: any) => e.id === selectedExp.id);
      if (match) setSelectedExp(match);
    }
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [orgId, token]);

  const handleCreateExperiment = async () => {
    if (!token || !orgId) return;
    const res = await createExperiment(token, orgId, {
      name: newName,
      description: newDesc || undefined
    });
    setCreateDialogOpen(false);
    setNewName('');
    setNewDesc('');
    await load();
    setSelectedExp(res.experiment);
  };

  const handleAddVariant = async () => {
    if (!token || !orgId || !selectedExp) return;
    await addExperimentVariant(token, orgId, selectedExp.id, {
      name: variantName,
      systemPrompt: variantPrompt
    });
    setVariantDialogOpen(false);
    setVariantName('');
    setVariantPrompt('');
    await load();
  };

  const handleAddInputs = async () => {
    if (!token || !orgId || !selectedExp) return;
    const lines = inputsText
      .split('\n')
      .map((l) => l.trim())
      .filter(Boolean);
    const inputs = lines.map((line, idx) => ({ key: `case_${idx + 1}`, content: line }));
    await addExperimentInputs(token, orgId, selectedExp.id, inputs);
    setInputsText('');
    await load();
  };

  const handleRun = async () => {
    if (!token || !orgId || !selectedExp) return;
    setRunning(true);
    try {
      await runExperiment(token, orgId, selectedExp.id, {});
      await load();
    } finally {
      setRunning(false);
    }
  };

  const handleFeedback = async (runId: string, thumbsUp: boolean) => {
    if (!token || !orgId) return;
    await sendExperimentFeedback(token, orgId, runId, { thumbsUp });
    await load();
  };

  const renderRunsTable = () => {
    if (!selectedExp) return null;
    if (!selectedExp.runs?.length) {
      return (
        <Typography variant="body2" color="text.secondary">
          No runs yet. Add inputs & variants, then click Run.
        </Typography>
      );
    }

    return (
      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1, maxHeight: 520, overflow: 'auto' }}>
        {selectedExp.runs.map((run: any) => {
          const variant = selectedExp.variants.find((v: any) => v.id === run.variantId);
          const input = selectedExp.inputs.find((i: any) => i.id === run.inputId);
          return (
            <Card key={run.id} sx={{ borderRadius: 2 }}>
              <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 0.5 }}>
                <Box display="flex" justifyContent="space-between" alignItems="center">
                  <Box>
                    <Typography variant="subtitle2">{variant?.name || 'Variant'}</Typography>
                    <Typography variant="caption" color="text.secondary">
                      {input?.key}: {input?.content.slice(0, 80)}
                    </Typography>
                  </Box>
                  <Box display="flex" alignItems="center" gap={1}>
                    {run.latencyMs && (
                      <Typography variant="caption" color="text.secondary">
                        {run.latencyMs} ms
                      </Typography>
                    )}
                    <IconButton
                      size="small"
                      onClick={() => void handleFeedback(run.id, true)}
                      color={run.thumbsUp === true ? 'success' : 'default'}
                    >
                      <ThumbUpOffAltIcon fontSize="small" />
                    </IconButton>
                    <IconButton
                      size="small"
                      onClick={() => void handleFeedback(run.id, false)}
                      color={run.thumbsUp === false ? 'error' : 'default'}
                    >
                      <ThumbDownOffAltIcon fontSize="small" />
                    </IconButton>
                  </Box>
                </Box>
                <Typography
                  variant="body2"
                  sx={{ mt: 0.5, whiteSpace: 'pre-wrap', fontFamily: 'monospace', fontSize: 13 }}
                >
                  {run.output}
                </Typography>
              </CardContent>
            </Card>
          );
        })}
      </Box>
    );
  };

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      {/* Left: experiment list */}
      <Box sx={{ width: 260, display: 'flex', flexDirection: 'column', gap: 1 }}>
        <Box display="flex" alignItems="center" justifyContent="space-between">
          <Box display="flex" alignItems="center" gap={1}>
            <AutoAwesomeIcon fontSize="small" />
            <Typography variant="subtitle1">Experiments</Typography>
          </Box>
          <Button
            size="small"
            startIcon={<AddIcon />}
            onClick={() => setCreateDialogOpen(true)}
          >
            New
          </Button>
        </Box>

        <Card sx={{ flex: 1, borderRadius: 3, overflow: 'auto' }}>
          <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 0.5, p: 1 }}>
            {experiments.map((exp) => (
              <Card
                key={exp.id}
                sx={{
                  borderRadius: 2,
                  border: '1px solid',
                  borderColor: selectedExp?.id === exp.id ? 'primary.main' : 'divider',
                  cursor: 'pointer'
                }}
                onClick={() => setSelectedExp(exp)}
              >
                <CardContent sx={{ p: 1.25 }}>
                  <Typography variant="body2">{exp.name}</Typography>
                  {exp.description && (
                    <Typography variant="caption" color="text.secondary">
                      {exp.description}
                    </Typography>
                  )}
                </CardContent>
              </Card>
            ))}
            {experiments.length === 0 && (
              <Typography variant="body2" color="text.secondary">
                No experiments yet.
              </Typography>
            )}
          </CardContent>
        </Card>
      </Box>

      {/* Right: experiment detail */}
      <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 2, minWidth: 0 }}>
        {selectedExp ? (
          <>
            <Box display="flex" justifyContent="space-between" alignItems="center">
              <Box>
                <Typography variant="h6">{selectedExp.name}</Typography>
                {selectedExp.description && (
                  <Typography variant="body2" color="text.secondary">
                    {selectedExp.description}
                  </Typography>
                )}
              </Box>
              <Button
                variant="contained"
                startIcon={<PlayArrowIcon />}
                disabled={running || !selectedExp.inputs?.length || !selectedExp.variants?.length}
                onClick={() => void handleRun()}
              >
                {running ? 'Running…' : 'Run experiment'}
              </Button>
            </Box>

            <Box sx={{ display: 'flex', gap: 2, flex: 1, minHeight: 0 }}>
              {/* Inputs + variants config */}
              <Box sx={{ width: 360, display: 'flex', flexDirection: 'column', gap: 2 }}>
                <Card sx={{ borderRadius: 3 }}>
                  <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1.5 }}>
                    <Box display="flex" justifyContent="space-between" alignItems="center">
                      <Typography variant="subtitle2">Variants</Typography>
                      <Button size="small" onClick={() => setVariantDialogOpen(true)}>
                        Add variant
                      </Button>
                    </Box>
                    {selectedExp.variants?.length ? (
                      selectedExp.variants.map((v: any) => (
                        <Typography key={v.id} variant="body2">
                          • {v.name}
                        </Typography>
                      ))
                    ) : (
                      <Typography variant="body2" color="text.secondary">
                        No variants yet.
                      </Typography>
                    )}
                  </CardContent>
                </Card>

                <Card sx={{ borderRadius: 3 }}>
                  <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                    <Typography variant="subtitle2">Inputs</Typography>
                    <Typography variant="caption" color="text.secondary">
                      One input per line. Example: questions, test prompts, user messages.
                    </Typography>
                    <TextField
                      multiline
                      minRows={4}
                      fullWidth
                      placeholder="Enter inputs (one per line)"
                      value={inputsText}
                      onChange={(e) => setInputsText(e.target.value)}
                    />
                    <Box display="flex" justifyContent="flex-end" mt={0.5}>
                      <Button size="small" onClick={() => void handleAddInputs()} disabled={!inputsText.trim()}>
                        Add inputs
                      </Button>
                    </Box>
                    {selectedExp.inputs?.length ? (
                      <Typography variant="caption" color="text.secondary">
                        Current inputs: {selectedExp.inputs.length}
                      </Typography>
                    ) : null}
                  </CardContent>
                </Card>
              </Box>

              {/* Runs */}
              <Card sx={{ borderRadius: 3, flex: 1 }}>
                <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                  <Typography variant="subtitle2">Runs</Typography>
                  {renderRunsTable()}
                </CardContent>
              </Card>
            </Box>
          </>
        ) : (
          <Card sx={{ borderRadius: 3, flex: 1 }}>
            <CardContent
              sx={{
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
            >
              <Typography variant="body2" color="text.secondary">
                Select an experiment or create a new one.
              </Typography>
            </CardContent>
          </Card>
        )}
      </Box>

      {/* Create Experiment Dialog */}
      <Dialog open={createDialogOpen} onClose={() => setCreateDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>New experiment</DialogTitle>
        <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
          <TextField
            label="Name"
            fullWidth
            value={newName}
            onChange={(e) => setNewName(e.target.value)}
          />
          <TextField
            label="Description"
            fullWidth
            value={newDesc}
            onChange={(e) => setNewDesc(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setCreateDialogOpen(false)}>Cancel</Button>
          <Button
            onClick={() => void handleCreateExperiment()}
            disabled={!newName.trim()}
          >
            Create
          </Button>
        </DialogActions>
      </Dialog>

      {/* Add Variant Dialog */}
      <Dialog open={variantDialogOpen} onClose={() => setVariantDialogOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>New variant</DialogTitle>
        <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
          <TextField
            label="Name"
            fullWidth
            value={variantName}
            onChange={(e) => setVariantName(e.target.value)}
          />
          <TextField
            label="System prompt"
            fullWidth
            multiline
            minRows={4}
            value={variantPrompt}
            onChange={(e) => setVariantPrompt(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setVariantDialogOpen(false)}>Cancel</Button>
          <Button
            onClick={() => void handleAddVariant()}
            disabled={!variantName.trim()}
          >
            Add variant
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};
```

Add to router:

```tsx
import { ExperimentsPage } from './org/ExperimentsPage';

<Route path="/app/orgs/:orgId/experiments" element={<ExperimentsPage />} />
```

---

## 44.8. Observability & Grafana

Integrate Playground & Experiments with metrics (28.md):

- `playground_requests_total{orgId,modelProvider,modelName}`  
- `playground_latency_ms` (histogram).  
- `experiment_runs_total{orgId,experimentId,variantId}`  
- `experiment_latency_ms{orgId,experimentId,variantId}`.  
- `experiment_feedback_thumbs_up_total{orgId,experimentId,variantId}` & `thumbs_down_total`.

Emit events (38.md):

- `playground.completion` – whenever a playground run completes.  
- `experiment.run.completed` – per run.  
- `experiment.feedback.updated` – on thumbs up/down.  
- `experiment.score.created` – when numeric score is attached.

Grafana dashboards:

- Playground usage per org & model.  
- Experiment performance comparisons across variants (avg latency, thumbs‑up rate).  
- Metric‑specific panels (e.g. avg `correctness` per variant).

---

## 44.9. Sanity Checklist

Before enabling Playground & Experiments in production:

- [ ] Prisma migration including `PlaygroundSession`, `PlaygroundMessage`, `Experiment*` and `Eval*` models applied.  
- [ ] `/playground/complete` endpoint works and is wired into the M3 Playground UI.  
- [ ] Experiments CRUD, run & feedback routes are functional and RBAC‑protected.  
- [ ] ExperimentsPage shows variants, inputs and runs as expected.  
- [ ] Metrics and events are visible in Grafana and audit log.  
- [ ] Quotas & rate limits (19.md) apply to Playground & Experiments as to normal chat.

If all checks pass, the platform now has a **full Playground & Eval suite** comparable to (veya daha iyi) modern AI platforms: rapid prompt iteration, multi‑variant experiments, manual scoring and deep observability.

---

_End of 44.md – Playground, Experiments & Evals – Multi‑Run Prompt Testing with Material 3 UI_
