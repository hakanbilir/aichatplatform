# 37. Conversation Search, Filters & Inbox – Backend + Material 3 UI

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Implement a **powerful, ChatGPT‑class conversation search & inbox experience**:
>
> - Full‑text search across conversations & messages (per org).  
> - Filters (by user, date range, model, tags, has tools/RAG/attachments).  
> - Material 3 **Inbox UI** with gradients, quick filters and keyboard navigation.  
> - Fully wired backend (Prisma + Postgres FTS) and frontend hooks.
>
> This turns the app into an "AI knowledge inbox" where users can instantly find any previous conversation or answer.

This spec builds on:

- 13.md – Role & RBAC model.  
- 19.md – Org quota / usage guard.  
- 25.md – Conversation & message core APIs.  
- 28.md – Metrics & observability.  
- 35–36.md – Prompt & Preset features which add metadata to conversations.

---

## 37.1. Data Model & Indexing

We assume existing Prisma models:

- `Conversation` – belongs to `Org`, has `title`, `createdById`, `modelId`, etc.  
- `Message` – belongs to `Conversation`, `role`, `content`, timestamps, tool info, etc.

To support **fast full‑text search**, we add FTS columns via migrations and store denormalized tags.

### 37.1.1. Prisma Extensions

In `packages/db/prisma/schema.prisma` (or equivalent), extend models:

```prisma
model Conversation {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  orgId         String
  createdById   String

  title         String
  modelId       String

  // JSON metadata: tags, presetId, hasRag, toolsUsed, etc.
  metadata      Json     @default("{}")

  // For full-text search over titles (Postgres specific)
  titleTsv      Unsupported("tsvector")? @db.TsVector

  org   Org   @relation(fields: [orgId], references: [id])
  owner User  @relation(fields: [createdById], references: [id])
  // ... messages relation, etc.
}

model Message {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())

  conversationId String
  orgId          String
  authorId       String?

  role           String   // 'system' | 'user' | 'assistant' | 'tool'
  content        String

  // Whether this message includes tool calls, RAG context, etc.
  flags          Json     @default("{}")

  // Full-text indexable body
  contentTsv     Unsupported("tsvector")? @db.TsVector

  conversation Conversation @relation(fields: [conversationId], references: [id])
  org           Org          @relation(fields: [orgId], references: [id])
}
```

> **Note:** Prisma supports `Unsupported("tsvector")` for Postgres; the actual index and triggers are defined in SQL migrations.

---

### 37.1.2. Postgres Migration for FTS

Create a SQL migration (e.g. `prisma/migrations/XXXX_add_fts_indices/step.sql`):

```sql
-- Conversation title FTS
ALTER TABLE "Conversation" ADD COLUMN IF NOT EXISTS "titleTsv" tsvector;

UPDATE "Conversation"
SET "titleTsv" = to_tsvector('simple', coalesce("title", ''));

CREATE INDEX IF NOT EXISTS conversation_title_tsv_idx
  ON "Conversation" USING GIN ("titleTsv");

CREATE OR REPLACE FUNCTION conversation_title_tsv_trigger() RETURNS trigger AS $$
BEGIN
  NEW."titleTsv" := to_tsvector('simple', coalesce(NEW."title", ''));
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER conversation_title_tsv_update
  BEFORE INSERT OR UPDATE OF "title"
  ON "Conversation"
  FOR EACH ROW EXECUTE FUNCTION conversation_title_tsv_trigger();

-- Message content FTS
ALTER TABLE "Message" ADD COLUMN IF NOT EXISTS "contentTsv" tsvector;

UPDATE "Message"
SET "contentTsv" = to_tsvector('simple', coalesce("content", ''));

CREATE INDEX IF NOT EXISTS message_content_tsv_idx
  ON "Message" USING GIN ("contentTsv");

CREATE OR REPLACE FUNCTION message_content_tsv_trigger() RETURNS trigger AS $$
BEGIN
  NEW."contentTsv" := to_tsvector('simple', coalesce(NEW."content", ''));
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

CREATE TRIGGER message_content_tsv_update
  BEFORE INSERT OR UPDATE OF "content"
  ON "Message"
  FOR EACH ROW EXECUTE FUNCTION message_content_tsv_trigger();
```

This sets up GIN indices and triggers so search is fast and automatic.

---

## 37.2. Search DTO & Service (Backend)

We design a typed **search request/response** optimized for conversation inbox UIs.

### 37.2.1. Search DTO

**File:** `apps/api-gateway/src/search/types.ts`

```ts
// apps/api-gateway/src/search/types.ts

export type SearchSort = 'recent' | 'relevance';

export interface ConversationSearchFilters {
  modelIds?: string[];
  createdByUserIds?: string[];
  // ISO strings
  createdAfter?: string;
  createdBefore?: string;
  hasTools?: boolean;
  hasRag?: boolean;
  hasFiles?: boolean;
}

export interface ConversationSearchRequest {
  orgId: string;
  query: string;
  page: number;
  pageSize: number;
  sort: SearchSort;
  filters?: ConversationSearchFilters;
}

export interface ConversationSearchHitMessageSnippet {
  messageId: string;
  role: string;
  createdAt: string;
  // short excerpt with ellipsis
  snippet: string;
}

export interface ConversationSearchHit {
  conversationId: string;
  conversationTitle: string;
  modelId: string;
  createdAt: string;
  updatedAt: string;

  // for UI badges
  hasTools: boolean;
  hasRag: boolean;
  hasFiles: boolean;

  messages: ConversationSearchHitMessageSnippet[];
}

export interface ConversationSearchResponse {
  total: number;
  page: number;
  pageSize: number;
  hits: ConversationSearchHit[];
}
```

---

### 37.2.2. Search Service Implementation

**File:** `apps/api-gateway/src/search/service.ts`

```ts
// apps/api-gateway/src/search/service.ts

import { prisma } from '@ai-chat/db';
import { Prisma } from '@prisma/client';
import {
  ConversationSearchFilters,
  ConversationSearchRequest,
  ConversationSearchResponse,
  ConversationSearchHit,
  ConversationSearchHitMessageSnippet
} from './types';

const DEFAULT_PAGE_SIZE = 20;
const MAX_PAGE_SIZE = 50;

function clampPageSize(size: number | undefined): number {
  if (!size || size <= 0) return DEFAULT_PAGE_SIZE;
  return Math.min(size, MAX_PAGE_SIZE);
}

function buildFilterWhere(orgId: string, filters?: ConversationSearchFilters): Prisma.ConversationWhereInput {
  const where: Prisma.ConversationWhereInput = { orgId };

  if (!filters) return where;

  if (filters.modelIds && filters.modelIds.length > 0) {
    where.modelId = { in: filters.modelIds };
  }

  if (filters.createdByUserIds && filters.createdByUserIds.length > 0) {
    where.createdById = { in: filters.createdByUserIds };
  }

  if (filters.createdAfter || filters.createdBefore) {
    where.createdAt = {};
    if (filters.createdAfter) {
      where.createdAt.gte = new Date(filters.createdAfter);
    }
    if (filters.createdBefore) {
      where.createdAt.lte = new Date(filters.createdBefore);
    }
  }

  // metadata flags stored as JSON booleans, e.g. { hasTools: true, hasRag: true }
  if (filters.hasTools) {
    (where as any).metadata = {
      ...(where as any).metadata,
      path: ['hasTools'],
      equals: true
    };
  }

  // these JSON path filters may be adjusted to match your Prisma version & JSON querying semantics
  return where;
}

function buildSearchWhere(orgId: string, query: string, filters?: ConversationSearchFilters): {
  conversationWhere: Prisma.ConversationWhereInput;
  messageWhere: Prisma.MessageWhereInput;
} {
  const conversationWhere = buildFilterWhere(orgId, filters);

  const trimmed = query.trim();
  if (!trimmed) {
    return {
      conversationWhere,
      messageWhere: { orgId }
    };
  }

  const tsQuery = trimmed
    .split(/\s+/)
    .map((token) => token + ':*')
    .join(' & ');

  const messageWhere: Prisma.MessageWhereInput = {
    orgId,
    AND: [
      {
        OR: [
          // Postgres FTS; eslint disabled because of `$queryRaw`
          // @ts-expect-error - raw filter
          {
            contentTsv: { search: tsQuery }
          }
        ]
      }
    ]
  };

  return { conversationWhere, messageWhere };
}

function createSnippet(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - 1).trimEnd() + '…';
}

export async function searchConversations(
  req: ConversationSearchRequest
): Promise<ConversationSearchResponse> {
  const pageSize = clampPageSize(req.pageSize);
  const offset = (req.page <= 0 ? 0 : req.page) * pageSize;

  const { conversationWhere, messageWhere } = buildSearchWhere(
    req.orgId,
    req.query,
    req.filters
  );

  // First, find matching messages with their conversation IDs
  const messageMatches = await prisma.message.findMany({
    where: messageWhere,
    select: {
      id: true,
      conversationId: true,
      role: true,
      createdAt: true,
      content: true
    },
    take: 500 // cap for performance
  });

  const byConversation = new Map<string, ConversationSearchHitMessageSnippet[]>();

  for (const msg of messageMatches) {
    const list = byConversation.get(msg.conversationId) ?? [];
    if (list.length >= 3) continue; // up to 3 snippets per conversation
    list.push({
      messageId: msg.id,
      role: msg.role,
      createdAt: msg.createdAt.toISOString(),
      snippet: createSnippet(msg.content, 200)
    });
    byConversation.set(msg.conversationId, list);
  }

  // Get conversation IDs
  const conversationIds = Array.from(byConversation.keys());

  // If query is empty, we just use conversationWhere and ignore messageMatches
  let conversations;
  let total = 0;

  if (!req.query.trim()) {
    total = await prisma.conversation.count({ where: conversationWhere });
    conversations = await prisma.conversation.findMany({
      where: conversationWhere,
      orderBy: req.sort === 'recent' ? { updatedAt: 'desc' } : { createdAt: 'desc' },
      skip: offset,
      take: pageSize
    });
  } else if (conversationIds.length === 0) {
    return {
      total: 0,
      page: req.page,
      pageSize,
      hits: []
    };
  } else {
    total = conversationIds.length;
    const pagedIds = conversationIds.slice(offset, offset + pageSize);

    conversations = await prisma.conversation.findMany({
      where: {
        ...conversationWhere,
        id: { in: pagedIds }
      },
      orderBy: req.sort === 'recent' ? { updatedAt: 'desc' } : { createdAt: 'desc' }
    });
  }

  const hits: ConversationSearchHit[] = conversations.map((conv) => {
    const metadata: any = conv.metadata || {};
    const snippets = byConversation.get(conv.id) || [];

    return {
      conversationId: conv.id,
      conversationTitle: conv.title,
      modelId: conv.modelId,
      createdAt: conv.createdAt.toISOString(),
      updatedAt: conv.updatedAt.toISOString(),
      hasTools: Boolean(metadata.hasTools),
      hasRag: Boolean(metadata.hasRag),
      hasFiles: Boolean(metadata.hasFiles),
      messages: snippets
    };
  });

  return {
    total,
    page: req.page,
    pageSize,
    hits
  };
}
```

> **Note:** This service is intentionally simplified; in production you might use `prisma.$queryRaw` for more advanced ranking with `ts_rank`.

---

## 37.3. Search Route (API Gateway)

**File:** `apps/api-gateway/src/routes/search.ts`

```ts
// apps/api-gateway/src/routes/search.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { searchConversations } from '../search/service';
import { ConversationSearchRequest } from '../search/types';

const searchBodySchema = z.object({
  query: z.string().default(''),
  page: z.number().int().min(0).default(0),
  pageSize: z.number().int().min(1).max(50).default(20),
  sort: z.enum(['recent', 'relevance']).default('recent'),
  filters: z
    .object({
      modelIds: z.array(z.string()).optional(),
      createdByUserIds: z.array(z.string()).optional(),
      createdAfter: z.string().optional(),
      createdBefore: z.string().optional(),
      hasTools: z.boolean().optional(),
      hasRag: z.boolean().optional(),
      hasFiles: z.boolean().optional()
    })
    .optional()
});

export default async function searchRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  app.post('/orgs/:orgId/search', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:read'
    );

    const parsed = searchBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const body = parsed.data;

    const reqDto: ConversationSearchRequest = {
      orgId,
      query: body.query,
      page: body.page,
      pageSize: body.pageSize,
      sort: body.sort,
      filters: body.filters
    };

    const result = await searchConversations(reqDto);
    return reply.send(result);
  });
}
```

Register in `main.ts`:

```ts
import searchRoutes from './routes/search';

await app.register(searchRoutes);
```

RBAC: `org:chat:read` is sufficient to search conversations within the org.

---

## 37.4. Frontend API & Hook

### 37.4.1. Frontend Search API Wrapper

**File:** `apps/web/src/api/search.ts`

```ts
// apps/web/src/api/search.ts

import { apiRequest } from './client';

export type SearchSort = 'recent' | 'relevance';

export interface ConversationSearchFilters {
  modelIds?: string[];
  createdByUserIds?: string[];
  createdAfter?: string;
  createdBefore?: string;
  hasTools?: boolean;
  hasRag?: boolean;
  hasFiles?: boolean;
}

export interface ConversationSearchHitMessageSnippet {
  messageId: string;
  role: string;
  createdAt: string;
  snippet: string;
}

export interface ConversationSearchHit {
  conversationId: string;
  conversationTitle: string;
  modelId: string;
  createdAt: string;
  updatedAt: string;
  hasTools: boolean;
  hasRag: boolean;
  hasFiles: boolean;
  messages: ConversationSearchHitMessageSnippet[];
}

export interface ConversationSearchResponse {
  total: number;
  page: number;
  pageSize: number;
  hits: ConversationSearchHit[];
}

export interface ConversationSearchPayload {
  query: string;
  page?: number;
  pageSize?: number;
  sort?: SearchSort;
  filters?: ConversationSearchFilters;
}

export async function searchConversationsApi(
  token: string,
  orgId: string,
  payload: ConversationSearchPayload
): Promise<ConversationSearchResponse> {
  return apiRequest<ConversationSearchResponse>(
    `/orgs/${orgId}/search`,
    {
      method: 'POST',
      body: JSON.stringify(payload)
    },
    token
  );
}
```

---

### 37.4.2. useConversationSearch Hook

**File:** `apps/web/src/search/useConversationSearch.ts`

```ts
// apps/web/src/search/useConversationSearch.ts

import { useCallback, useState } from 'react';
import { useAuth } from '../auth/AuthContext';
import {
  ConversationSearchFilters,
  ConversationSearchHit,
  ConversationSearchResponse,
  ConversationSearchPayload,
  searchConversationsApi,
  SearchSort
} from '../api/search';

export interface UseConversationSearchState {
  query: string;
  sort: SearchSort;
  filters: ConversationSearchFilters;
  page: number;
  pageSize: number;
}

export function useConversationSearch(orgId: string | null) {
  const { token } = useAuth();

  const [state, setState] = useState<UseConversationSearchState>({
    query: '',
    sort: 'recent',
    filters: {},
    page: 0,
    pageSize: 20
  });

  const [results, setResults] = useState<ConversationSearchResponse | null>(null);
  const [hits, setHits] = useState<ConversationSearchHit[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const runSearch = useCallback(
    async (override?: Partial<UseConversationSearchState>) => {
      if (!token || !orgId) return;
      const nextState: UseConversationSearchState = {
        ...state,
        ...override
      };

      setState(nextState);
      setLoading(true);
      setError(null);

      try {
        const payload: ConversationSearchPayload = {
          query: nextState.query,
          page: nextState.page,
          pageSize: nextState.pageSize,
          sort: nextState.sort,
          filters: nextState.filters
        };

        const res = await searchConversationsApi(token, orgId, payload);
        setResults(res);
        setHits(res.hits);
      } catch (err) {
        setError((err as Error).message || 'Search failed');
      } finally {
        setLoading(false);
      }
    },
    [token, orgId, state]
  );

  return {
    state,
    results,
    hits,
    loading,
    error,
    runSearch,
    setState
  };
}
```

---

## 37.5. Inbox & Search UI – Material 3

We design a **unified conversations inbox** that combines:

- Search bar + filters.  
- Paginated list of conversations with snippets.  
- Vivid gradients and subtle interactions.

Route: `/app/orgs/:orgId/inbox` (or reuse existing conversation list route and embed this).

### 37.5.1. Inbox Page Component

**File:** `apps/web/src/inbox/ConversationInboxPage.tsx`

```tsx
// apps/web/src/inbox/ConversationInboxPage.tsx

import React, { useEffect } from 'react';
import {
  Box,
  Chip,
  IconButton,
  InputAdornment,
  Pagination,
  Paper,
  Skeleton,
  TextField,
  Tooltip,
  Typography
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import FilterAltOutlinedIcon from '@mui/icons-material/FilterAltOutlined';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import RefreshIcon from '@mui/icons-material/Refresh';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { useConversationSearch } from '../search/useConversationSearch';
import { ConversationSearchHit } from '../api/search';

const gradientBg =
  'radial-gradient(circle at top left, rgba(56,189,248,0.12), transparent 55%), ' +
  'radial-gradient(circle at bottom right, rgba(94,234,212,0.12), transparent 55%)';

interface ConversationHitCardProps {
  hit: ConversationSearchHit;
  onOpen: () => void;
}

const ConversationHitCard: React.FC<ConversationHitCardProps> = ({ hit, onOpen }) => {
  const firstSnippet = hit.messages[0]?.snippet || '';

  return (
    <Paper
      elevation={0}
      onClick={onOpen}
      sx={{
        p: 1.5,
        borderRadius: 2.5,
        border: '1px solid',
        borderColor: 'divider',
        cursor: 'pointer',
        display: 'flex',
        flexDirection: 'column',
        gap: 0.5,
        '&:hover': {
          borderColor: 'primary.main',
          boxShadow: (theme) => theme.shadows[2]
        },
        transition: 'border-color 120ms ease-out, box-shadow 120ms ease-out'
      }}
    >
      <Box display="flex" justifyContent="space-between" alignItems="center" gap={1}>
        <Typography
          variant="subtitle2"
          noWrap
          sx={{ maxWidth: '70%' }}
        >
          {hit.conversationTitle}
        </Typography>
        <Typography variant="caption" color="text.secondary">
          {new Date(hit.updatedAt).toLocaleString()}
        </Typography>
      </Box>

      {firstSnippet && (
        <Typography
          variant="body2"
          color="text.secondary"
          sx={{
            display: '-webkit-box',
            WebkitLineClamp: 2,
            WebkitBoxOrient: 'vertical',
            overflow: 'hidden'
          }}
        >
          {firstSnippet}
        </Typography>
      )}

      <Box display="flex" alignItems="center" justifyContent="space-between" mt={0.5}>
        <Typography variant="caption" color="text.secondary">
          {hit.modelId}
        </Typography>
        <Box display="flex" gap={0.5}>
          {hit.hasRag && <Chip size="small" label="RAG" variant="outlined" />}
          {hit.hasTools && <Chip size="small" label="Tools" variant="outlined" />}
          {hit.hasFiles && <Chip size="small" label="Files" variant="outlined" />}
        </Box>
      </Box>
    </Paper>
  );
};

export const ConversationInboxPage: React.FC = () => {
  const { orgId } = useParams();
  const [searchParams, setSearchParams] = useSearchParams();
  const navigate = useNavigate();

  const {
    state,
    hits,
    results,
    loading,
    error,
    runSearch,
    setState
  } = useConversationSearch(orgId || null);

  useEffect(() => {
    // initial: sync from URL query param
    const q = searchParams.get('q') || '';
    if (q && q !== state.query) {
      setState((prev) => ({ ...prev, query: q, page: 0 }));
      void runSearch({ query: q, page: 0 });
    } else if (!q) {
      void runSearch({});
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleQueryChange = (q: string) => {
    setState((prev) => ({ ...prev, query: q, page: 0 }));
    setSearchParams((params) => {
      if (q) params.set('q', q);
      else params.delete('q');
      return params;
    });
  };

  const handleKeyDown: React.KeyboardEventHandler<HTMLInputElement> = (e) => {
    if (e.key === 'Enter') {
      void runSearch({ page: 0 });
    }
  };

  const handlePageChange = (_: React.ChangeEvent<unknown>, pageNumber: number) => {
    const zeroBased = pageNumber - 1;
    setState((prev) => ({ ...prev, page: zeroBased }));
    void runSearch({ page: zeroBased });
  };

  const totalPages = results ? Math.ceil(results.total / results.pageSize) : 0;

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      {/* Header */}
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1}>
          <AutoAwesomeIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Inbox</Typography>
            <Typography variant="caption" color="text.secondary">
              Search and filter all your conversations in this organization.
            </Typography>
          </Box>
        </Box>
        <IconButton
          size="small"
          onClick={() => runSearch({})}
        >
          <RefreshIcon fontSize="small" />
        </IconButton>
      </Box>

      {/* Search bar & quick filters */}
      <Box display="flex" flexDirection={{ xs: 'column', md: 'row' }} gap={1.5}>
        <TextField
          fullWidth
          placeholder="Search conversations…"
          value={state.query}
          onChange={(e) => handleQueryChange(e.target.value)}
          onKeyDown={handleKeyDown}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon fontSize="small" />
              </InputAdornment>
            ),
            endAdornment: (
              <InputAdornment position="end">
                <Tooltip title="Advanced filters">
                  <IconButton size="small">
                    <FilterAltOutlinedIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </InputAdornment>
            )
          }}
        />

        <Box display="flex" gap={1} alignItems="center">
          <Typography variant="caption" color="text.secondary">
            Sort
          </Typography>
          <Chip
            size="small"
            label="Recent"
            color={state.sort === 'recent' ? 'primary' : 'default'}
            onClick={() => {
              setState((prev) => ({ ...prev, sort: 'recent', page: 0 }));
              void runSearch({ sort: 'recent', page: 0 });
            }}
          />
          <Chip
            size="small"
            label="Relevance"
            color={state.sort === 'relevance' ? 'primary' : 'default'}
            onClick={() => {
              setState((prev) => ({ ...prev, sort: 'relevance', page: 0 }));
              void runSearch({ sort: 'relevance', page: 0 });
            }}
          />
        </Box>
      </Box>

      {/* Results list */}
      <Box sx={{ flex: 1, overflow: 'auto' }}>
        {loading && (
          <Box display="flex" flexDirection="column" gap={1.5}>
            {Array.from({ length: 5 }).map((_, idx) => (
              <Skeleton key={idx} variant="rounded" height={72} />
            ))}
          </Box>
        )}

        {!loading && error && (
          <Typography variant="body2" color="error">
            {error}
          </Typography>
        )}

        {!loading && !error && hits.length === 0 && (
          <Typography variant="body2" color="text.secondary">
            No conversations found.
          </Typography>
        )}

        {!loading && !error && hits.length > 0 && (
          <Box
            sx={{
              display: 'grid',
              gridTemplateColumns: {
                xs: '1fr',
                md: 'repeat(2, minmax(0, 1fr))',
                lg: 'repeat(3, minmax(0, 1fr))'
              },
              gap: 1.5
            }}
          >
            {hits.map((hit) => (
              <ConversationHitCard
                key={hit.conversationId}
                hit={hit}
                onOpen={() => {
                  if (!orgId) return;
                  navigate(`/app/orgs/${orgId}/conversations/${hit.conversationId}`);
                }}
              />
            ))}
          </Box>
        )}
      </Box>

      {/* Pagination */}
      {results && totalPages > 1 && (
        <Box display="flex" justifyContent="center">
          <Pagination
            count={totalPages}
            page={results.page + 1}
            onChange={handlePageChange}
            size="small"
          />
        </Box>
      )}
    </Box>
  );
};
```

Add route:

```tsx
import { ConversationInboxPage } from './inbox/ConversationInboxPage';

<Route path="/app/orgs/:orgId/inbox" element={<ConversationInboxPage />} />
```

> **Advanced filters UI** (model, user, date range, flags) can be implemented as a small popover/dialog that manipulates `state.filters` and calls `runSearch`; this file defines the core skeleton.

---

## 37.6. Keyboard Navigation & Accessibility

To make the inbox feel “IDE‑like” and efficient:

- Add a global shortcut (e.g. `Cmd/Ctrl + K`) that focuses the inbox search field when the user is on the inbox page.  
- Ensure `ConversationHitCard` is focusable:
  - Wrap in a `<button>`‑like element or set `tabIndex={0}` and handle `onKeyDown` (`Enter`/`Space` → open).  
- Provide `aria-label` for icon buttons (`Refresh`, `Filters`).  
- Ensure text contrast meets WCAG AA even on gradient backgrounds.

These details can be implemented directly in the JSX by Cursor/agents without changing the core structure.

---

## 37.7. Observability & Metrics

Integrate with observability (28.md):

- Counters:  
  - `conversation_search_total{orgId}` – each call to `/orgs/:orgId/search`.  
  - `conversation_search_empty_results_total{orgId}` – when `hits.length === 0`.  
- Histograms:  
  - `conversation_search_latency_ms` – API handler duration.  
- Logs:  
  - Log `orgId`, `userId`, `queryLength`, `resultCount`, not full query text (for privacy unless explicitly allowed).

Expose dashboards in Grafana:  
- Search volume over time per org.  
- Empty result rate per org.  
- Average search latency.

---

## 37.8. Sanity Checklist

Before shipping the Conversation Inbox & search to production:

- [ ] FTS migrations applied and indices verified on `Conversation.titleTsv` and `Message.contentTsv`.  
- [ ] `/orgs/:orgId/search` endpoint returns results in < 200 ms for typical queries.  
- [ ] Inbox page shows relevant hits and opens conversations correctly.  
- [ ] URL query (`?q=`) sync works for deep links/bookmarks.  
- [ ] Keyboard navigation (`Tab`, `Enter`) works across results grid.  
- [ ] Metrics for search usage and latency visible in Grafana.

If all checks pass, your AI chat platform now has a **fast, UX‑rich search & inbox experience**, comparable to and often more flexible than ChatGPT’s conversation search—fully multi‑tenant, RBAC‑aware and optimized for enterprise usage.

---

_End of 37.md – Conversation Search, Filters & Inbox – Backend + Material 3 UI_
