# 32. Plugin & Integration Platform (Apps, Webhooks & External Tools)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Design and implement a **plugin / integration platform** for the AI chat system.
>
> - Allow organizations to install **apps** (Slack, Teams, generic webhook, internal services).  
> - Expose a **webhook + HTTP tool** model so external systems can participate in conversations.  
> - Integrate cleanly with the existing **tools engine** (26.md) and **RBAC** (13.md, 31.md).  
> - Provide a stable surface that can later power an **App Store / Marketplace** without code changes.

This file focuses on **backend primitives** and HTTP contracts; a dedicated UI will be defined in a later file.

---

## 32.1. Concepts & Terminology

We introduce a few core concepts:

- **Integration Provider** – a template that describes how to connect to a given external system. Examples: `slack`, `teams`, `generic-webhook`, `internal-http`.  
- **Org Integration** – an instance of a provider installed for a specific org, with credentials and settings.  
- **Webhook Subscription** – a rule that sends events (chat turns, tool results, etc.) to an external URL for a given org integration.  
- **External Tool** – a tool definition backed by an external HTTP endpoint belonging to an integration; used via the tools engine (26.md).

Design constraints:

- Plugins **never** run arbitrary code inside the API process. All integration is via HTTP calls (outgoing webhooks, HTTP tools).  
- Everything is org‑scoped and secured via **RBAC** and **HMAC signatures** on webhooks.  
- The same architecture works on a single host (Docker) or in a distributed Kubernetes setup (30.md).

---

## 32.2. Data Model (Prisma Level)

We define minimal Prisma models to support integrations.

> **Note:** Adjust naming to match your existing schema conventions. These models can live in the main Prisma schema with other org models.

```prisma
model IntegrationProvider {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  key         String   @unique // e.g. "slack", "generic-webhook"
  name        String
  description String
  // Optional manifest JSON (capabilities, logo, docs URL, etc.)
  manifest    Json

  orgIntegrations OrgIntegration[]
}

model OrgIntegration {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  orgId       String
  providerId  String
  name        String
  isEnabled   Boolean  @default(true)

  // Encrypted/opaque credential payload (tokens, webhooks, config)
  credentials Json
  config      Json

  provider IntegrationProvider @relation(fields: [providerId], references: [id])
  org      Org                 @relation(fields: [orgId], references: [id])

  webhookSubscriptions WebhookSubscription[]
  externalTools       ExternalToolDefinition[]
}

model WebhookSubscription {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  orgIntegrationId String
  url             String
  // e.g. ["chat.turn.completed", "tool.exec.success"]
  eventTypes      Json
  secret          String   // HMAC secret for signing
  isActive        Boolean  @default(true)

  orgIntegration OrgIntegration @relation(fields: [orgIntegrationId], references: [id])
  deliveries     WebhookDeliveryLog[]
}

model WebhookDeliveryLog {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  subscriptionId String
  statusCode  Int?
  durationMs  Int?
  success     Boolean
  error       String?

  subscription WebhookSubscription @relation(fields: [subscriptionId], references: [id])
}

model ExternalToolDefinition {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  orgIntegrationId String
  name             String   // e.g. "jira.createIssue"
  description      String
  // OpenAI-style JSON schema for arguments
  argsSchema       Json
  // HTTP config for calling the external service
  httpConfig       Json     // { "method": "POST", "url": "https://...", "headers": {...} }
  isEnabled        Boolean  @default(true)

  orgIntegration OrgIntegration @relation(fields: [orgIntegrationId], references: [id])
}
```

These models enable:

- Multiple integrations per org.  
- Multiple webhook subscriptions per integration.  
- Multiple tool definitions per integration.

---

## 32.3. Integration Provider Registry

We maintain a **registry** of supported providers in code. This allows you to ship built‑in apps (Slack, generic webhook) and later add more.

### 32.3.1. Provider Types

**File:** `apps/api-gateway/src/integrations/types.ts`

```ts
// apps/api-gateway/src/integrations/types.ts

export type IntegrationProviderKey = 'generic-webhook' | 'slack' | 'teams' | 'internal-http';

export interface IntegrationProviderDefinition {
  key: IntegrationProviderKey;
  name: string;
  description: string;
  // URL to docs or configuration instructions
  docsUrl?: string;
  // Whether this provider supports outbound webhooks
  supportsWebhooks: boolean;
  // Whether this provider supports external tools (HTTP-backed tools)
  supportsExternalTools: boolean;
}
```

### 32.3.2. Registry Implementation

**File:** `apps/api-gateway/src/integrations/registry.ts`

```ts
// apps/api-gateway/src/integrations/registry.ts

import { IntegrationProviderDefinition, IntegrationProviderKey } from './types';

const PROVIDERS: IntegrationProviderDefinition[] = [
  {
    key: 'generic-webhook',
    name: 'Generic Webhook',
    description: 'Send events to any HTTPS endpoint and optionally expose HTTP-backed tools.',
    supportsWebhooks: true,
    supportsExternalTools: true
  },
  {
    key: 'slack',
    name: 'Slack',
    description: 'Post messages to Slack channels and receive notifications via Slack webhooks.',
    supportsWebhooks: true,
    supportsExternalTools: true
  },
  {
    key: 'teams',
    name: 'Microsoft Teams',
    description: 'Send notifications and messages to Teams channels.',
    supportsWebhooks: true,
    supportsExternalTools: false
  },
  {
    key: 'internal-http',
    name: 'Internal HTTP Service',
    description: 'Call internal HTTP endpoints (inside your VPC or cluster) as tools.',
    supportsWebhooks: false,
    supportsExternalTools: true
  }
];

export function listIntegrationProviders(): IntegrationProviderDefinition[] {
  return PROVIDERS.slice();
}

export function getIntegrationProvider(key: IntegrationProviderKey): IntegrationProviderDefinition | undefined {
  return PROVIDERS.find((p) => p.key === key);
}
```

### 32.3.3. Syncing DB Providers (Optional)

On startup or via a migration script, ensure `IntegrationProvider` rows exist for each registry entry. This can be done with a small script using Prisma `upsert`.

---

## 32.4. Org Integrations Service

We implement service functions to manage org integrations and expose them via HTTP routes.

### 32.4.1. Service Layer

**File:** `apps/api-gateway/src/services/orgIntegrations.ts`

```ts
// apps/api-gateway/src/services/orgIntegrations.ts

import { prisma } from '@ai-chat/db';
import { IntegrationProviderKey } from '../integrations/types';
import { getIntegrationProvider } from '../integrations/registry';

export interface CreateOrgIntegrationInput {
  orgId: string;
  providerKey: IntegrationProviderKey;
  name: string;
  credentials: any;
  config?: any;
}

export async function createOrgIntegration(input: CreateOrgIntegrationInput) {
  const provider = getIntegrationProvider(input.providerKey);
  if (!provider) {
    throw new Error(`Unknown provider: ${input.providerKey}`);
  }

  const providerRow = await prisma.integrationProvider.upsert({
    where: { key: provider.key },
    update: {},
    create: {
      key: provider.key,
      name: provider.name,
      description: provider.description,
      manifest: {}
    }
  });

  const integration = await prisma.orgIntegration.create({
    data: {
      orgId: input.orgId,
      providerId: providerRow.id,
      name: input.name,
      isEnabled: true,
      credentials: input.credentials,
      config: input.config ?? {}
    }
  });

  return integration;
}

export async function listOrgIntegrations(orgId: string) {
  return prisma.orgIntegration.findMany({
    where: { orgId },
    include: {
      provider: true
    },
    orderBy: {
      createdAt: 'asc'
    }
  });
}

export async function updateOrgIntegration(
  orgId: string,
  integrationId: string,
  data: { name?: string; isEnabled?: boolean; config?: any }
) {
  // Enforce org scoping in the where clause
  return prisma.orgIntegration.updateMany({
    where: {
      id: integrationId,
      orgId
    },
    data: {
      name: data.name,
      isEnabled: data.isEnabled,
      config: data.config
    }
  });
}

export async function deleteOrgIntegration(orgId: string, integrationId: string) {
  await prisma.orgIntegration.deleteMany({
    where: {
      id: integrationId,
      orgId
    }
  });
}
```

All service functions enforce **org scoping** by including `orgId` in `where` clauses (31.4).

---

## 32.5. Org Integrations HTTP API

We now expose routes for listing and managing org integrations.

### 32.5.1. Routes

**File:** `apps/api-gateway/src/routes/orgIntegrations.ts`

```ts
// apps/api-gateway/src/routes/orgIntegrations.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { createOrgIntegration, deleteOrgIntegration, listOrgIntegrations, updateOrgIntegration } from '../services/orgIntegrations';

const createBodySchema = z.object({
  providerKey: z.enum(['generic-webhook', 'slack', 'teams', 'internal-http']),
  name: z.string().min(1).max(128),
  credentials: z.unknown(),
  config: z.unknown().optional()
});

const updateBodySchema = z.object({
  name: z.string().min(1).max(128).optional(),
  isEnabled: z.boolean().optional(),
  config: z.unknown().optional()
});

export default async function orgIntegrationsRoutes(
  app: FastifyInstance,
  _opts: FastifyPluginOptions
) {
  app.get('/orgs/:orgId/integrations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:tools:manage'
    );

    const integrations = await listOrgIntegrations(orgId);
    return reply.send({ integrations });
  });

  app.post('/orgs/:orgId/integrations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:tools:manage'
    );

    const parsed = createBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const integration = await createOrgIntegration({
      orgId,
      providerKey: parsed.data.providerKey,
      name: parsed.data.name,
      credentials: parsed.data.credentials,
      config: parsed.data.config
    });

    return reply.code(201).send({ integration });
  });

  app.patch('/orgs/:orgId/integrations/:integrationId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const integrationId = (request.params as any).integrationId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:tools:manage'
    );

    const parsed = updateBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    await updateOrgIntegration(orgId, integrationId, parsed.data);

    return reply.send({ ok: true });
  });

  app.delete('/orgs/:orgId/integrations/:integrationId', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;
    const integrationId = (request.params as any).integrationId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:tools:manage'
    );

    await deleteOrgIntegration(orgId, integrationId);

    return reply.send({ ok: true });
  });
}
```

Register in `main.ts`:

```ts
import orgIntegrationsRoutes from './routes/orgIntegrations';

await app.register(orgIntegrationsRoutes);
```

RBAC permission `org:tools:manage` (31.3) is reused to guard integration management.

---

## 32.6. Webhook Dispatch Engine

Webhook subscriptions allow external systems to react to events (chat turns, tool executions, etc.).

### 32.6.1. HMAC Signature

We sign outbound webhook requests with an HMAC header so receivers can verify authenticity.

- Header: `X-AI-Chat-Signature`  
- Algorithm: `HMAC-SHA256` over the raw JSON body.  
- Secret: `WebhookSubscription.secret`.

**File:** `apps/api-gateway/src/services/webhookDispatch.ts`

```ts
// apps/api-gateway/src/services/webhookDispatch.ts

import crypto from 'crypto';
import { prisma } from '@ai-chat/db';
import { logger } from '../observability/logger';

export type WebhookEventType = 'chat.turn.completed' | 'tool.exec.success' | 'tool.exec.error';

export interface WebhookEventPayload {
  type: WebhookEventType;
  orgId: string;
  conversationId?: string;
  data: any;
}

function computeSignature(secret: string, body: string): string {
  return crypto.createHmac('sha256', secret).update(body).digest('hex');
}

export async function dispatchWebhookEvent(event: WebhookEventPayload): Promise<void> {
  const subscriptions = await prisma.webhookSubscription.findMany({
    where: {
      isActive: true,
      orgIntegration: {
        orgId: event.orgId,
        isEnabled: true
      }
    },
    include: {
      orgIntegration: true
    }
  });

  if (!subscriptions.length) return;

  const body = JSON.stringify(event);

  for (const sub of subscriptions) {
    const startedAt = Date.now();
    let success = false;
    let statusCode: number | null = null;
    let error: string | null = null;

    try {
      const signature = computeSignature(sub.secret, body);

      const res = await fetch(sub.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-AI-Chat-Signature': signature,
          'X-AI-Chat-Event': event.type
        },
        body
      });

      statusCode = res.status;
      success = res.ok;

      if (!res.ok) {
        error = `HTTP ${res.status}`;
      }
    } catch (err) {
      error = (err as Error).message;
    } finally {
      const durationMs = Date.now() - startedAt;

      await prisma.webhookDeliveryLog.create({
        data: {
          subscriptionId: sub.id,
          statusCode: statusCode ?? 0,
          durationMs,
          success,
          error
        }
      });

      logger.info({
        event: 'webhook.delivery',
        subscriptionId: sub.id,
        orgId: event.orgId,
        url: sub.url,
        statusCode,
        durationMs,
        success,
        error
      }, 'Webhook delivery completed');
    }
  }
}
```

### 32.6.2. Emitting Events from Chat & Tool Engine

- After a chat turn completes (26.md), call `dispatchWebhookEvent` with type `chat.turn.completed`.  
- After tool execution success/error (26.md), call with type `tool.exec.success` or `tool.exec.error`.

Example (in `chatEngine.ts`, after successful assistant message creation):

```ts
import { dispatchWebhookEvent } from '../services/webhookDispatch';

await dispatchWebhookEvent({
  type: 'chat.turn.completed',
  orgId: conversation.orgId!,
  conversationId: conversation.id,
  data: {
    assistantMessageId: assistantMessage.id,
    model: modelConfig.id
  }
});
```

Example (in `toolEngine.ts`, for success branch):

```ts
await dispatchWebhookEvent({
  type: 'tool.exec.success',
  orgId: ctx.orgId!,
  data: {
    tool: tool.name
  }
});
```

> Only call dispatch when `ctx.orgId` is non‑null.

---

## 32.7. External Tools Backed by HTTP

We now wire `ExternalToolDefinition` into the tools engine so orgs can define HTTP‑backed tools.

### 32.7.1. HTTP Tool Adapter

**File:** `apps/api-gateway/src/tools/externalHttpToolAdapter.ts`

```ts
// apps/api-gateway/src/tools/externalHttpToolAdapter.ts

import { ToolContext, ToolDefinition } from './types';
import { prisma } from '@ai-chat/db';

interface HttpConfig {
  method: string;
  url: string;
  headers?: Record<string, string>;
}

export async function buildExternalToolsForOrg(orgId: string): Promise<ToolDefinition[]> {
  const defs = await prisma.externalToolDefinition.findMany({
    where: {
      orgIntegration: {
        orgId,
        isEnabled: true
      },
      isEnabled: true
    },
    include: {
      orgIntegration: true
    }
  });

  const tools: ToolDefinition[] = defs.map((def) => {
    const httpConfig = def.httpConfig as HttpConfig;

    const tool: ToolDefinition = {
      name: def.name,
      description: def.description,
      argsSchema: def.argsSchema,
      async execute(args: any, ctx: ToolContext) {
        const body = JSON.stringify({
          orgId: ctx.orgId,
          userId: ctx.userId,
          conversationId: ctx.conversationId,
          args
        });

        const res = await fetch(httpConfig.url, {
          method: httpConfig.method || 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(httpConfig.headers || {})
          },
          body
        });

        if (!res.ok) {
          const text = await res.text();
          throw new Error(`External tool HTTP ${res.status}: ${text}`);
        }

        const json = await res.json();
        return json;
      }
    };

    return tool;
  });

  return tools;
}
```

### 32.7.2. Extending Tool Registry per Context

Update `listToolsForContext` in `toolEngine.ts` (26.3.2) to append org external tools:

```ts
import { buildExternalToolsForOrg } from '../tools/externalHttpToolAdapter';

export async function listToolsForContext(ctx: ToolContext) {
  const base = listAllTools();

  if (ctx.orgId) {
    const external = await buildExternalToolsForOrg(ctx.orgId);
    return [...base, ...external];
  }

  return base;
}
```

> **Important:** Because `listToolsForContext` is now async, you may need to adjust call sites (26.md) to `await` it.

For example, in `chatEngine.ts`:

```ts
const tools = await listToolsForContext(ctx);
```

---

## 32.8. Security & RBAC for Integrations

- Management of integrations is guarded by `org:tools:manage` (31.3).  
- Webhooks use **HMAC signatures** that external systems must verify.  
- External tools only see `orgId`, `userId`, `conversationId` and `args`, no raw DB access.  
- Everything remains org‑scoped: `ExternalToolDefinition` and `WebhookSubscription` are linked to `OrgIntegration`, which is linked to `Org`.

To further tighten security:

- Store `WebhookSubscription.secret` and any credentials **encrypted** (KMS/Envelope encryption).  
- Limit outbound HTTP to allow‑listed domains (e.g., by using a proxy or firewall).  
- Add per‑tool and per‑integration **rate limits** on outbound calls.

---

## 32.9. Sanity Checks

From the repo root:

1. **Migrate DB:**

   ```bash
   pnpm --filter api-gateway prisma migrate dev
   ```

2. **Typecheck & lint:**

   ```bash
   pnpm lint
   pnpm typecheck
   ```

3. **Run API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

4. **Manual tests:**

   - `POST /orgs/:orgId/integrations` to create a `generic-webhook` integration.  
   - Insert one `WebhookSubscription` row for this integration with a test URL (e.g. https://webhook.site).  
   - Trigger a chat turn and confirm your webhook endpoint receives `chat.turn.completed` events with HMAC header.  
   - Create an `ExternalToolDefinition` row and confirm it appears in `GET /tools` for that org and can be executed via the tools panel (27.md).

If all checks pass, the platform now supports a **safe, extensible plugin model** based on org integrations, webhooks and external HTTP‑backed tools, ready to be expanded into a full App Store and integration ecosystem.

---

_End of 32.md – Plugin & Integration Platform (Apps, Webhooks & External Tools)_
