# 19. Hard Quota Enforcement in Chat API (Runtime Guard)

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Turn the **plan & quota model** (18.md) into **runtime‑enforced hard limits** on chat usage.
>
> - Backend: reusable **Org quota guard service**.  
> - Backend: integrate hard‑limit checks into **chat streaming/completions routes**.  
> - Error contract: stable JSON error shape (`ORG_HARD_QUOTA_EXCEEDED`).
>
> This ensures that once an org passes its **hard token limit**, further completions are blocked at the API boundary in a predictable way.

> **Important instructions to AI agents:**
> - Do **not** modify the DB schema or analytics routes here; they remain as in **18.md**.  
> - Implement the guard as a small, focused service and call it from chat routes.  
> - Do not add TODOs or half‑implemented stubs.

---

## 19.1. Quota Semantics

We enforce **hard quota** at the chat API layer with the following rules:

1. **Scope:**
   - Quotas apply **only** to conversations that belong to an organization (`conversation.orgId != null`).  
   - Personal / user‑only conversations (no `orgId`) are not limited by this guard.

2. **Window:**
   - We use a **rolling 30‑day window** for enforcement.  
   - This is aligned with the "monthly" soft/hard limits in `Org.monthlySoftLimitTokens` and `Org.monthlyHardLimitTokens`.

3. **Condition:**
   - If, within that 30‑day window, the **total tokens consumed by this org** (sum of prompt + completion tokens for all assistant messages) is **greater than or equal to** `Org.monthlyHardLimitTokens`, the org is **blocked** from requesting new completions.
   - Soft limits are not enforced here; they are used only for analytics / warnings (18.md).

4. **Error contract:**
   - Requests that are blocked by hard quota return **HTTP 429** with JSON:

     ```jsonc
     {
       "error": "ORG_HARD_QUOTA_EXCEEDED",
       "message": "This organization has exceeded its hard token limit in the current billing window.",
       "plan": "PRO",
       "quota": {
         "windowDays": 30,
         "usageTokens": 125000,
         "monthlySoftLimitTokens": 100000,
         "monthlyHardLimitTokens": 120000,
         "softLimitRemainingTokens": 0,
         "hardLimitRemainingTokens": 0,
         "softLimitExceeded": true,
         "hardLimitExceeded": true
       }
     }
     ```

---

## 19.2. Backend Service – Org Quota Guard

We create a small service that:

- Loads the org plan & limits.  
- Computes usage in the last `windowDays` days.  
- Returns a normalized quota status object that can be reused by both chat routes and future features.

### 19.2.1. Create `apps/api-gateway/src/services/orgQuotaGuard.ts`

```ts
// apps/api-gateway/src/services/orgQuotaGuard.ts

import { prisma } from '@ai-chat/db';

export type OrgPlan = 'FREE' | 'PRO' | 'ENTERPRISE' | 'CUSTOM';

export interface OrgQuotaWindowUsage {
  orgId: string;
  plan: OrgPlan;
  windowDays: number;
  usageTokens: number;
  monthlySoftLimitTokens: number | null;
  monthlyHardLimitTokens: number | null;
  softLimitRemainingTokens: number | null;
  hardLimitRemainingTokens: number | null;
  softLimitExceeded: boolean;
  hardLimitExceeded: boolean;
}

/**
 * Compute total token usage for an org within a rolling window, based on
 * ASSISTANT messages' `meta.usage` (promptTokens + completionTokens).
 */
export async function getOrgQuotaWindowUsage(orgId: string, windowDays: number = 30): Promise<OrgQuotaWindowUsage> {
  const org = await prisma.org.findUnique({
    where: { id: orgId },
    select: {
      id: true,
      plan: true,
      monthlySoftLimitTokens: true,
      monthlyHardLimitTokens: true
    }
  });

  if (!org) {
    throw new Error(`Org not found for quota guard: ${orgId}`);
  }

  const now = new Date();
  const from = new Date(now.getTime() - windowDays * 24 * 60 * 60 * 1000);

  const messages = await prisma.message.findMany({
    where: {
      role: 'ASSISTANT',
      createdAt: {
        gte: from
      },
      conversation: {
        orgId
      }
    },
    select: {
      meta: true
    }
  });

  let usageTokens = 0;

  for (const m of messages) {
    const meta: any = m.meta ?? {};
    const usage = meta?.usage;

    if (!usage || typeof usage !== 'object') {
      continue;
    }

    const promptTokens = typeof usage.promptTokens === 'number' ? usage.promptTokens : 0;
    const completionTokens = typeof usage.completionTokens === 'number' ? usage.completionTokens : 0;

    usageTokens += promptTokens + completionTokens;
  }

  const monthlySoftLimitTokens = org.monthlySoftLimitTokens ?? null;
  const monthlyHardLimitTokens = org.monthlyHardLimitTokens ?? null;

  const softLimitRemainingTokens =
    monthlySoftLimitTokens != null ? Math.max(monthlySoftLimitTokens - usageTokens, 0) : null;

  const hardLimitRemainingTokens =
    monthlyHardLimitTokens != null ? Math.max(monthlyHardLimitTokens - usageTokens, 0) : null;

  const softLimitExceeded =
    monthlySoftLimitTokens != null && usageTokens >= monthlySoftLimitTokens;

  const hardLimitExceeded =
    monthlyHardLimitTokens != null && usageTokens >= monthlyHardLimitTokens;

  return {
    orgId,
    plan: org.plan as OrgPlan,
    windowDays,
    usageTokens,
    monthlySoftLimitTokens,
    monthlyHardLimitTokens,
    softLimitRemainingTokens,
    hardLimitRemainingTokens,
    softLimitExceeded,
    hardLimitExceeded
  };
}
```

This service is intentionally **read‑only** and **idempotent**. It does not mutate any state – it just computes usage and compares it to configured limits.

---

## 19.3. Backend – Enforce Hard Quota in Chat Routes

We now integrate the quota guard into chat routes.

> **Assumption:** `apps/api-gateway/src/routes/chat.ts` already exposes at least a streaming endpoint (e.g. `POST /chat/stream`) that:
>
> - Authenticates the user via `app.authenticate`.  
> - Loads the `conversation` from the DB and checks access.  
> - Calls the underlying model provider (Ollama, OpenAI, etc.) to stream completions.
>
> We will insert **quota checks** after loading the conversation and before calling the provider.

### 19.3.1. Import quota guard in `chat.ts`

At the top of `apps/api-gateway/src/routes/chat.ts`, add:

```ts
import { getOrgQuotaWindowUsage } from '../services/orgQuotaGuard';
```

### 19.3.2. Enforce quota in `POST /chat/stream`

Inside the `/chat/stream` route handler, **after** you load the conversation and verify that the user has access, add a guard block like this.

> Use the closest existing variables from your current implementation; here we assume:
>
> - `conversation` is the loaded conversation from Prisma.  
> - `conversation.orgId` may be `string | null`.  
> - `reply` is the Fastify reply object.

```ts
// apps/api-gateway/src/routes/chat.ts (inside /chat/stream handler)

// After conversation is loaded and access is checked
if (conversation.orgId) {
  const quota = await getOrgQuotaWindowUsage(conversation.orgId, 30);

  if (quota.hardLimitExceeded) {
    // Block further completions for this org
    reply.code(429).send({
      error: 'ORG_HARD_QUOTA_EXCEEDED',
      message: 'This organization has exceeded its hard token limit in the current billing window.',
      plan: quota.plan,
      quota: {
        windowDays: quota.windowDays,
        usageTokens: quota.usageTokens,
        monthlySoftLimitTokens: quota.monthlySoftLimitTokens,
        monthlyHardLimitTokens: quota.monthlyHardLimitTokens,
        softLimitRemainingTokens: quota.softLimitRemainingTokens,
        hardLimitRemainingTokens: quota.hardLimitRemainingTokens,
        softLimitExceeded: quota.softLimitExceeded,
        hardLimitExceeded: quota.hardLimitExceeded
      }
    });
    return;
  }
}

// If we reach here, org is within hard quota – proceed with provider call
```

Place this block **before** the code that:

- Builds the provider request payload.  
- Opens a stream to Ollama / OpenAI.  
- Starts writing chunks to the HTTP response.

> **Note:** For personal conversations without `orgId`, the `if (conversation.orgId)` guard simply does nothing, so they are unaffected.

### 19.3.3. Enforce quota in non‑streaming chat endpoint (if present)

If you also expose a non‑streaming endpoint (e.g. `POST /chat/completions`), repeat the same pattern there:

- Import `getOrgQuotaWindowUsage`.  
- After loading the conversation and verifying access, call the guard.  
- If `quota.hardLimitExceeded` is true, return **429** with the same JSON shape.

Example sketch:

```ts
// Inside /chat/completions handler, after loading conversation
if (conversation.orgId) {
  const quota = await getOrgQuotaWindowUsage(conversation.orgId, 30);

  if (quota.hardLimitExceeded) {
    reply.code(429).send({
      error: 'ORG_HARD_QUOTA_EXCEEDED',
      message: 'This organization has exceeded its hard token limit in the current billing window.',
      plan: quota.plan,
      quota: {
        windowDays: quota.windowDays,
        usageTokens: quota.usageTokens,
        monthlySoftLimitTokens: quota.monthlySoftLimitTokens,
        monthlyHardLimitTokens: quota.monthlyHardLimitTokens,
        softLimitRemainingTokens: quota.softLimitRemainingTokens,
        hardLimitRemainingTokens: quota.hardLimitRemainingTokens,
        softLimitExceeded: quota.softLimitExceeded,
        hardLimitExceeded: quota.hardLimitExceeded
      }
    });
    return;
  }
}

// Proceed with non-streaming completion generation
```

---

## 19.4. Sanity Checks

From the repo root:

1. **Compile & lint:**

   ```bash
   pnpm lint
   pnpm typecheck
   ```

2. **Run API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

3. **Simulate an org over hard limit:**

   - In the DB, set a small `monthlyHardLimitTokens` for a test org (e.g. `1000`).  
   - Insert or generate assistant messages in that org such that their combined `meta.usage` tokens exceed that limit (e.g. 1500).

4. **Call `/chat/stream` with a conversation in that org:**

   ```bash
   curl -X POST \
     -H "Authorization: Bearer <token-for-user-in-org>" \
     -H "Content-Type: application/json" \
     -d '{ "conversationId": "<conv-id>", "messages": [ ... ] }' \
     http://localhost:4000/chat/stream
   ```

   You should get:

   - HTTP status **429**.  
   - JSON body with `error: "ORG_HARD_QUOTA_EXCEEDED"` and a `quota` object as defined above.

5. **Call `/chat/stream` with a conversation in another org under limit:**

   - The request should proceed and stream as usual.

---

## 19.5. Next Steps

With hard quota enforcement in place, future markdown files can:

- Wire a **nice UI/UX** in the web app when `ORG_HARD_QUOTA_EXCEEDED` occurs (inline banner + CTA to the Org Analytics page).  
- Add **Admin plan management UI** to edit `plan`, `monthlySoftLimitTokens`, `monthlyHardLimitTokens` per org.  
- Integrate with external **billing providers** (PAYTR / Stripe) so that plan changes auto‑adjust these limits.  
- Emit **audit log events** and notifications when hard limits are crossed.

> **AI Agent Instruction:**  
> Ensure that `orgQuotaGuard.ts` compiles, that `chat.ts` imports it correctly, and that both `/chat/stream` (and any non‑streaming endpoints) enforce the hard limit using the standardized error response.

---

_End of 19.md – Hard Quota Enforcement in Chat API (Runtime Guard)_
