# 39. Conversation Export, Sharing & Data Retention – Backend + Material 3 UI

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human backend/frontend engineers.  
> **Goal of this file:** Implement **enterprise‑grade conversation export & sharing** capabilities comparable to (and beyond) ChatGPT:
>
> - Export conversations in multiple formats (JSONL, Markdown, HTML) for backup, analysis or migration.  
> - Create **secure shared links** with optional expiration and passphrase.  
> - Org‑level **data retention & deletion policies** (e.g. auto‑delete after N days).  
> - Material 3 UI to export/share/manage conversations and retention rules.
>
> Everything is specified so Cursor‑like agents can implement it end‑to‑end without extra clarification.

This spec builds on:

- 13.md – Role & RBAC model.  
- 19.md – Org quotas & usage guard.  
- 25.md – Conversations & messages core APIs.  
- 33–37.md – RAG, prompts, presets, search, inbox.  
- 38.md – Events & audit log (we will emit events here).

---

## 39.1. Concepts & Feature Overview

We introduce three main capabilities:

1. **Conversation Export**  
   - Users can export a single conversation or multiple selected conversations.  
   - Export formats: `jsonl`, `markdown`, `html`.  
   - Exports run as **async jobs**, with status & download links.  

2. **Conversation Sharing (Public Links)**  
   - Users can generate a **public, read‑only link** to a conversation.  
   - Optional: hide specific messages, anonymize participants, require passphrase, set expiration.  
   - Public viewer is a lightweight Material 3 page, no login required.

3. **Org Data Retention Policy**  
   - Org owners/admins can configure:  
     - Max conversation age before **soft delete**.  
     - Whether exports/public links are allowed.  
     - Whether to allow user‑level deletion of conversations.  
   - Background jobs enforce retention policies.

All features are **org‑scoped, RBAC‑aware, and multi‑tenant safe**.

---

## 39.2. Data Model – Prisma

Extend Prisma schema (`packages/db/prisma/schema.prisma`) with models for exports, shared links and retention config.

```prisma
model ConversationExport {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orgId       String
  requestedBy String

  // Optional: If null, it may represent multi-conversation export
  conversationId String?

  // e.g. "jsonl", "markdown", "html"
  format      String

  // "pending" | "processing" | "completed" | "failed"
  status      String

  // Where the export file is stored (S3 path, local path, etc.)
  fileUrl     String?

  // Optional result metadata, error info, stats, etc.
  metadata    Json     @default("{}")

  org       Org   @relation(fields: [orgId], references: [id])
  requester User  @relation(fields: [requestedBy], references: [id])
}

model ConversationShareLink {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  orgId         String
  conversationId String
  createdBy     String

  // Public slug used in URLs, e.g. "/s/:slug"
  slug          String   @unique

  // Optional passphrase hash (e.g. bcrypt) – null if no passphrase
  passphraseHash String?

  // Optional expiration time – null means no expiry
  expiresAt     DateTime?

  // Whether the link is currently active
  isActive      Boolean  @default(true)

  // Whether to anonymize user names/emails in the public view
  anonymize     Boolean  @default(true)

  // Optional JSON config: hidden message IDs, theme, etc.
  config        Json     @default("{}")

  org          Org          @relation(fields: [orgId], references: [id])
  conversation Conversation @relation(fields: [conversationId], references: [id])
  creator      User         @relation(fields: [createdBy], references: [id])
}

model OrgDataRetentionConfig {
  id          String   @id @default(cuid())
  orgId       String   @unique

  // Number of days before conversations are auto-deleted; null = no auto-delete
  maxConversationAgeDays Int?

  // Whether end users can delete their own conversations
  allowUserDeletion      Boolean @default(true)

  // Whether exports are allowed at all
  allowExports           Boolean @default(true)

  // Whether public share links are allowed
  allowShareLinks        Boolean @default(true)

  // Whether to hard-delete deleted conversations after some grace period
  hardDeleteAfterDays    Int?    // null = keep soft-deleted

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org Org @relation(fields: [orgId], references: [id])
}
```

> If there is already a generic org‑settings table, this model can be merged logically; here we define it separately for clarity.

Run migrations after editing the schema.

---

## 39.3. Export Generation Service (Backend)

Exports run as **asynchronous jobs**. Creation is initiated via API, and a background worker fills in the file and updates status.

### 39.3.1. Export Request DTO & Service

**File:** `apps/api-gateway/src/exports/types.ts`

```ts
// apps/api-gateway/src/exports/types.ts

export type ConversationExportFormat = 'jsonl' | 'markdown' | 'html';

export interface CreateExportRequest {
  orgId: string;
  requestedBy: string;
  conversationId: string;
  format: ConversationExportFormat;
}

export interface ExportJobResultMetadata {
  conversationId: string;
  format: ConversationExportFormat;
  messageCount: number;
  sizeBytes: number;
}
```

**File:** `apps/api-gateway/src/exports/service.ts`

```ts
// apps/api-gateway/src/exports/service.ts

import { prisma } from '@ai-chat/db';
import { CreateExportRequest } from './types';

export async function createConversationExportJob(payload: CreateExportRequest) {
  const job = await prisma.conversationExport.create({
    data: {
      orgId: payload.orgId,
      requestedBy: payload.requestedBy,
      conversationId: payload.conversationId,
      format: payload.format,
      status: 'pending'
    }
  });

  // Optionally emit an event for observability (see 38.md)
  // await emitEvent({ ... });

  return job;
}
```

---

### 39.3.2. Export Worker – Implementation Sketch

A worker reads `ConversationExport` rows with `status = 'pending' | 'processing'`, generates files and updates rows.

**File:** `apps/worker/src/conversationExportWorker.ts`

```ts
// apps/worker/src/conversationExportWorker.ts

import fs from 'node:fs/promises';
import path from 'node:path';
import { prisma } from '@ai-chat/db';
import { ConversationExportFormat } from '../../api-gateway/src/exports/types';

// This is a simple implementation writing to local disk; in real deployments, use S3/minio.
const EXPORT_DIR = process.env.EXPORT_DIR ?? path.join(process.cwd(), 'exports');

async function ensureExportDir() {
  await fs.mkdir(EXPORT_DIR, { recursive: true });
}

async function buildExportContent(
  format: ConversationExportFormat,
  conversation: any,
  messages: any[]
): Promise<string> {
  if (format === 'jsonl') {
    const lines = messages.map((m) =>
      JSON.stringify({
        id: m.id,
        createdAt: m.createdAt,
        role: m.role,
        content: m.content
      })
    );
    return lines.join('\n');
  }

  if (format === 'markdown') {
    const header = `# ${conversation.title}\n\n`; // basic markdown escape can be added
    const body = messages
      .map((m) => `**${m.role.toUpperCase()}** (${m.createdAt.toISOString()}):\n\n${m.content}\n`)
      .join('\n');
    return header + body;
  }

  if (format === 'html') {
    const items = messages
      .map(
        (m) =>
          `<div class="message"><div class="meta">${m.role.toUpperCase()} · ${m.createdAt.toISOString()}</div><pre>${
            // basic escaping
            String(m.content)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
          }</pre></div>`
      )
      .join('\n');

    return `<!doctype html><html><head><meta charset="utf-8" /><title>${conversation.title}</title></head><body>${items}</body></html>`;
  }

  throw new Error(`Unsupported export format: ${format}`);
}

export async function processConversationExportBatch(limit = 10) {
  await ensureExportDir();

  const jobs = await prisma.conversationExport.findMany({
    where: { status: 'pending' },
    take: limit
  });

  for (const job of jobs) {
    try {
      await prisma.conversationExport.update({
        where: { id: job.id },
        data: { status: 'processing' }
      });

      if (!job.conversationId) {
        throw new Error('conversationId is required for this export worker');
      }

      const conversation = await prisma.conversation.findUnique({
        where: { id: job.conversationId },
        include: { messages: true }
      });

      if (!conversation) {
        throw new Error('Conversation not found');
      }

      const content = await buildExportContent(
        job.format as ConversationExportFormat,
        conversation,
        conversation.messages
      );

      const filename = `${job.id}.${job.format}`;
      const fullPath = path.join(EXPORT_DIR, filename);

      await fs.writeFile(fullPath, content, 'utf8');

      const stats = await fs.stat(fullPath);

      await prisma.conversationExport.update({
        where: { id: job.id },
        data: {
          status: 'completed',
          fileUrl: fullPath,
          metadata: {
            conversationId: conversation.id,
            format: job.format,
            messageCount: conversation.messages.length,
            sizeBytes: stats.size
          }
        }
      });
    } catch (err) {
      await prisma.conversationExport.update({
        where: { id: job.id },
        data: {
          status: 'failed',
          metadata: {
            ...(job.metadata as any),
            error: (err as Error).message
          }
        }
      });
    }
  }
}
```

Workers can be run via a periodic job (cron, systemd, etc.) calling `processConversationExportBatch()`.

---

## 39.4. Export API Routes (Backend)

### 39.4.1. Create Export Job & Get Status

**File:** `apps/api-gateway/src/routes/exports.ts`

```ts
// apps/api-gateway/src/routes/exports.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { prisma } from '@ai-chat/db';
import { createConversationExportJob } from '../exports/service';

const exportBodySchema = z.object({
  format: z.enum(['jsonl', 'markdown', 'html'])
});

export default async function exportsRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // Create export
  app.post('/orgs/:orgId/conversations/:conversationId/export', {
    preHandler: [app.authenticate]
  }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const { orgId, conversationId } = request.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:read'
    );

    const config = await prisma.orgDataRetentionConfig.findUnique({ where: { orgId } });
    if (config && config.allowExports === false) {
      return reply.code(403).send({ error: 'EXPORTS_DISABLED' });
    }

    const bodyParsed = exportBodySchema.safeParse(request.body);
    if (!bodyParsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: bodyParsed.error.format() });
    }

    // Optional: ensure user can access this conversation specifically.
    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        orgId
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'NOT_FOUND' });
    }

    const job = await createConversationExportJob({
      orgId,
      requestedBy: payload.userId,
      conversationId,
      format: bodyParsed.data.format
    });

    return reply.code(202).send({ exportId: job.id, status: job.status });
  });

  // Get export status & metadata
  app.get('/orgs/:orgId/exports/:exportId', {
    preHandler: [app.authenticate]
  }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const { orgId, exportId } = request.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:read'
    );

    const job = await prisma.conversationExport.findFirst({
      where: {
        id: exportId,
        orgId
      }
    });

    if (!job) {
      return reply.code(404).send({ error: 'NOT_FOUND' });
    }

    return reply.send({
      id: job.id,
      status: job.status,
      format: job.format,
      fileUrl: job.status === 'completed' ? job.fileUrl : null,
      metadata: job.metadata
    });
  });
}
```

Register in `main.ts`:

```ts
import exportsRoutes from './routes/exports';

await app.register(exportsRoutes);
```

> If exports are stored in S3 or another object store, `fileUrl` should be a signed URL or internal path resolved by another download route.

---

## 39.5. Conversation Sharing API (Public Links)

### 39.5.1. Utility Functions

**File:** `apps/api-gateway/src/sharing/utils.ts`

```ts
// apps/api-gateway/src/sharing/utils.ts

import crypto from 'node:crypto';
import bcrypt from 'bcryptjs';

export function generateSlug(): string {
  return crypto.randomBytes(6).toString('base64url');
}

export async function hashPassphrase(passphrase: string): Promise<string> {
  const saltRounds = 10;
  return bcrypt.hash(passphrase, saltRounds);
}

export async function verifyPassphrase(hash: string, passphrase: string): Promise<boolean> {
  return bcrypt.compare(passphrase, hash);
}
```

### 39.5.2. Routes – Create/Update/Delete Share Links

**File:** `apps/api-gateway/src/routes/sharing.ts`

```ts
// apps/api-gateway/src/routes/sharing.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { prisma } from '@ai-chat/db';
import { generateSlug, hashPassphrase, verifyPassphrase } from '../sharing/utils';

const createShareBodySchema = z.object({
  expiresAt: z.string().datetime().optional(),
  passphrase: z.string().min(4).max(128).optional(),
  anonymize: z.boolean().default(true),
  hiddenMessageIds: z.array(z.string()).optional()
});

const updateShareBodySchema = z.object({
  isActive: z.boolean().optional(),
  expiresAt: z.string().datetime().optional(),
  anonymize: z.boolean().optional(),
  hiddenMessageIds: z.array(z.string()).optional()
});

export default async function sharingRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // Create share link
  app.post('/orgs/:orgId/conversations/:conversationId/share', {
    preHandler: [app.authenticate]
  }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const { orgId, conversationId } = request.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const config = await prisma.orgDataRetentionConfig.findUnique({ where: { orgId } });
    if (config && config.allowShareLinks === false) {
      return reply.code(403).send({ error: 'SHARE_LINKS_DISABLED' });
    }

    const bodyParsed = createShareBodySchema.safeParse(request.body);
    if (!bodyParsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: bodyParsed.error.format() });
    }

    const conversation = await prisma.conversation.findFirst({ where: { id: conversationId, orgId } });
    if (!conversation) {
      return reply.code(404).send({ error: 'NOT_FOUND' });
    }

    const slug = generateSlug();

    const passphraseHash = bodyParsed.data.passphrase
      ? await hashPassphrase(bodyParsed.data.passphrase)
      : null;

    const link = await prisma.conversationShareLink.create({
      data: {
        orgId,
        conversationId,
        createdBy: payload.userId,
        slug,
        passphraseHash,
        expiresAt: bodyParsed.data.expiresAt ? new Date(bodyParsed.data.expiresAt) : null,
        anonymize: bodyParsed.data.anonymize,
        config: {
          hiddenMessageIds: bodyParsed.data.hiddenMessageIds ?? []
        }
      }
    });

    return reply.code(201).send({
      id: link.id,
      slug: link.slug,
      isActive: link.isActive,
      expiresAt: link.expiresAt,
      anonymize: link.anonymize,
      config: link.config
    });
  });

  // Update / deactivate share link
  app.patch('/orgs/:orgId/share-links/:shareId', {
    preHandler: [app.authenticate]
  }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const { orgId, shareId } = request.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    const bodyParsed = updateShareBodySchema.safeParse(request.body);
    if (!bodyParsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: bodyParsed.error.format() });
    }

    const link = await prisma.conversationShareLink.updateMany({
      where: { id: shareId, orgId },
      data: {
        isActive: bodyParsed.data.isActive,
        expiresAt: bodyParsed.data.expiresAt ? new Date(bodyParsed.data.expiresAt) : undefined,
        anonymize: bodyParsed.data.anonymize,
        config: bodyParsed.data.hiddenMessageIds
          ? {
              hiddenMessageIds: bodyParsed.data.hiddenMessageIds
            }
          : undefined
      }
    });

    if (link.count === 0) {
      return reply.code(404).send({ error: 'NOT_FOUND' });
    }

    return reply.send({ ok: true });
  });

  // Delete share link
  app.delete('/orgs/:orgId/share-links/:shareId', {
    preHandler: [app.authenticate]
  }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const { orgId, shareId } = request.params as any;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:chat:write'
    );

    await prisma.conversationShareLink.deleteMany({ where: { id: shareId, orgId } });
    return reply.send({ ok: true });
  });

  // Public view route (unauthenticated)
  app.post('/public/conversations/:slug', async (request, reply) => {
    // Accept optional passphrase in body for protected links
    const bodySchema = z.object({ passphrase: z.string().optional() });
    const bodyParsed = bodySchema.safeParse(request.body);
    if (!bodyParsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: bodyParsed.error.format() });
    }

    const { slug } = request.params as any;

    const link = await prisma.conversationShareLink.findUnique({
      where: { slug },
      include: {
        conversation: {
          include: { messages: true }
        },
        creator: {
          select: { id: true, displayName: true }
        }
      }
    });

    if (!link || !link.isActive) {
      return reply.code(404).send({ error: 'NOT_FOUND' });
    }

    if (link.expiresAt && link.expiresAt < new Date()) {
      return reply.code(410).send({ error: 'EXPIRED' });
    }

    if (link.passphraseHash) {
      const provided = bodyParsed.data.passphrase || '';
      const valid = await verifyPassphrase(link.passphraseHash, provided);
      if (!valid) {
        return reply.code(403).send({ error: 'INVALID_PASSPHRASE' });
      }
    }

    const hiddenIds: string[] = (link.config as any).hiddenMessageIds ?? [];

    // Filter & anonymize messages for public view
    const messages = link.conversation.messages
      .filter((m) => !hiddenIds.includes(m.id))
      .map((m) => ({
        id: m.id,
        createdAt: m.createdAt,
        role: m.role,
        content: m.content
      }));

    return reply.send({
      slug: link.slug,
      title: link.conversation.title,
      createdAt: link.conversation.createdAt,
      createdBy: link.anonymize
        ? null
        : {
            id: link.creator.id,
            displayName: link.creator.displayName
          },
      messages
    });
  });
}
```

Register in `main.ts`:

```ts
import sharingRoutes from './routes/sharing';

await app.register(sharingRoutes);
```

---

## 39.6. Org Data Retention Service & Worker

Retention rules are org‑level and enforced via a worker that periodically soft‑deletes conversations and optionally hard‑deletes after a grace period.

### 39.6.1. Retention Config API

**File:** `apps/api-gateway/src/routes/retention.ts`

```ts
// apps/api-gateway/src/routes/retention.ts

import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { z } from 'zod';
import { JwtPayload } from '../auth/types';
import { assertOrgPermission } from '../rbac/guards';
import { prisma } from '@ai-chat/db';

const retentionBodySchema = z.object({
  maxConversationAgeDays: z.number().int().min(1).max(3650).nullable().optional(),
  allowUserDeletion: z.boolean().optional(),
  allowExports: z.boolean().optional(),
  allowShareLinks: z.boolean().optional(),
  hardDeleteAfterDays: z.number().int().min(1).max(3650).nullable().optional()
});

export default async function retentionRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  app.get('/orgs/:orgId/retention', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:read'
    );

    const cfg = await prisma.orgDataRetentionConfig.findUnique({ where: { orgId } });
    return reply.send({ config: cfg });
  });

  app.put('/orgs/:orgId/retention', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;
    const orgId = (request.params as any).orgId as string;

    await assertOrgPermission(
      { id: payload.userId, isSuperadmin: payload.isSuperadmin },
      orgId,
      'org:settings:write'
    );

    const parsed = retentionBodySchema.safeParse(request.body);
    if (!parsed.success) {
      return reply.code(400).send({ error: 'INVALID_BODY', details: parsed.error.format() });
    }

    const cfg = await prisma.orgDataRetentionConfig.upsert({
      where: { orgId },
      update: {
        maxConversationAgeDays: parsed.data.maxConversationAgeDays ?? undefined,
        allowUserDeletion: parsed.data.allowUserDeletion ?? undefined,
        allowExports: parsed.data.allowExports ?? undefined,
        allowShareLinks: parsed.data.allowShareLinks ?? undefined,
        hardDeleteAfterDays: parsed.data.hardDeleteAfterDays ?? undefined
      },
      create: {
        orgId,
        maxConversationAgeDays: parsed.data.maxConversationAgeDays ?? null,
        allowUserDeletion: parsed.data.allowUserDeletion ?? true,
        allowExports: parsed.data.allowExports ?? true,
        allowShareLinks: parsed.data.allowShareLinks ?? true,
        hardDeleteAfterDays: parsed.data.hardDeleteAfterDays ?? null
      }
    });

    return reply.send({ config: cfg });
  });
}
```

Register in `main.ts`:

```ts
import retentionRoutes from './routes/retention';

await app.register(retentionRoutes);
```

---

### 39.6.2. Retention Worker Sketch

Assuming `Conversation` has a `deletedAt` nullable field (if not, add one via migration):

```prisma
model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?
  // ... other fields
}
```

**File:** `apps/worker/src/retentionWorker.ts`

```ts
// apps/worker/src/retentionWorker.ts

import { prisma } from '@ai-chat/db';

export async function enforceRetentionPolicies(batchSize = 200) {
  const orgs = await prisma.orgDataRetentionConfig.findMany();

  const now = new Date();

  for (const cfg of orgs) {
    // Soft delete based on maxConversationAgeDays
    if (cfg.maxConversationAgeDays) {
      const cutoff = new Date(now.getTime() - cfg.maxConversationAgeDays * 24 * 60 * 60 * 1000);

      await prisma.conversation.updateMany({
        where: {
          orgId: cfg.orgId,
          deletedAt: null,
          createdAt: { lt: cutoff }
        },
        data: {
          deletedAt: now
        }
      });
    }

    // Hard delete based on hardDeleteAfterDays
    if (cfg.hardDeleteAfterDays) {
      const cutoffDeleted = new Date(
        now.getTime() - cfg.hardDeleteAfterDays * 24 * 60 * 60 * 1000
      );

      await prisma.conversation.deleteMany({
        where: {
          orgId: cfg.orgId,
          deletedAt: { lt: cutoffDeleted }
        }
      });
    }
  }
}
```

Enforce this worker via a scheduled job (e.g. daily) to keep storage and privacy policies under control.

---

## 39.7. Frontend – Export & Sharing API Wrappers

### 39.7.1. Export API – Web

**File:** `apps/web/src/api/exports.ts`

```ts
// apps/web/src/api/exports.ts

import { apiRequest } from './client';

export type ConversationExportFormat = 'jsonl' | 'markdown' | 'html';

export interface ExportJob {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  format: ConversationExportFormat;
  fileUrl: string | null;
  metadata: Record<string, any>;
}

export async function createExportJob(
  token: string,
  orgId: string,
  conversationId: string,
  format: ConversationExportFormat
): Promise<{ exportId: string; status: string }> {
  return apiRequest<{ exportId: string; status: string }>(
    `/orgs/${orgId}/conversations/${conversationId}/export`,
    {
      method: 'POST',
      body: JSON.stringify({ format })
    },
    token
  );
}

export async function fetchExportJob(
  token: string,
  orgId: string,
  exportId: string
): Promise<ExportJob> {
  return apiRequest<ExportJob>(
    `/orgs/${orgId}/exports/${exportId}`,
    { method: 'GET' },
    token
  );
}
```

### 39.7.2. Sharing API – Web

**File:** `apps/web/src/api/sharing.ts`

```ts
// apps/web/src/api/sharing.ts

import { apiRequest } from './client';

export interface ShareLink {
  id: string;
  slug: string;
  isActive: boolean;
  expiresAt?: string | null;
  anonymize: boolean;
  config: Record<string, any>;
}

export interface CreateShareLinkInput {
  expiresAt?: string;
  passphrase?: string;
  anonymize?: boolean;
  hiddenMessageIds?: string[];
}

export interface UpdateShareLinkInput {
  isActive?: boolean;
  expiresAt?: string;
  anonymize?: boolean;
  hiddenMessageIds?: string[];
}

export async function createShareLink(
  token: string,
  orgId: string,
  conversationId: string,
  input: CreateShareLinkInput
): Promise<ShareLink> {
  return apiRequest<ShareLink>(
    `/orgs/${orgId}/conversations/${conversationId}/share`,
    {
      method: 'POST',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function updateShareLink(
  token: string,
  orgId: string,
  shareId: string,
  input: UpdateShareLinkInput
): Promise<void> {
  await apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/share-links/${shareId}`,
    {
      method: 'PATCH',
      body: JSON.stringify(input)
    },
    token
  );
}

export async function deleteShareLink(
  token: string,
  orgId: string,
  shareId: string
): Promise<void> {
  await apiRequest<{ ok: boolean }>(
    `/orgs/${orgId}/share-links/${shareId}`,
    { method: 'DELETE' },
    token
  );
}

export interface PublicSharedConversation {
  slug: string;
  title: string;
  createdAt: string;
  createdBy: { id: string; displayName: string } | null;
  messages: { id: string; createdAt: string; role: string; content: string }[];
}

export async function fetchPublicSharedConversation(
  slug: string,
  passphrase?: string
): Promise<PublicSharedConversation> {
  return apiRequest<PublicSharedConversation>(
    `/public/conversations/${slug}`,
    {
      method: 'POST',
      body: JSON.stringify({ passphrase })
    },
    undefined // no auth token for public route
  );
}
```

---

## 39.8. Material 3 UI – Conversation Export & Share Dialogs

### 39.8.1. Export Dialog in Conversation View

**File:** `apps/web/src/conversations/ConversationExportDialog.tsx`

```tsx
// apps/web/src/conversations/ConversationExportDialog.tsx

import React, { useState } from 'react';
import {
  Box,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  MenuItem,
  Select,
  Typography
} from '@mui/material';
import DownloadIcon from '@mui/icons-material/Download';
import { ConversationExportFormat, createExportJob, fetchExportJob } from '../api/exports';
import { useAuth } from '../auth/AuthContext';

interface ConversationExportDialogProps {
  open: boolean;
  onClose: () => void;
  orgId: string;
  conversationId: string;
}

export const ConversationExportDialog: React.FC<ConversationExportDialogProps> = ({
  open,
  onClose,
  orgId,
  conversationId
}) => {
  const { token } = useAuth();
  const [format, setFormat] = useState<ConversationExportFormat>('markdown');
  const [exportId, setExportId] = useState<string | null>(null);
  const [status, setStatus] = useState<string | null>(null);
  const [fileUrl, setFileUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleStartExport = async () => {
    if (!token) return;
    setLoading(true);
    try {
      const res = await createExportJob(token, orgId, conversationId, format);
      setExportId(res.exportId);
      setStatus(res.status);
    } finally {
      setLoading(false);
    }
  };

  const handleRefreshStatus = async () => {
    if (!token || !exportId) return;
    setLoading(true);
    try {
      const job = await fetchExportJob(token, orgId, exportId);
      setStatus(job.status);
      setFileUrl(job.fileUrl);
    } finally {
      setLoading(false);
    }
  };

  const handleDownload = () => {
    if (!fileUrl) return;
    window.open(fileUrl, '_blank');
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="xs" fullWidth>
      <DialogTitle>Export conversation</DialogTitle>
      <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
        <Box>
          <Typography variant="subtitle2">Format</Typography>
          <Select
            size="small"
            fullWidth
            value={format}
            onChange={(e) => setFormat(e.target.value as ConversationExportFormat)}
          >
            <MenuItem value="markdown">Markdown (.md)</MenuItem>
            <MenuItem value="jsonl">JSON Lines (.jsonl)</MenuItem>
            <MenuItem value="html">HTML (.html)</MenuItem>
          </Select>
        </Box>

        {exportId && (
          <Box>
            <Typography variant="caption" color="text.secondary">
              Status: {status}
            </Typography>
            {fileUrl && (
              <Box mt={1}>
                <Button
                  size="small"
                  variant="contained"
                  startIcon={<DownloadIcon />}
                  onClick={handleDownload}
                >
                  Download
                </Button>
              </Box>
            )}
          </Box>
        )}
      </DialogContent>
      <DialogActions>
        {exportId && !fileUrl && (
          <Button onClick={handleRefreshStatus} disabled={loading}>
            Refresh status
          </Button>
        )}
        {!exportId && (
          <Button onClick={handleStartExport} disabled={loading}>
            Start export
          </Button>
        )}
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  );
};
```

Integrate this dialog into the conversation view (e.g. in a kebab menu near the title).

---

### 39.8.2. Share Link Dialog in Conversation View

**File:** `apps/web/src/conversations/ConversationShareDialog.tsx`

```tsx
// apps/web/src/conversations/ConversationShareDialog.tsx

import React, { useState } from 'react';
import {
  Box,
  Button,
  Checkbox,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  FormControlLabel,
  TextField,
  Typography
} from '@mui/material';
import LinkIcon from '@mui/icons-material/Link';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import dayjs from 'dayjs';
import { useAuth } from '../auth/AuthContext';
import { createShareLink } from '../api/sharing';

interface ConversationShareDialogProps {
  open: boolean;
  onClose: () => void;
  orgId: string;
  conversationId: string;
  basePublicUrl: string; // e.g. https://app.example.com
}

export const ConversationShareDialog: React.FC<ConversationShareDialogProps> = ({
  open,
  onClose,
  orgId,
  conversationId,
  basePublicUrl
}) => {
  const { token } = useAuth();

  const [expiresInDays, setExpiresInDays] = useState('7');
  const [passphrase, setPassphrase] = useState('');
  const [anonymize, setAnonymize] = useState(true);
  const [publicUrl, setPublicUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleCreateLink = async () => {
    if (!token) return;
    setLoading(true);
    try {
      const expiresAt = expiresInDays
        ? dayjs().add(Number(expiresInDays) || 0, 'day').toISOString()
        : undefined;

      const link = await createShareLink(token, orgId, conversationId, {
        expiresAt,
        passphrase: passphrase || undefined,
        anonymize
      });

      const url = `${basePublicUrl}/s/${link.slug}`;
      setPublicUrl(url);
    } finally {
      setLoading(false);
    }
  };

  const handleCopy = async () => {
    if (!publicUrl) return;
    try {
      await navigator.clipboard.writeText(publicUrl);
    } catch {
      // ignore
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="xs" fullWidth>
      <DialogTitle>Share conversation</DialogTitle>
      <DialogContent sx={{ display: 'flex', flexDirection: 'column', gap: 2, mt: 1 }}>
        <TextField
          label="Expires in (days)"
          size="small"
          value={expiresInDays}
          onChange={(e) => setExpiresInDays(e.target.value)}
        />
        <TextField
          label="Passphrase (optional)"
          size="small"
          value={passphrase}
          onChange={(e) => setPassphrase(e.target.value)}
          helperText="If set, viewers must enter this passphrase to access the link."
        />
        <FormControlLabel
          control={
            <Checkbox
              checked={anonymize}
              onChange={(e) => setAnonymize(e.target.checked)}
            />
          }
          label="Anonymize users in public view"
        />

        {publicUrl && (
          <Box>
            <Typography variant="caption" color="text.secondary">
              Public URL
            </Typography>
            <Box
              sx={{
                mt: 0.5,
                p: 1,
                borderRadius: 2,
                border: '1px solid',
                borderColor: 'divider',
                display: 'flex',
                alignItems: 'center',
                gap: 1
              }}
            >
              <LinkIcon fontSize="small" />
              <Typography
                variant="caption"
                sx={{ wordBreak: 'break-all' }}
              >
                {publicUrl}
              </Typography>
              <Button
                size="small"
                variant="text"
                startIcon={<ContentCopyIcon fontSize="small" />}
                onClick={handleCopy}
              >
                Copy
              </Button>
            </Box>
          </Box>
        )}
      </DialogContent>
      <DialogActions>
        {!publicUrl && (
          <Button onClick={handleCreateLink} disabled={loading}>
            Create link
          </Button>
        )}
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  );
};
```

Attach this dialog to the conversation view action menu (e.g. a "Share" icon next to the export button).

---

## 39.9. Material 3 UI – Org Data Retention Settings

Route: `/app/orgs/:orgId/settings/retention`

**File:** `apps/web/src/org/RetentionSettingsPage.tsx`

```tsx
// apps/web/src/org/RetentionSettingsPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  Checkbox,
  FormControlLabel,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { useParams } from 'react-router-dom';
import { apiRequest } from '../api/client';
import { useAuth } from '../auth/AuthContext';

interface OrgDataRetentionConfigDto {
  id: string;
  orgId: string;
  maxConversationAgeDays: number | null;
  allowUserDeletion: boolean;
  allowExports: boolean;
  allowShareLinks: boolean;
  hardDeleteAfterDays: number | null;
}

export const RetentionSettingsPage: React.FC = () => {
  const { orgId } = useParams();
  const { token } = useAuth();

  const [config, setConfig] = useState<OrgDataRetentionConfigDto | null>(null);
  const [loading, setLoading] = useState(false);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(45,212,191,0.16), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(129,140,248,0.2), transparent 55%)';

  useEffect(() => {
    if (!token || !orgId) return;

    let cancelled = false;

    async function load() {
      setLoading(true);
      try {
        const res = await apiRequest<{ config: OrgDataRetentionConfigDto | null }>(
          `/orgs/${orgId}/retention`,
          { method: 'GET' },
          token
        );
        if (!cancelled) {
          setConfig(
            res.config || {
              id: 'temp',
              orgId,
              maxConversationAgeDays: null,
              allowUserDeletion: true,
              allowExports: true,
              allowShareLinks: true,
              hardDeleteAfterDays: null
            }
          );
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    }

    void load();

    return () => {
      cancelled = true;
    };
  }, [token, orgId]);

  const handleSave = async () => {
    if (!token || !orgId || !config) return;

    await apiRequest<{ config: OrgDataRetentionConfigDto }>(
      `/orgs/${orgId}/retention`,
      {
        method: 'PUT',
        body: JSON.stringify({
          maxConversationAgeDays: config.maxConversationAgeDays,
          allowUserDeletion: config.allowUserDeletion,
          allowExports: config.allowExports,
          allowShareLinks: config.allowShareLinks,
          hardDeleteAfterDays: config.hardDeleteAfterDays
        })
      },
      token
    );
  };

  if (!config) {
    return null;
  }

  return (
    <Box
      sx={{
        p: 2,
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
        height: '100%',
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Box display="flex" alignItems="center" justifyContent="space-between">
        <Box display="flex" alignItems="center" gap={1}>
          <AutoAwesomeIcon fontSize="small" />
          <Box>
            <Typography variant="h6">Data retention</Typography>
            <Typography variant="caption" color="text.secondary">
              Control how long conversations and exports are kept in this organization.
            </Typography>
          </Box>
        </Box>
        <Button variant="contained" onClick={handleSave} disabled={loading}>
          Save changes
        </Button>
      </Box>

      <Card sx={{ borderRadius: 3 }}>
        <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <TextField
            label="Max conversation age (days)"
            type="number"
            value={config.maxConversationAgeDays ?? ''}
            onChange={(e) =>
              setConfig((prev) =>
                prev
                  ? {
                      ...prev,
                      maxConversationAgeDays: e.target.value
                        ? Number(e.target.value)
                        : null
                    }
                  : prev
              )
            }
            helperText="Conversations older than this will be automatically soft-deleted. Leave empty for no automatic deletion."
          />

          <TextField
            label="Hard delete after (days)"
            type="number"
            value={config.hardDeleteAfterDays ?? ''}
            onChange={(e) =>
              setConfig((prev) =>
                prev
                  ? {
                      ...prev,
                      hardDeleteAfterDays: e.target.value
                        ? Number(e.target.value)
                        : null
                    }
                  : prev
              )
            }
            helperText="Soft-deleted conversations will be permanently removed after this many days. Leave empty to keep them indefinitely."
          />

          <FormControlLabel
            control={
              <Checkbox
                checked={config.allowUserDeletion}
                onChange={(e) =>
                  setConfig((prev) => (prev ? { ...prev, allowUserDeletion: e.target.checked } : prev))
                }
              />
            }
            label="Allow users to delete their own conversations"
          />

          <FormControlLabel
            control={
              <Checkbox
                checked={config.allowExports}
                onChange={(e) =>
                  setConfig((prev) => (prev ? { ...prev, allowExports: e.target.checked } : prev))
                }
              />
            }
            label="Allow conversation exports"
          />

          <FormControlLabel
            control={
              <Checkbox
                checked={config.allowShareLinks}
                onChange={(e) =>
                  setConfig((prev) => (prev ? { ...prev, allowShareLinks: e.target.checked } : prev))
                }
              />
            }
            label="Allow public share links"
          />
        </CardContent>
      </Card>
    </Box>
  );
};
```

Add route:

```tsx
import { RetentionSettingsPage } from './org/RetentionSettingsPage';

<Route path="/app/orgs/:orgId/settings/retention" element={<RetentionSettingsPage />} />
```

---

## 39.10. Public Shared Conversation Viewer UI

A minimalist, **read‑only** view for public shared conversations.

Route: `/s/:slug` in the web app (mapped to `/public/conversations/:slug` API).

**File:** `apps/web/src/public/PublicSharedConversationPage.tsx`

```tsx
// apps/web/src/public/PublicSharedConversationPage.tsx

import React, { useEffect, useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  CircularProgress,
  TextField,
  Typography
} from '@mui/material';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import { useParams } from 'react-router-dom';
import { fetchPublicSharedConversation, PublicSharedConversation } from '../api/sharing';

export const PublicSharedConversationPage: React.FC = () => {
  const { slug } = useParams();

  const [passphrase, setPassphrase] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<PublicSharedConversation | null>(null);

  const gradientBg =
    'radial-gradient(circle at top left, rgba(59,130,246,0.18), transparent 55%), ' +
    'radial-gradient(circle at bottom right, rgba(236,72,153,0.18), transparent 55%)';

  const load = async () => {
    if (!slug) return;
    setLoading(true);
    setError(null);
    try {
      const res = await fetchPublicSharedConversation(slug, passphrase || undefined);
      setData(res);
    } catch (err) {
      setData(null);
      setError((err as Error).message || 'Failed to load conversation');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    void load();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [slug]);

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        p: 2,
        backgroundImage: gradientBg,
        backgroundColor: 'background.default'
      }}
    >
      <Card sx={{ maxWidth: 800, width: '100%', borderRadius: 3 }}>
        <CardContent sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <Box display="flex" alignItems="center" gap={1}>
            <AutoAwesomeIcon fontSize="small" />
            <Box>
              <Typography variant="h6">Shared conversation</Typography>
              <Typography variant="caption" color="text.secondary">
                Read-only view. Content may be anonymized by the owner.
              </Typography>
            </Box>
          </Box>

          {error && (
            <Typography variant="body2" color="error">
              {error}
            </Typography>
          )}

          {loading && (
            <Box display="flex" justifyContent="center" py={4}>
              <CircularProgress size={24} />
            </Box>
          )}

          {!loading && !data && (
            <Box display="flex" flexDirection="column" gap={1}>
              <Typography variant="body2" color="text.secondary">
                If this link is passphrase-protected, please enter the passphrase below.
              </Typography>
              <Box display="flex" gap={1}>
                <TextField
                  label="Passphrase"
                  size="small"
                  fullWidth
                  value={passphrase}
                  onChange={(e) => setPassphrase(e.target.value)}
                />
                <Button variant="contained" onClick={load}>
                  Submit
                </Button>
              </Box>
            </Box>
          )}

          {data && (
            <Box display="flex" flexDirection="column" gap={2}>
              <Box>
                <Typography variant="h6">{data.title}</Typography>
                {data.createdBy && (
                  <Typography variant="caption" color="text.secondary">
                    Shared from {data.createdBy.displayName}
                  </Typography>
                )}
              </Box>

              <Box
                sx={{
                  maxHeight: '60vh',
                  overflow: 'auto',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: 1
                }}
              >
                {data.messages.map((m) => (
                  <Box
                    key={m.id}
                    sx={{
                      alignSelf: m.role === 'user' ? 'flex-end' : 'flex-start',
                      maxWidth: '80%',
                      p: 1.25,
                      borderRadius: 2,
                      bgcolor: m.role === 'user' ? 'primary.main' : 'background.paper',
                      color: m.role === 'user' ? 'primary.contrastText' : 'text.primary',
                      boxShadow: 1
                    }}
                  >
                    <Typography
                      variant="caption"
                      color={m.role === 'user' ? 'primary.contrastText' : 'text.secondary'}
                    >
                      {m.role}
                    </Typography>
                    <Typography
                      variant="body2"
                      sx={{ whiteSpace: 'pre-wrap', mt: 0.5 }}
                    >
                      {m.content}
                    </Typography>
                  </Box>
                ))}
              </Box>
            </Box>
          )}
        </CardContent>
      </Card>
    </Box>
  );
};
```

Add route:

```tsx
import { PublicSharedConversationPage } from './public/PublicSharedConversationPage';

<Route path="/s/:slug" element={<PublicSharedConversationPage />} />
```

---

## 39.11. Observability & Metrics

Integrate exports & sharing with Grafana metrics (28.md):

- `conversation_exports_total{orgId,format,status}` – increment when jobs complete/fail.  
- `conversation_export_latency_ms` – measure `processing` duration per job.  
- `shared_links_total{orgId}` – count of active share links per org.  
- `retention_conversations_deleted_total{orgId,mode}` – soft vs hard delete.

Dashboards:

- Export volume per org & format.  
- Active public share links per org.  
- Retention job activity over time.

---

## 39.12. Sanity Checklist

Before shipping Export & Sharing to production:

- [ ] Prisma migrations for `ConversationExport`, `ConversationShareLink`, `OrgDataRetentionConfig` (and `Conversation.deletedAt`) applied.  
- [ ] Export worker runs and successfully produces files for each format.  
- [ ] Export dialog can create jobs, poll status, and download files.  
- [ ] Share dialog creates links, and public `/s/:slug` view loads conversations correctly.  
- [ ] Org retention settings page correctly updates retention config and worker enforces it.  
- [ ] Metrics for exports, share links, and retention appear in Grafana.

If all checks pass, the AI chat platform now has **professional‑grade export, sharing and retention** comparable to (and more configurable than) ChatGPT’s, fully integrated into the multi‑tenant architecture and Material 3 UI.

---

_End of 39.md – Conversation Export, Sharing & Data Retention – Backend + Material 3 UI_
