

# 15. Per‑Conversation Usage & Token Metrics in the UI

> **Audience:** AI coding assistants (Cursor, Claude Code, ChatGPT, etc.) and human developers.  
> **Goal of this file:** Surface **per‑conversation usage metrics** directly in the chat UI:
>
> - Backend: `GET /conversations/:id/usage` endpoint that aggregates token usage from message metadata.  
> - Frontend API: `getConversationUsage(...)`.  
> - Frontend UI: Material‑3‑style **usage chips** in the chat settings bar (total tokens, completions).  
> - Automatic refresh of usage after each completion.
>
> After following this file, each conversation will show lightweight, always‑up‑to‑date usage info similar to ChatGPT’s per‑chat token counter.

> **Important instructions to AI agents:**
> - This file **extends** `11.md` (metrics), `12.md` (per‑conversation settings), and `14.md` (title & system prompt).  
> - When we say "replace file X", treat the new content as canonical and keep it consistent with previous files.  
> - Do **not** introduce any TODOs or partial implementations.

---

## 15.1. Usage Model – Where the Data Comes From

In `11.md`, we ensured that **assistant messages** persist usage metadata:

- In `apps/api-gateway/src/routes/chat.ts`, assistant messages are created with:

```ts
meta: {
  usage: response.usage ?? null,
  providerMeta: response.providerMeta ?? null
}
```

and similar for streaming.

We will now:

1. Query all assistant messages for a conversation.  
2. Read `meta.usage` (if present).  
3. Sum `promptTokens` and `completionTokens`.  
4. Compute: `totalTokens = promptTokens + completionTokens`.  
5. Expose the result via `GET /conversations/:id/usage`.

The endpoint will **not** be Prometheus‑backed; it uses the DB to keep implementation simple and localized per conversation.

---

## 15.2. Backend – Conversation Usage Endpoint

We extend the existing `conversations` routes with a new `GET /conversations/:id/usage` endpoint.

> **Important:** This section **replaces** `apps/api-gateway/src/routes/conversations.ts` created in `12.md` with an updated version that adds the usage route.  
> It preserves all previous behaviors (list, create, get, patch) and adds the new usage aggregation.

### 15.2.1. Replace `apps/api-gateway/src/routes/conversations.ts`

```ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { prisma } from '@ai-chat/db';
import { JwtPayload } from '../auth/types';
import { z } from 'zod';

const createConversationBodySchema = z.object({
  title: z.string().min(1).max(200).optional(),
  systemPrompt: z.string().max(8000).optional(),
  model: z.string().max(200).optional(),
  temperature: z.number().min(0).max(2).optional(),
  topP: z.number().min(0).max(1).optional()
});

const updateConversationBodySchema = z.object({
  title: z.string().min(1).max(200).optional(),
  systemPrompt: z.string().max(8000).nullable().optional(),
  model: z.string().max(200).nullable().optional(),
  temperature: z.number().min(0).max(2).nullable().optional(),
  topP: z.number().min(0).max(1).nullable().optional()
});

function getUserOrgIds(userId: string) {
  return prisma.orgMember
    .findMany({
      where: { userId },
      select: { orgId: true }
    })
    .then((rows) => rows.map((r) => r.orgId));
}

export default async function conversationsRoutes(app: FastifyInstance, _opts: FastifyPluginOptions) {
  // List conversations visible to the user (own + orgs)
  app.get('/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const orgIds = await getUserOrgIds(payload.userId);
    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversations = await prisma.conversation.findMany({
      where: {
        OR: orConditions
      },
      orderBy: {
        updatedAt: 'desc'
      },
      take: 100
    });

    return reply.send({
      conversations: conversations.map((c) => ({
        id: c.id,
        title: c.title,
        model: c.model,
        createdAt: c.createdAt,
        updatedAt: c.updatedAt,
        orgId: c.orgId
      }))
    });
  });

  // Create conversation
  app.post('/conversations', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const parseBody = createConversationBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid conversation data', details: parseBody.error.format() });
    }

    const { title, systemPrompt, model, temperature, topP } = parseBody.data;

    const conversation = await prisma.conversation.create({
      data: {
        title: title ?? null,
        systemPrompt: systemPrompt ?? null,
        model: model ?? null,
        temperature: temperature ?? null,
        topP: topP ?? null,
        userId: payload.userId,
        orgId: null
      }
    });

    return reply.code(201).send({
      id: conversation.id,
      title: conversation.title,
      model: conversation.model,
      createdAt: conversation.createdAt,
      updatedAt: conversation.updatedAt,
      orgId: conversation.orgId
    });
  });

  // Get conversation with messages
  app.get('/conversations/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }

    const conversationId = parseParams.data.id;

    const orgIds = await getUserOrgIds(payload.userId);
    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
          take: 200
        }
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    return reply.send({
      conversation: {
        id: conversation.id,
        title: conversation.title,
        model: conversation.model,
        systemPrompt: conversation.systemPrompt,
        temperature: conversation.temperature,
        topP: conversation.topP,
        createdAt: conversation.createdAt,
        updatedAt: conversation.updatedAt,
        orgId: conversation.orgId,
        messages: conversation.messages.map((m) => ({
          id: m.id,
          role: m.role,
          content: m.content,
          createdAt: m.createdAt
        }))
      }
    });
  });

  // Patch conversation settings (title/model/systemPrompt/temperature/topP)
  app.patch('/conversations/:id', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }
    const conversationId = parseParams.data.id;

    const parseBody = updateConversationBodySchema.safeParse(request.body);
    if (!parseBody.success) {
      return reply.code(400).send({ error: 'Invalid conversation update', details: parseBody.error.format() });
    }

    const orgIds = await getUserOrgIds(payload.userId);
    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const existing = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      }
    });

    if (!existing) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    const data: any = {};

    if ('title' in parseBody.data) {
      data.title = parseBody.data.title ?? null;
    }
    if ('systemPrompt' in parseBody.data) {
      data.systemPrompt = parseBody.data.systemPrompt ?? null;
    }
    if ('model' in parseBody.data) {
      data.model = parseBody.data.model ?? null;
    }
    if ('temperature' in parseBody.data) {
      data.temperature = parseBody.data.temperature ?? null;
    }
    if ('topP' in parseBody.data) {
      data.topP = parseBody.data.topP ?? null;
    }

    const updated = await prisma.conversation.update({
      where: { id: conversationId },
      data: {
        ...data,
        updatedAt: new Date()
      }
    });

    return reply.send({
      conversation: {
        id: updated.id,
        title: updated.title,
        model: updated.model,
        systemPrompt: updated.systemPrompt,
        temperature: updated.temperature,
        topP: updated.topP,
        createdAt: updated.createdAt,
        updatedAt: updated.updatedAt,
        orgId: updated.orgId
      }
    });
  });

  // Usage summary for a conversation (aggregated from assistant messages)
  app.get('/conversations/:id/usage', { preHandler: [app.authenticate] }, async (request, reply) => {
    const payload = request.user as JwtPayload;

    const paramsSchema = z.object({ id: z.string().min(1) });
    const parseParams = paramsSchema.safeParse(request.params);
    if (!parseParams.success) {
      return reply.code(400).send({ error: 'Invalid conversation id' });
    }

    const conversationId = parseParams.data.id;

    const orgIds = await getUserOrgIds(payload.userId);
    const orConditions: any[] = [{ userId: payload.userId }];
    if (orgIds.length > 0) {
      orConditions.push({ orgId: { in: orgIds } });
    }

    const conversation = await prisma.conversation.findFirst({
      where: {
        id: conversationId,
        OR: orConditions
      },
      select: {
        id: true
      }
    });

    if (!conversation) {
      return reply.code(404).send({ error: 'Conversation not found' });
    }

    const messages = await prisma.message.findMany({
      where: {
        conversationId,
        role: 'ASSISTANT'
      },
      select: {
        meta: true,
        createdAt: true
      },
      orderBy: {
        createdAt: 'asc'
      }
    });

    let totalPromptTokens = 0;
    let totalCompletionTokens = 0;
    let completions = 0;
    let lastMessageAt: Date | null = null;

    for (const m of messages) {
      const meta: any = m.meta ?? {};
      const usage = meta?.usage;

      if (usage && typeof usage === 'object') {
        const promptTokens = typeof usage.promptTokens === 'number' ? usage.promptTokens : 0;
        const completionTokens = typeof usage.completionTokens === 'number' ? usage.completionTokens : 0;

        totalPromptTokens += promptTokens;
        totalCompletionTokens += completionTokens;
        completions += 1;

        if (!lastMessageAt || m.createdAt > lastMessageAt) {
          lastMessageAt = m.createdAt;
        }
      }
    }

    const totalTokens = totalPromptTokens + totalCompletionTokens;

    return reply.send({
      conversationId,
      totals: {
        promptTokens: totalPromptTokens,
        completionTokens: totalCompletionTokens,
        totalTokens
      },
      completions,
      lastMessageAt
    });
  });
}
```

This endpoint is intentionally simple and efficient:

- Only ASSISTANT messages are scanned.  
- It ignores messages with missing or malformed `usage`.  
- It enforces the same **access control** as `GET /conversations/:id`.

---

## 15.3. Frontend API – `getConversationUsage`

We now extend the frontend conversations API module to support the new usage endpoint.

> **Important:** This section **replaces** `apps/web/src/api/conversations.ts` and keeps all existing functions while adding the new one.

### 15.3.1. Replace `apps/web/src/api/conversations.ts`

```ts
import { apiRequest } from './client';

export interface ConversationListItem {
  id: string;
  title: string | null;
  model: string | null;
  createdAt: string;
  updatedAt: string;
  orgId: string | null;
}

export interface ConversationMessage {
  id: string;
  role: string;
  content: string;
  createdAt: string;
}

export interface ConversationDetails {
  id: string;
  title: string | null;
  model: string | null;
  systemPrompt: string | null;
  temperature: number | null;
  topP: number | null;
  createdAt: string;
  updatedAt: string;
  orgId: string | null;
  messages: ConversationMessage[];
}

export async function listConversations(token: string): Promise<{ conversations: ConversationListItem[] }> {
  return apiRequest<{ conversations: ConversationListItem[] }>('/conversations', { method: 'GET' }, token);
}

export async function createConversation(
  token: string,
  data: { title?: string; systemPrompt?: string; model?: string; temperature?: number; topP?: number }
): Promise<ConversationListItem> {
  const result = await apiRequest<ConversationListItem>(
    '/conversations',
    {
      method: 'POST',
      body: JSON.stringify(data)
    },
    token
  );
  return result;
}

export async function getConversation(token: string, id: string): Promise<{ conversation: ConversationDetails }> {
  return apiRequest<{ conversation: ConversationDetails }>(`/conversations/${id}`, { method: 'GET' }, token);
}

export interface UpdateConversationPayload {
  title?: string | null;
  systemPrompt?: string | null;
  model?: string | null;
  temperature?: number | null;
  topP?: number | null;
}

export async function updateConversation(
  token: string,
  id: string,
  data: UpdateConversationPayload
): Promise<{ conversation: ConversationDetails }> {
  return apiRequest<{ conversation: ConversationDetails }>(
    `/conversations/${id}`,
    {
      method: 'PATCH',
      body: JSON.stringify(data)
    },
    token
  );
}

export interface ConversationUsageTotals {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

export interface ConversationUsageSummary {
  conversationId: string;
  totals: ConversationUsageTotals;
  completions: number;
  lastMessageAt: string | null;
}

export async function getConversationUsage(
  token: string,
  id: string
): Promise<ConversationUsageSummary> {
  return apiRequest<ConversationUsageSummary>(`/conversations/${id}/usage`, { method: 'GET' }, token);
}
```

---

## 15.4. Frontend UI – Usage Chips in `ChatPage`

We now surface the usage summary inside the chat settings bar.

> **Important:** This section **replaces** `apps/web/src/chat/ChatPage.tsx` created in `14.md`.  
> The new version keeps **all previous features** (inline title editing, system prompt drawer, model/temperature/top‑p) and adds usage chips.

### 15.4.1. Replace `apps/web/src/chat/ChatPage.tsx`

```tsx
[...see full markdown for complete ChatPage.tsx code...]
```

This implementation:

- Fetches **conversation details + usage** whenever a conversation is selected.  
- Shows usage chips with total tokens and completions; uses a subtle `…` state while loading.  
- Refreshes usage after each sent message and completion.  
- Preserves all features from `12.md` and `14.md` (title editing, system prompt drawer, model/temperature/top‑p controls).

---

## 15.5. Sanity Checks

From the repo root:

1. **Install dependencies (if not already):**

   ```bash
   pnpm install
   ```

2. **Run API gateway:**

   ```bash
   pnpm dev --filter=api-gateway
   ```

3. **Run web app:**

   ```bash
   cd apps/web
   pnpm dev
   ```

4. **Verify usage endpoint:**

   Use your HTTP client (or `curl`) with a valid JWT:

   ```bash
   curl -H "Authorization: Bearer &lt;token&gt;" \
     http://localhost:4000/conversations/&lt;conversationId&gt;/usage
   ```

   You should see JSON like:

   ```json
   {
     "conversationId": "...",
     "totals": {
       "promptTokens": 1200,
       "completionTokens": 3400,
       "totalTokens": 4600
     },
     "completions": 12,
     "lastMessageAt": "2025-12-06T16:31:22.000Z"
   }
   ```

5. **Verify UI behavior:**

   - Open `http://localhost:5173` and sign in.  
   - Go to `/app`, select a conversation.  
   - The top bar should show usage chips: e.g. `Tokens: 4600`, `Completions: 12`.  
   - Send a few new messages; after the assistant responds, the numbers should increase.

If all checks pass, your chat UI now exposes **per‑conversation usage metrics** in a clean, Material‑3‑inspired way.

---

## 15.6. Next Steps

Future markdown files can extend this further by:

- Surfacing **latency statistics** per conversation (e.g., average / p95 completion time).  
- Adding an **org‑level analytics overview** page that aggregates usage for all conversations in an org.  
- Wiring these stats into **billing & quotas** for multi‑tenant pricing.

> **AI Agent Instruction:**  
> Before moving on, ensure `GET /conversations/:id/usage` compiles and works, and the usage chips update correctly when sending new messages.

---

_End of 15.md – Per‑Conversation Usage & Token Metrics in the UI_
